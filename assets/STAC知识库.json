{
  "ACL": {
    "threats": [
      {
        "name": "ACL绕过",
        "details": "",
        "security_requirement": {
          "name": "ACL绕过",
          "details": "确保访问控制列表（ACL）能够有效地限制对系统资源的访问，并防止恶意用户通过绕过ACL来获取未授权的访问权限。\n加强对ACL规则的设计和实施，防止ACL绕过导致的安全漏洞和数据泄露。"
        },
        "security_design": {
          "name": "ACL绕过",
          "details": "最小权限设置：\n基于最小权限原则进行 ACL 规则配置，只赋予用户执行其工作任务必需的资源访问权限，避免过度授权。\n资源分类分级：\n对不同资源分类分级，制定精细化的 ACL 规则，明确各角色、用户组在不同层级资源上的具体访问权限。\nACL 规则实施与验证：\n在程序开发阶段，嵌入严格的权限校验代码，确保每次资源访问请求都对照 ACL 规则进行准确验证，不符合规则的请求立即阻断。\n监控与告警机制：\n配置告警功能，一旦发现疑似 ACL 绕过的异常访问，及时向安全运维团队发送告警信息，以便快速响应处置。"
        },
        "test_case": {
          "name": "ACL绕过",
          "details": "测试方法：使用普通用户的账号访问管理员用户的特有功能或链接；\n预期结果：系统应该能够拒绝该访问请求。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "API密钥认证": {
    "threats": [
      {
        "name": "密钥劫持",
        "details": "",
        "security_requirement": {
          "name": "密钥劫持",
          "details": "确保 API 密钥的安全性，防止被恶意获取或滥用。\n加强对 API 访问的身份验证和授权，确保只有合法用户能够访问受保护的 API。"
        },
        "security_design": {
          "name": "密钥劫持",
          "details": "API 密钥生成安全：\n采用高强度随机数生成算法创建 API 密钥，结合时间戳、特定字符等元素，确保密钥的复杂性与唯一性，降低被暴力破解或猜测的风险，为其安全性奠定基础。\n传输加密措施：\n在 API 密钥于客户端与服务器端传输时，强制运用 HTTPS 等安全协议进行加密传输，防止密钥在网络传输途中被窃取，保障传输过程的保密性与完整性。\n存储安全机制：\n服务器端存储 API 密钥时，利用数据库加密功能或专用的密钥管理系统进行加密存储，并设置严格的访问权限，仅允许特定的授权服务或模块访问，防止因存储介质被攻破而导致密钥泄露。\n身份验证与授权强化：\n建立多重身份验证机制，如结合 API 密钥与用户密码、短信验证码或生物识别信息等进行综合验证。同时，细化授权策略，根据用户角色、IP 地址范围等因素，精确控制对不同 API 资源的访问权限，确保只有合法且经过授权的用户能够访问相应的 API，有效防止 API 密钥被恶意获取或滥用。"
        },
        "test_case": {
          "name": "密钥劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有密钥验证的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      },
      {
        "name": "密钥泄露",
        "details": "如果密钥被硬编码在代码中，一旦代码泄露或被逆向工程，攻击者可能会获取到密钥，从而对系统造成威胁，同时也增加了维护的复杂性。如果本地配置文件没有受到足够的保护，可能存在被泄露和篡改的风险，其中的密钥也会被泄露及篡改，导致敏感数据泄露或被攻击。",
        "security_requirement": {
          "name": "密钥泄露",
          "details": "确保 API 密钥的安全性，防止泄露给未经授权的第三方。\n加强对 API 密钥的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "密钥泄露",
          "details": "密钥生成强化：\n采用强加密算法与随机因子生成 API 密钥，使其具备高度复杂性与不可预测性，降低被破解获取的概率，构建密钥安全的首道防线。\n传输加密保障：\n借助安全传输协议如 HTTPS 传输 API 密钥，对其加密打包，防止在网络链路中被窃取，确保传输阶段的保密性与完整性。\n存储安全管控：\n利用加密存储技术与严格访问权限设置，将 API 密钥存储于安全区域，无论是数据库存储还是本地存储，都防止因存储介质暴露而引发泄露。\n定期更新机制：\n设定 API 密钥定期更新周期，促使使用者定期更换密钥，减少长期使用同一密钥带来的泄露风险，降低潜在危害的持续性。\n异常监测响应：\n搭建密钥使用异常监测体系，实时追踪密钥使用的频率、来源等，一旦发现异常，如短时间内异地频繁使用，立即暂停密钥并通知相关方，及时应对泄露危机。"
        },
        "test_case": {
          "name": "密钥泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有密钥验证的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      },
      {
        "name": "密钥存储安全",
        "details": "",
        "security_requirement": {
          "name": "密钥存储安全",
          "details": "确保密钥在存储和传输过程中的机密性和完整性。\n防止未经授权的访问和使用敏感密钥。"
        },
        "security_design": {
          "name": "密钥存储安全",
          "details": "存储加密：\n采用专业加密算法对密钥加密后存储，如 AES 算法，搭配安全的密钥管理系统，将其存于独立且有严格访问控制的区域，防止存储时被窃取，保障机密性与完整性。\n传输防护：\n运用安全传输协议（如 TLS/SSL）传输密钥，对其加密打包，杜绝传输中遭拦截篡改，同时认证通信双方身份，避免未经授权访问。\n权限管理：\n设置精细的权限体系，只允许特定授权角色对密钥进行操作，定期审计权限使用情况，确保密钥不被违规使用。"
        },
        "test_case": {
          "name": "密钥存储安全",
          "details": "测试方法：咨询开发，了解应用程序是否使用安全的加密方法存储密钥，如硬件安全模块（HSM）或密钥管理服务（KMS）。\n预期结果：密钥应加密安全存储，受加密保护，只有授权的应用程序或用户才能访问。"
        },
        "industry_standard": {
          "name": "密码安全",
          "details": null
        }
      }
    ]
  },
  "DOM 解析（Document Object Model）": {
    "threats": [
      {
        "name": "解析器漏洞",
        "details": "",
        "security_requirement": {
          "name": "解析器漏洞",
          "details": "保护解析器的安全性，防止解析器被恶意输入滥用。\n加强对解析器的配置和使用，及时修补解析器的安全漏洞。"
        },
        "security_design": {
          "name": "解析器漏洞",
          "details": "代码审查与优化：\n在开发过程中，对涉及解析器相关的代码开展严谨的审查工作。检查代码逻辑是否严谨，是否存在可被恶意输入利用的薄弱环节，比如对输入数据处理时边界条件判断不足、错误的类型转换等情况，及时发现并修正代码缺陷，从代码层面增强解析器安全性。\n安全编码规范遵循：\n开发团队要严格遵循安全编码规范，在编写解析器相关代码时，采用安全的函数、方法来处理输入和执行解析操作，避免使用容易引发安全问题的过时或不安全的编程方式，例如避免使用存在已知漏洞的库函数，以此保障解析器代码本身的质量与安全性。\n输入处理模块开发：\n精心设计解析器的输入处理模块，将输入验证、过滤、格式化等功能整合其中。运用正则表达式、类型校验等技术手段，确保输入到解析器的内容符合预期要求，能够有效阻挡恶意构造的输入数据，同时对合法输入进行规范处理后再传递给解析器主体部分进行解析。\n版本管理与更新整合：\n在开发的版本管理体系中，将解析器安全漏洞修复与版本更新紧密结合起来。当发现解析器存在安全问题需要修补时，及时在版本控制系统中标记、记录相关变更，确保更新后的版本能将修补后的解析器正确部署到相应环境中，让开发、测试、生产等各环节都能使用到修复好漏洞的解析器版本。\n"
        },
        "test_case": {
          "name": "解析器漏洞",
          "details": "测试方法：在应用系统可以输入的位置尝试输入如下内容，查看是否正常响应。\n<!DOCTYPE foo [<!ELEMENT foo ANY>\n    <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<foo>&xxe;</foo>\n预期结果：如果目标系统存在解析器漏洞，可能导致解析器崩溃、拒绝服务或执行恶意代码等安全问题。系统应该及时更新解析器版本，或者实施输入验证和过滤等措施来防止解析器漏洞的利用。"
        },
        "industry_standard": null
      }
    ]
  },
  "H5本地资源缓存": {
    "threats": [
      {
        "name": "代码信息泄露",
        "details": "",
        "security_requirement": {
          "name": "代码信息泄露",
          "details": "防止敏感代码信息泄露，包括源代码、配置文件、注释等，以避免攻击者获取系统架构和逻辑信息，从而进行更精确的攻击。"
        },
        "security_design": {
          "name": "代码信息泄露",
          "details": "代码混淆：\n对源代码进行混淆处理，通过重命名变量、函数等标识符，打乱代码逻辑结构，让攻击者难以直接读懂代码内容，增加逆向分析获取有效信息的难度，保护代码逻辑不被轻易窥探。\n访问权限控制：\n严格限制对源代码、配置文件存储位置的访问权限，依据职责和工作需求，仅允许相关的开发、运维等授权人员进行查看、修改，禁止非授权访问，防止内部人员误操作或外部攻击者直接获取敏感代码信息。\n生产环境清理：\n在将代码部署到生产环境前，仔细去除不必要的调试信息、注释内容以及测试相关代码，确保生产环境中留存的都是与实际运行相关且不包含敏感信息的代码，减少可被攻击者利用的信息暴露。\n加密存储：\n对于包含敏感信息的配置文件，采用加密的方式进行存储，只有在运行时通过安全的解密机制、凭借正确的密钥才能获取并使用其中的内容，防止配置信息被窃取查看。\n网络隔离：\n划分不同的网络区域，将开发环境、测试环境与生产环境进行有效隔离，限制不同区域间随意的数据传输，避免因网络安全漏洞导致代码信息从相对安全的区域泄露到外部，增加整体防护层级。\n版本管理安全：\n在使用代码版本管理工具（如 Git 等）时，合理配置访问权限，设置强密码和多因素认证，对重要的代码仓库设置为私有，同时定期审查版本管理系统中的操作记录，防止代码被非法下载或查看。"
        },
        "test_case": {
          "name": "代码信息泄露",
          "details": "测试方法：查看源码中是否存在Git存储库地址、账户、数据库凭据、API密钥等信息。\n预期结果：不存在。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      },
      {
        "name": "敏感文件泄露",
        "details": "",
        "security_requirement": {
          "name": "敏感文件泄露",
          "details": "确保敏感文件的机密性和完整性，防止未经授权的访问和泄露。\n实施适当的访问控制和安全监控，及时发现并应对敏感文件泄露事件。"
        },
        "security_design": {
          "name": "敏感文件泄露",
          "details": "文件加密存储：\n采用专业加密算法（如 AES 等）对敏感文件加密后再存储，添加校验码确保完整性。这样即便存储介质遭入侵，文件内容也难被获取与篡改，保障机密性与完整性。\n访问权限设置：\n依据用户角色、业务需求精细划分访问权限，只允许授权人员操作敏感文件，且采用多因素认证加强访问把关，防止未经授权访问。\n安全监控搭建：\n构建文件访问监控系统，实时追踪操作记录，分析访问频次、来源等。发现异常访问行为，像短时间批量下载等情况，立即告警并采取措施应对泄露风险。"
        },
        "test_case": {
          "name": "敏感文件泄露",
          "details": "测试方法：尝试在应用程序的URL中带传参的参数中直接输入\"../../../etc/passwd\"或web.config等，查看能否直接下载。\n预期结果：系统应拒绝未经授权的访问，敏感文件应受到严格保护，无法通过应用程序直接访问或下载。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      },
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      }
    ]
  },
  "H5交互（针对新上线）": {
    "threats": [
      {
        "name": "代码信息泄露",
        "details": "",
        "security_requirement": {
          "name": "代码信息泄露",
          "details": "防止敏感代码信息泄露，包括源代码、配置文件、注释等，以避免攻击者获取系统架构和逻辑信息，从而进行更精确的攻击。"
        },
        "security_design": {
          "name": "代码信息泄露",
          "details": "代码混淆：\n对源代码进行混淆处理，通过重命名变量、函数等标识符，打乱代码逻辑结构，让攻击者难以直接读懂代码内容，增加逆向分析获取有效信息的难度，保护代码逻辑不被轻易窥探。\n访问权限控制：\n严格限制对源代码、配置文件存储位置的访问权限，依据职责和工作需求，仅允许相关的开发、运维等授权人员进行查看、修改，禁止非授权访问，防止内部人员误操作或外部攻击者直接获取敏感代码信息。\n生产环境清理：\n在将代码部署到生产环境前，仔细去除不必要的调试信息、注释内容以及测试相关代码，确保生产环境中留存的都是与实际运行相关且不包含敏感信息的代码，减少可被攻击者利用的信息暴露。\n加密存储：\n对于包含敏感信息的配置文件，采用加密的方式进行存储，只有在运行时通过安全的解密机制、凭借正确的密钥才能获取并使用其中的内容，防止配置信息被窃取查看。\n网络隔离：\n划分不同的网络区域，将开发环境、测试环境与生产环境进行有效隔离，限制不同区域间随意的数据传输，避免因网络安全漏洞导致代码信息从相对安全的区域泄露到外部，增加整体防护层级。\n版本管理安全：\n在使用代码版本管理工具（如 Git 等）时，合理配置访问权限，设置强密码和多因素认证，对重要的代码仓库设置为私有，同时定期审查版本管理系统中的操作记录，防止代码被非法下载或查看。"
        },
        "test_case": {
          "name": "代码信息泄露",
          "details": "测试方法：查看源码中是否存在Git存储库地址、账户、数据库凭据、API密钥等信息。\n预期结果：不存在。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      }
    ]
  },
  "HTTP Strict Transport Security（HSTS）（针对新上线）": {
    "threats": [
      {
        "name": "HSTS绕过",
        "details": "",
        "security_requirement": {
          "name": "HSTS绕过",
          "details": "确保网站的HSTS策略能够有效地防止中间人攻击和SSL剥离攻击，保护用户数据在传输过程中的安全性和完整性。\n加强对HSTS策略的安全设计和实施，防止HSTS绕过导致的安全漏洞和数据泄露问题。"
        },
        "security_design": {
          "name": "HSTS绕过",
          "details": "HSTS 策略制定与部署：\n合理设置 HSTS 策略的最大年龄（max-age）参数，选择较长且合适的时长，确保浏览器能在较长时间内强制使用 HTTPS 进行连接，减少被绕过的机会。\n在网站的所有相关域名（包括子域名等）上统一、全面地部署 HSTS 策略，避免出现策略覆盖不全的情况，不给攻击者留下可利用的薄弱环节。\n服务器 SSL/TLS 配置强化：\n对网站服务器的 SSL/TLS 配置进行严格优化，采用最新且安全可靠的加密算法和协议版本，增强连接的安全性，使得攻击者难以突破 HSTS 防护进行中间人攻击等。\n网站代码安全校验逻辑嵌入：\n在网站代码中嵌入额外的安全校验逻辑，例如在页面加载、资源请求等环节再次验证连接是否遵循 HSTS 要求，若发现异常及时阻断并提示用户。\n连接监控与应急响应机制：\n建立针对网站连接情况的实时监控体系，重点关注是否存在不符合 HSTS 策略的连接请求，分析其来源、特征等信息，及时察觉潜在的 HSTS 绕过行为。\n一旦监测到有疑似 HSTS 绕过的情况发生，迅速启动应急响应流程，一方面阻断相关异常连接，另一方面向运维和安全团队发送告警信息，以便及时进行漏洞排查、修复以及溯源等工作，防止数据泄露和安全风险进一步扩大。"
        },
        "test_case": {
          "name": "HSTS绕过",
          "details": "测试方法：使用HTTP方式访问HTTPS的地址，查看是否能访问成功。\n预期结果：自动跳转 HTTPS 访问或拒绝访问提示网站开启 HSTS。"
        },
        "industry_standard": null
      }
    ]
  },
  "IoT客户端（针对新上线）": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      }
    ]
  },
  "Java 中的反序列化": {
    "threats": [
      {
        "name": "序列化漏洞",
        "details": "",
        "security_requirement": {
          "name": "序列化漏洞",
          "details": "使用安全的组件和中间件。"
        },
        "security_design": {
          "name": "序列化漏洞",
          "details": "组件选型：\n在项目开发中，优先选用经过安全验证、更新及时且社区维护活跃的序列化组件和中间件，像知名且安全口碑好的 JSON 序列化库等，避免使用存在已知漏洞或已停止更新维护的老旧版本，从源头降低序列化漏洞风险。\n版本更新：\n定期关注所使用的序列化相关组件、中间件的官方更新动态，及时升级到修复了安全漏洞的最新版本，确保其在处理序列化操作时能抵御各类可能的攻击，保障系统安全稳定运行，防止因版本滞后而出现可被利用的序列化漏洞。\n安全配置：\n依据官方推荐及安全最佳实践，对选用的组件和中间件进行合理安全配置，比如设置严格的反序列化白名单，限定可接受的序列化数据类型及来源，精准管控序列化过程，避免因配置不当引发序列化漏洞。\n"
        },
        "test_case": {
          "name": "序列化漏洞",
          "details": "测试方法：专用工具或安全扫码工具。"
        },
        "industry_standard": null
      }
    ]
  },
  "JSON 解析器": {
    "threats": [
      {
        "name": "解析器漏洞",
        "details": "",
        "security_requirement": {
          "name": "解析器漏洞",
          "details": "保护解析器的安全性，防止解析器被恶意输入滥用。\n加强对解析器的配置和使用，及时修补解析器的安全漏洞。"
        },
        "security_design": {
          "name": "解析器漏洞",
          "details": "代码审查与优化：\n在开发过程中，对涉及解析器相关的代码开展严谨的审查工作。检查代码逻辑是否严谨，是否存在可被恶意输入利用的薄弱环节，比如对输入数据处理时边界条件判断不足、错误的类型转换等情况，及时发现并修正代码缺陷，从代码层面增强解析器安全性。\n安全编码规范遵循：\n开发团队要严格遵循安全编码规范，在编写解析器相关代码时，采用安全的函数、方法来处理输入和执行解析操作，避免使用容易引发安全问题的过时或不安全的编程方式，例如避免使用存在已知漏洞的库函数，以此保障解析器代码本身的质量与安全性。\n输入处理模块开发：\n精心设计解析器的输入处理模块，将输入验证、过滤、格式化等功能整合其中。运用正则表达式、类型校验等技术手段，确保输入到解析器的内容符合预期要求，能够有效阻挡恶意构造的输入数据，同时对合法输入进行规范处理后再传递给解析器主体部分进行解析。\n版本管理与更新整合：\n在开发的版本管理体系中，将解析器安全漏洞修复与版本更新紧密结合起来。当发现解析器存在安全问题需要修补时，及时在版本控制系统中标记、记录相关变更，确保更新后的版本能将修补后的解析器正确部署到相应环境中，让开发、测试、生产等各环节都能使用到修复好漏洞的解析器版本。\n"
        },
        "test_case": {
          "name": "解析器漏洞",
          "details": "测试方法：在应用系统可以输入的位置尝试输入如下内容，查看是否正常响应。\n<!DOCTYPE foo [<!ELEMENT foo ANY>\n    <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<foo>&xxe;</foo>\n预期结果：如果目标系统存在解析器漏洞，可能导致解析器崩溃、拒绝服务或执行恶意代码等安全问题。系统应该及时更新解析器版本，或者实施输入验证和过滤等措施来防止解析器漏洞的利用。"
        },
        "industry_standard": null
      }
    ]
  },
  "JWT认证": {
    "threats": [
      {
        "name": "JWT劫持",
        "details": "",
        "security_requirement": {
          "name": "JWT劫持",
          "details": "确保JWT令牌的安全性和可靠性，防止被恶意用户劫持和滥用。\n加强对JWT令牌的保护和管理，防止未经授权的访问和操作。"
        },
        "security_design": {
          "name": "JWT劫持",
          "details": "JWT 生成与加密：\n使用强加密算法（如 HMAC-SHA256 或 RSA）生成 JWT 签名，确保令牌的完整性和不可篡改性，防止攻击者修改令牌内容。\n对 JWT 中的敏感信息（如用户身份标识等）进行加密处理，避免信息在传输或存储过程中被窃取和利用。\n令牌传输安全：\n强制要求在安全的网络通道（如 HTTPS）上传输 JWT 令牌，防止令牌在网络传输过程中被劫持和窃取。\n在令牌传输过程中，添加额外的安全校验机制，如时间戳验证，确保令牌的时效性和新鲜度，防止重放攻击。\n存储与访问控制：\n在服务器端，对 JWT 令牌的存储进行严格的访问控制，只有授权的服务或模块才能读取和验证令牌。\n在客户端，指导用户合理设置浏览器或应用的安全选项，防止本地存储的 JWT 令牌被第三方恶意获取。\n令牌验证与失效处理：\n服务器端在接收到 JWT 令牌时，进行全面的验证，包括签名验证、有效期验证、受众验证等，确保令牌的合法性和有效性。\n一旦检测到令牌存在异常或已被泄露，及时将令牌列入黑名单并通知相关系统和用户，使该令牌失效，防止进一步的恶意使用。\n监控与预警：\n建立 JWT 令牌使用的监控系统，实时跟踪令牌的生成、传输、验证和使用情况，分析异常行为模式。\n当发现可疑的 JWT 劫持行为，如大量无效令牌尝试或异常的令牌使用地点等，立即触发预警机制，通知安全团队进行调查和应对。"
        },
        "test_case": {
          "name": "JWT劫持",
          "details": "测试方法：使用 Fiddler 修改数据包，替换旧的JWT令牌尝试访问系统资源。\n预期结果：系统应拒绝访问请求，或报相应的错误。"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      },
      {
        "name": "JWT泄露",
        "details": "",
        "security_requirement": {
          "name": "JWT泄露",
          "details": "确保JWT令牌的安全性和保密性，防止令牌被恶意用户窃取。\n加强对JWT令牌的保护和管理，减少令牌泄露的风险。"
        },
        "security_design": {
          "name": "JWT泄露",
          "details": "令牌生成强化：\n采用高强度加密算法生成 JWT 签名，确保签名难以被伪造或篡改，增强令牌自身安全性。\n避免在令牌中包含过多敏感信息，遵循最小化原则，仅保留必要的身份验证相关数据，降低泄露风险。\n传输安全保障：\n强制启用 HTTPS 协议传输 JWT 令牌，加密传输通道，防止令牌在网络传输过程中被嗅探窃取。\n对传输的令牌添加时间戳与随机数等额外信息，并在接收端进行验证，防范重放攻击与中间人攻击导致的泄露。\n存储安全管控：\n服务器端存储 JWT 令牌时，采用安全的存储机制，如加密数据库或受保护的内存区域，限制访问权限，仅允许授权组件读取。\n客户端存储令牌时，优先选择安全的本地存储方式，如浏览器的安全本地存储 API，并设置合适的访问限制，防止其他应用非法获取。\n定期令牌更新：\n设定合理的令牌有效期，并定期为用户更新令牌，减少令牌长期暴露在外的时间，降低泄露后被恶意利用的时长。\n监控与响应机制：\n建立对 JWT 令牌使用情况的监控体系，记录令牌的生成、传输、使用等关键环节信息，及时发现异常使用模式或疑似泄露迹象。\n一旦检测到可能的令牌泄露事件，立即触发应急响应流程，包括使泄露令牌失效、通知相关用户重新登录获取新令牌、对相关系统进行安全检查与漏洞修复等操作，防止进一步的安全风险。"
        },
        "test_case": {
          "name": "JWT泄露",
          "details": "测试方法：使用 Fiddler 修改数据包，替换旧的JWT令牌尝试访问系统资源。\n预期结果：系统应拒绝访问请求，或报相应的错误。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      }
    ]
  },
  "OAuth认证": {
    "threats": [
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      }
    ]
  },
  "RBAC": {
    "threats": [
      {
        "name": "服务权限控制",
        "details": "",
        "security_requirement": {
          "name": "服务权限控制",
          "details": "使用普通权限的运行服务"
        },
        "security_design": {
          "name": "服务权限控制",
          "details": "最小权限原则应用：\n详细梳理服务所需的各类操作权限，严格按照最小权限原则为服务分配权限。例如，仅赋予服务读取其运行必需配置文件的权限，而非整个文件系统的读取权限；仅允许服务与特定数据库表进行交互，且限制其操作类型为仅查询或仅特定条件下的更新，避免赋予不必要的增删改权限。\n权限分组与角色管理：\n将服务可能涉及的权限进行分类分组，创建与之对应的角色。每个服务仅关联其实际所需的角色，而非直接分配大量零散权限。通过角色的集中管理和调整，便于权限的统一管控和审计，降低因权限设置混乱导致的安全风险。\n权限动态调整机制：\n根据服务的运行状态和业务需求变化，建立动态的权限调整机制。例如，在服务进行非关键数据处理阶段，可适当降低其部分权限；当服务需要执行特定重要任务时，临时提升其所需的最小权限范围，任务完成后及时恢复原有权限设置，确保服务权限始终处于合理且安全的状态。"
        },
        "test_case": {
          "name": "服务权限控制",
          "details": "测试方法：咨询发布人员，是否以非 root 用户发布 web 服务。\n预期结果：文件访问用户、服务启动的用户是普通账户，不是root或者administrator账户。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "RBAC（Role_Based Access Control）": {
    "threats": [
      {
        "name": "权限最小化",
        "details": "",
        "security_requirement": {
          "name": "权限最小化",
          "details": "1. 应用系统对用户/管理员、数据库连接等应采取最小权限原则\n2. 应用系统启动的相关进程、系统各组件不得使用特权账户"
        },
        "security_design": {
          "name": "权限最小化",
          "details": "权限梳理与分配：\n细致梳理应用系统各功能所需权限，无论是用户操作还是管理员管理，以及数据库连接场景，均按实际需求精准分配，杜绝多余权限赋予，严格践行最小权限原则。\n账户权限管控：\n针对应用系统启动的进程及各组件，禁用特权账户，改为设立专用的普通权限账户，仅赋予其完成对应任务必需的权限，防止因特权账户带来权限滥用、安全漏洞等风险。\n定期复核更新：\n定期重新审视权限分配情况，依据业务变化、功能增减等及时调整，持续确保各主体、各环节都维持在最小且合理的权限状态，保障系统安全稳定运行。\n权限使用审计：\n建立权限使用审计机制，详细记录权限调用情况，便于监测分析是否存在超出最小权限范围的异常操作，发现问题及时纠正，强化最小权限落实。"
        },
        "test_case": {
          "name": "权限最小化",
          "details": "测试方法：咨询发布人员，是否以非 root 用户发布 web 服务。\n预期结果：文件访问用户、服务启动的用户是普通账户，不是root或者administrator账户。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "Referer检查": {
    "threats": [
      {
        "name": "Referer伪造",
        "details": "",
        "security_requirement": {
          "name": "Referer伪造",
          "details": "确保服务器能够正确验证和处理HTTP请求头中的Referer字段，防止Referer伪造攻击。\n加强对敏感操作和资源的访问控制，减少因Referer伪造而导致的安全问题。"
        },
        "security_design": {
          "name": "Referer伪造",
          "details": "Referer 字段验证机制：\n在服务器端设置严格的 Referer 字段验证规则，明确合法的来源域名、路径等信息，只接受符合预定义规则的 Referer 值，拒绝来源不明或不符合业务逻辑的 Referer 字段内容，防止攻击者随意伪造该字段来绕过访问限制。\n多因素验证结合：\n不要单纯依赖 Referer 字段进行访问控制，而是将其与其他验证手段（如用户身份认证、会话验证、IP 地址验证等）相结合，通过多重验证来综合判断请求的合法性，降低 Referer 伪造带来的风险。\n敏感资源访问控制细化：\n针对敏感操作和资源，进一步细化访问控制策略，明确规定只有特定角色、从特定页面或经过特定流程发起的请求才能访问，限制 Referer 字段可接受的范围，使其更加精准，避免因宽泛的 Referer 验证导致伪造攻击得逞。\n异常行为监测：\n建立对 Referer 字段相关请求行为的监测系统，分析请求频率、来源变化、Referer 值的分布等情况，及时发现异常的 Referer 使用模式，例如短期内大量来自异常域名的 Referer 出现，或 Referer 字段与请求的实际业务逻辑严重不符等情况。\n应急响应与修复：\n一旦监测到疑似 Referer 伪造的攻击行为，立即触发应急响应流程，阻断相关可疑请求，记录详细的攻击信息，同时通知安全运维人员进行深入排查和修复，根据攻击情况对 Referer 验证规则及相关访问控制策略进行调整优化，防止类似攻击再次发生。"
        },
        "test_case": {
          "name": "Referer伪造",
          "details": "测试方法：使用 Fiddler 抓包修改数据包中的 Referer 参数，修改成非设定的URL后再次发送。\n预期结果：系统应拒绝非法Referer字段的访问请求或请求失败/无效。"
        },
        "industry_standard": null
      }
    ]
  },
  "SAX 解析（Simple API for XML）": {
    "threats": [
      {
        "name": "解析器漏洞",
        "details": "",
        "security_requirement": {
          "name": "解析器漏洞",
          "details": "保护解析器的安全性，防止解析器被恶意输入滥用。\n加强对解析器的配置和使用，及时修补解析器的安全漏洞。"
        },
        "security_design": {
          "name": "解析器漏洞",
          "details": "代码审查与优化：\n在开发过程中，对涉及解析器相关的代码开展严谨的审查工作。检查代码逻辑是否严谨，是否存在可被恶意输入利用的薄弱环节，比如对输入数据处理时边界条件判断不足、错误的类型转换等情况，及时发现并修正代码缺陷，从代码层面增强解析器安全性。\n安全编码规范遵循：\n开发团队要严格遵循安全编码规范，在编写解析器相关代码时，采用安全的函数、方法来处理输入和执行解析操作，避免使用容易引发安全问题的过时或不安全的编程方式，例如避免使用存在已知漏洞的库函数，以此保障解析器代码本身的质量与安全性。\n输入处理模块开发：\n精心设计解析器的输入处理模块，将输入验证、过滤、格式化等功能整合其中。运用正则表达式、类型校验等技术手段，确保输入到解析器的内容符合预期要求，能够有效阻挡恶意构造的输入数据，同时对合法输入进行规范处理后再传递给解析器主体部分进行解析。\n版本管理与更新整合：\n在开发的版本管理体系中，将解析器安全漏洞修复与版本更新紧密结合起来。当发现解析器存在安全问题需要修补时，及时在版本控制系统中标记、记录相关变更，确保更新后的版本能将修补后的解析器正确部署到相应环境中，让开发、测试、生产等各环节都能使用到修复好漏洞的解析器版本。\n"
        },
        "test_case": {
          "name": "解析器漏洞",
          "details": "测试方法：在应用系统可以输入的位置尝试输入如下内容，查看是否正常响应。\n<!DOCTYPE foo [<!ELEMENT foo ANY>\n    <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<foo>&xxe;</foo>\n预期结果：如果目标系统存在解析器漏洞，可能导致解析器崩溃、拒绝服务或执行恶意代码等安全问题。系统应该及时更新解析器版本，或者实施输入验证和过滤等措施来防止解析器漏洞的利用。"
        },
        "industry_standard": null
      }
    ]
  },
  "X_Frame_Options（针对新上线）": {
    "threats": [
      {
        "name": "安全头部绕过",
        "details": "",
        "security_requirement": {
          "name": "安全头部绕过",
          "details": "正确设置和验证安全头部，防止绕过攻击"
        },
        "security_design": {
          "name": "安全头部绕过",
          "details": "安全头部规范设置：\n严格按照安全最佳实践，为网站或应用配置关键安全头部，如 Content-Security-Policy（CSP）用于控制资源加载、X-Frame-Options 限制页面嵌入、X-XSS-Protection 防范跨站脚本攻击等，确保各安全头部的参数准确合理。\n多头部协同验证：\n在服务器端建立综合的验证机制，对多个安全头部同时进行检查和校验，避免攻击者通过利用单一头部验证的薄弱点来绕过整体防护，确保各头部设置相互配合、形成严密的安全防线。\n定期检查更新：\n定期对已设置的安全头部进行全面检查，依据业务变化、新出现的安全威胁以及浏览器等技术环境的更新情况，及时调整和优化安全头部的参数及配置，保持防护的有效性。"
        },
        "test_case": {
          "name": "安全头部绕过",
          "details": "测试方法：修改 HTTP 头信息中的参数，如Content Security Policy、X-Frame-Options、X-XSS-Protection等，再次发送修改的数据包。\n预期结果：发送失败或报错。"
        },
        "industry_standard": null
      }
    ]
  },
  "XPath 解析": {
    "threats": [
      {
        "name": "XPath注入",
        "details": "",
        "security_requirement": {
          "name": "XPath注入",
          "details": "确保应用程序对输入的 XPath 查询进行严格的验证和过滤，防止恶意注入导致的安全问题。\n加强对 XPath 解析器的安全配置和使用，减少因解析器漏洞导致的安全风险。"
        },
        "security_design": {
          "name": "XPath注入",
          "details": "XPath 查询验证：\n在接收 XPath 查询输入的位置，依据业务逻辑确定合法的查询格式、语法范围，严格验证输入的 XPath 查询是否符合规定，拒绝不符合要求的输入。\n特殊字符过滤：\n针对 XPath 语句中关键的特殊字符（如单引号 '、双引号 \"、括号 ()、逻辑运算符 AND、OR 等），运用正则表达式或专门的过滤函数进行过滤或转义处理，避免这些字符被恶意利用构造注入攻击语句。\n输入类型限制：\n明确限定输入的 XPath 查询参数的数据类型，比如只允许数字型、字符串型等特定类型的输入，防止攻击者通过改变数据类型来篡改查询语义，引发安全问题。\nXPath 解析器配置优化：\n选用安全、稳定且更新及时的 XPath 解析器，仔细审查并禁用解析器中那些容易被利用的、存在安全隐患的配置选项，从根源上减少因解析器自身漏洞带来的风险。\n安全解析模式启用：\n若解析器支持安全解析模式，则开启该模式，让解析器在解析过程中自动检测并拦截可疑的注入内容，强化对 XPath 注入攻击的防御能力。"
        },
        "test_case": {
          "name": "XPath注入",
          "details": "测试方法：在输入功能处，写入特殊字符（如：@$%&*<>';/）或构造 SQL 语句。\n预期结果：拒绝执行该功能的正确处理，或报错但无过多错误信息。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "X_XSS_Protection（针对新上线）": {
    "threats": [
      {
        "name": "XSS保护绕过",
        "details": "",
        "security_requirement": {
          "name": "XSS保护绕过",
          "details": "确保网站或应用程序实施了有效的 XSS 防护措施，包括输入验证、输出编码和内容安全策略等。\n加强对用户输入和输出的验证和过滤，防止 XSS 攻击的发生和影响。"
        },
        "security_design": {
          "name": "XSS保护绕过",
          "details": "输入验证强化：\n对用户输入的各类数据（如表单字段、查询参数等）进行深度验证，不仅检查数据格式、长度，还分析其语义内容，依据业务逻辑严格甄别合法与非法输入，拒绝可能用于构造 XSS 攻击的恶意输入。\n输出编码细化：\n根据输出内容的类型（如 HTML、JavaScript、CSS 等）采用针对性的编码方式，例如在 HTML 输出时对特殊字符（<、>、&、'、\" 等）进行 HTML 实体编码，确保输出内容无法被浏览器解析为恶意脚本，且覆盖所有可能的输出场景，避免遗漏导致绕过防护。\n内容安全策略优化：\n完善内容安全策略（CSP），采用严格的白名单机制，明确允许加载的脚本、样式等资源来源，禁止一切非授权来源的内容加载，同时定期审查和更新 CSP，使其能适应业务变化与新出现的绕过手段。\n上下文敏感过滤：\n考虑输入输出的上下文环境，比如在 JavaScript 字符串中、HTML 属性内等不同场景下，对输入内容进行差异化的过滤与转义处理，精准防止攻击者利用特定上下文进行 XSS 绕过攻击。\n安全框架更新与选用：\n及时更新应用程序所使用的安全框架，选用具有更强抗 XSS 绕过能力的框架，利用其内置的先进防护机制来加固整体安全防线，降低被绕过的风险。"
        },
        "test_case": {
          "name": "XSS保护绕过",
          "details": "测试方法：在输出的功能处输入恶意的JavaScript代码或HTML元素如alert()、<script></script>、\"></script>。\n预期结果：返回报错，或转义后返回前端，或原封不动文本形式返回前端。"
        },
        "industry_standard": null
      }
    ]
  },
  "安全审计与监控": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "安全审计",
          "details": null
        }
      }
    ]
  },
  "安全通信协议（针对新上线）": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "报名信息": {
    "threats": [
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "参与者身份验证": {
    "threats": [
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      }
    ]
  },
  "查询、搜索": {
    "threats": [
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "SQL注入",
          "details": "对用户的输入信息过滤或者转义"
        },
        "security_design": {
          "name": "SQL注入",
          "details": "输入验证：\n严格校验用户输入数据类型、长度与格式，拒绝非法输入。\n字符过滤与转义：\n过滤或转义单引号、双引号等 SQL 特殊字符。\n预编译语句：\n采用预编译技术处理 SQL 查询，分离代码与数据。\n数据库权限：\n依最小权限原则设置数据库用户权限。"
        },
        "test_case": {
          "name": "SQL注入",
          "details": "测试方法：在输入处写入特殊字符（如：@$%&*<>';/）或构造 SQL 语句。\n预期结果：拒绝执行该功能的正确处理，或报错但无过多错误信息。"
        },
        "industry_standard": null
      },
      {
        "name": "跨站脚本攻击｜XSS",
        "details": "",
        "security_requirement": {
          "name": "跨站脚本攻击｜XSS",
          "details": "1. 对用户的输入信息进行过滤或者转义\n2. 确保前端显示的文本内容不可被浏览器解析"
        },
        "security_design": {
          "name": "跨站脚本攻击｜XSS",
          "details": "输入信息过滤机制：\n在开发中，针对用户输入的各类信息（比如表单填写内容、评论框输入等），运用正则表达式等技术手段，仔细甄别并过滤掉常见的用于跨站脚本攻击的危险字符，像 “<”“>”“script” 等标签及相关脚本关键字。通过严格的过滤逻辑，防止恶意输入进入系统后端，从源头阻断攻击可能。\n输入转义处理：\n对于无法过滤掉的特殊字符，编写代码将其进行转义处理，使其失去原本在浏览器中可被解析成脚本的能力。例如，把 “<” 转义为 “<”，“>” 转义为 “>”，确保即便有恶意输入混入，在前端展示时也不会被浏览器当作脚本代码来执行，保障页面安全。\n前端渲染控制：\n在前端代码编写时，采用安全的渲染方式，对于从后端获取的文本内容，明确设置为纯文本渲染模式，禁用浏览器默认的 HTML 解析功能，避免文本内容里隐藏的恶意脚本被浏览器误解析，让显示的内容只以文本形式呈现，杜绝 XSS 攻击隐患。\n内容输出验证：\n在将数据输出到前端页面进行展示前，再次对内容进行验证，检查是否存在被转义后又还原或者新混入的可导致浏览器解析的脚本元素，通过多重验证，确保最终展示给用户的文本内容始终处于不可被浏览器解析的安全状态，全方位保护系统免受 XSS 攻击。\n"
        },
        "test_case": {
          "name": "跨站脚本攻击｜XSS",
          "details": "测试方法：在输出的功能处输入恶意的JavaScript代码或HTML元素如alert()、<script></script>、\"></script>。\n预期结果：返回报错，或转义后返回前端，或原封不动文本形式返回前端。"
        },
        "industry_standard": null
      }
    ]
  },
  "查询订单": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "处理用户订单信息": {
    "threats": [
      {
        "name": "订单信息篡改",
        "details": "",
        "security_requirement": {
          "name": "订单信息篡改",
          "details": "确保订单信息的完整性和真实性，防止被篡改或伪造。\n保护用户的交易安全和个人信息安全，避免用户受到经济损失或隐私泄露。"
        },
        "security_design": {
          "name": "订单信息篡改",
          "details": "数据传输加密：\n采用强加密算法（如 SSL/TLS）对订单数据在网络传输时加密，确保数据安全传输，防止信息在网络链路中被窃取与篡改。\n数字签名应用：\n订单生成时，利用非对称加密技术为订单关键信息生成数字签名。接收端验证签名，若失败则拒绝订单，以此保障订单数据完整性与真实性，防范伪造信息。\n存储加密机制：\n数据库中对订单敏感信息（用户资料、支付详情等）采用 AES 等加密算法加密存储，仅在合法业务流程中依权限解密使用，降低数据泄露风险。\n输入验证强化：\n在订单创建与修改的前端及后端接口，严格校验输入数据格式、范围与逻辑一致性，杜绝不合规数据进入系统，防止篡改尝试。\n权限精细管理：\n遵循最小权限原则设置订单处理相关角色与权限，限制不同人员对订单信息的操作范围，避免因权限滥用引发信息篡改风险。"
        },
        "test_case": {
          "name": "订单信息篡改",
          "details": "测试方法：使用 Fiddler 抓包修改关键参数（前端至灰或不允许修改的），查看是否修改成功。\n预期结果：修改失败。"
        },
        "industry_standard": {
          "name": "数据完整性",
          "details": null
        }
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "打卡地点验证": {
    "threats": [
      {
        "name": "位置信息篡改",
        "details": "",
        "security_requirement": {
          "name": "位置信息篡改",
          "details": "确保位置定位的准确性，不能被手动修改。"
        },
        "security_design": {
          "name": "位置信息篡改",
          "details": "位置信息获取与校验：\n直接从可靠的底层定位硬件（如 GPS 芯片、基站定位模块等）获取原始位置数据，避免中间环节被篡改数据注入。\n对获取到的位置数据进行多维度校验，包括与周边基站信号强度分布特征对比、与地图地理信息特征（如地形、道路走向等）匹配校验，确保位置信息符合实际逻辑，若出现明显偏差则拒绝采用并进行异常记录。\n防止篡改机制：\n将位置信息存储于只读存储区域或采用加密存储方式，限制应用程序或其他进程对位置数据的写入权限，防止被恶意软件手动修改。\n对位置信息传输通道进行加密，防止数据在传输过程中被拦截篡改，确保从定位源到应用服务端接收的位置数据的完整性和准确性。\n异常监测与响应：\n建立位置信息异常监测系统，实时监测位置数据的变化规律，若发现位置信息在短时间内出现不符合常理的大幅跳跃或频繁变动，判定为可能的篡改行为，及时触发警报并采取相应安全措施，如暂停相关服务、要求用户重新进行身份验证与位置校准等。"
        },
        "test_case": {
          "name": "位置信息篡改",
          "details": "测试方法：\n用chrome浏览器打开需要定位的页面，F12打开调试器，点击右上角的三个点，选择More tools / Sensors修改位置信息，尝试访问应用程序中受地理位置限制的资源或功能，例如根据地理位置显示不同的内容或者提供不同的服务。\n预期结果：应用程序对模拟的不同地理位置信息无任何响应。"
        },
        "industry_standard": null
      }
    ]
  },
  "打卡异常提醒": {
    "threats": [
      {
        "name": "信息滥用",
        "details": "",
        "security_requirement": {
          "name": "信息滥用",
          "details": "信息访问权限最小化，防止信息泄露。"
        },
        "security_design": {
          "name": "信息滥用",
          "details": "信息权限管理：\n采用 RBAC 模型，依角色分配信息访问权限，遵循最小化原则，如客服仅能看客户基本信息，限制访问敏感数据，降低信息滥用风险。\n信息使用审计：\n构建审计机制，记录用户信息访问详情，定期审查日志，发现异常访问模式，如频繁访问无关信息，以便及时查处。\n数据脱敏与加密：\n敏感信息存储与传输时脱敏，模糊或替换身份证号等敏感字段，且加密重要信息，仅授权用户用解密密钥可访问，增加信息滥用难度。"
        },
        "test_case": {
          "name": "信息滥用",
          "details": "测试方法：查看应用程序的输出和日志，确认敏感数据（如身份证号码、银行卡号等）在显示时进行了脱敏处理（例如，只显示部分数据或替换为星号）。\n预期结果：敏感数据在显示和存储时脱敏处理得当。"
        },
        "industry_standard": null
      }
    ]
  },
  "导出": {
    "threats": [
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "文件读取漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件读取漏洞",
          "details": "访问控制：实施严格的文件访问控制策略，确保只有授权用户可以访问特定的文件。\n文件路径验证：对用户提供的文件路径进行验证和过滤，防止恶意构造的路径导致文件读取漏洞。\n最小权限原则：为应用程序分配最小权限，限制其对文件系统的访问，减少潜在的漏洞风险。"
        },
        "security_design": {
          "name": "文件读取漏洞",
          "details": "访问控制：\n依据用户角色、业务需求等因素，制定精细的文件访问控制策略，明确不同用户、不同业务模块所能访问的具体文件范围，严格限制非授权用户对任何敏感或关键文件的访问，例如，财务文件仅允许财务部门相关授权人员读取操作。\n文件路径验证：\n在接收用户输入的文件路径时，运用严格的正则表达式等验证手段，对路径进行合法性检查，过滤掉包含特殊字符、非法目录跳转符号（如 “../” 等可能导致目录穿越的符号）的恶意构造路径，保证文件路径指向符合安全预期的范围，杜绝因路径被恶意操控而引发的文件读取漏洞。\n最小权限原则：\n遵循最小权限分配理念，精准评估应用程序实际运行所需的文件系统访问权限，只为其赋予必要的最低限度权限，比如只允许读取特定目录下的配置文件，禁止对其他无关目录及文件进行写、删除等操作，以此最大程度降低因权限过大而产生文件读取方面潜在漏洞的风险。"
        },
        "test_case": {
          "name": "文件读取漏洞",
          "details": "测试方法：对带有路径的文件访问 URL，使用Fiddler抓包截取流量，然后拼接文件路径。例如\"../etc/passwd\"、\"../../../etc/passwd“\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "导入": {
    "threats": [
      {
        "name": "文件解析漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n恶意代码检测：使用恶意代码检测工具或技术，对上传的文件进行扫描，及时发现和处理潜在的恶意代码。\n安全配置：确保系统和应用程序的文件解析配置安全，避免存在不安全的解析器或配置。"
        },
        "security_design": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：\n建立全面且严格的文件类型白名单机制，针对上传的文件，详细检查其文件头信息、扩展名等多方面特征，与白名单中的合法文件类型进行精确匹配，坚决拒绝任何不在白名单内的文件上传，有效防止恶意文件（如含有脚本代码的伪装文件）混入系统。\n恶意代码检测：\n集成先进的恶意代码检测工具，在文件上传环节或定期对系统内已存储的文件进行深度扫描，运用特征码匹配、行为分析等多种检测技术，及时精准地识别潜在的恶意代码片段，一旦发现，立即采取隔离、删除等处理措施，并记录相关信息以便追溯分析。\n安全配置：\n全面审查系统和应用程序的文件解析配置，禁用或更新存在安全隐患的解析器，如老旧版本的 XML 解析器等容易遭受攻击的组件；同时，对文件解析的相关参数进行安全设置，限制解析的深度、范围等，避免因不安全的配置导致文件解析漏洞被利用，确保整个文件解析过程在安全可控的环境下进行。"
        },
        "test_case": {
          "name": "文件解析漏洞",
          "details": "测试方法：合法上传文件过程中，使用 Fiddler 拦截上传数据包，修改为非法文件名（1.jsp、2.ASp、shell.PHP等执行脚本名称。），在取消拦截查看是否成功。\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      },
      {
        "name": "文件上传漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n文件大小限制：限制上传文件的大小，防止攻击者上传过大的文件导致服务器资源耗尽。\n安全权限设置：确保上传文件的存储目录具有适当的权限设置，防止恶意文件被执行或访问。"
        },
        "security_design": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：\n构建严谨的文件类型验证体系，采用多种验证方式相结合，例如不仅检查文件扩展名，还深入分析文件头特征信息，与预定义的安全文件类型白名单进行细致比对，严禁任何不在白名单中的文件类型上传，有效阻拦恶意脚本文件、可执行文件等非法文件进入系统。\n文件大小限制：\n在文件上传功能模块中，设定合理的文件大小上限值，此值应综合考虑服务器性能、业务需求以及安全风险等多方面因素。当用户上传文件时，系统自动检查文件大小，若超出限制则立即中断上传过程，并向用户反馈相应提示信息，防止攻击者通过上传超大文件耗尽服务器资源，如磁盘空间、内存等，保障服务器稳定运行。\n安全权限设置：\n针对上传文件的存储目录，精心规划并设置严格的权限策略。赋予该目录仅允许特定合法进程进行写入操作的权限，而禁止其他非授权进程或用户对上传文件进行读取、执行等操作，防止恶意上传的文件被意外执行或非法访问，降低因文件上传漏洞引发的安全风险，确保服务器文件系统的安全性与完整性。"
        },
        "test_case": {
          "name": "文件上传漏洞",
          "details": "测试方法：检查应用程序是否只接受特定扩展名（如.jpg、.pdf）和类型（如图像、文档）的文件上传。\n预期结果：应用程序应拒绝上传可疑或不符合规定的文件类型或扩展名。"
        },
        "industry_standard": null
      }
    ]
  },
  "登录认证接口": {
    "threats": [
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      }
    ]
  },
  "订单查询与管理": {
    "threats": [
      {
        "name": "订单信息篡改",
        "details": "",
        "security_requirement": {
          "name": "订单信息篡改",
          "details": "确保订单信息的完整性和真实性，防止被篡改或伪造。\n保护用户的交易安全和个人信息安全，避免用户受到经济损失或隐私泄露。"
        },
        "security_design": {
          "name": "订单信息篡改",
          "details": "数据传输加密：\n采用强加密算法（如 SSL/TLS）对订单数据在网络传输时加密，确保数据安全传输，防止信息在网络链路中被窃取与篡改。\n数字签名应用：\n订单生成时，利用非对称加密技术为订单关键信息生成数字签名。接收端验证签名，若失败则拒绝订单，以此保障订单数据完整性与真实性，防范伪造信息。\n存储加密机制：\n数据库中对订单敏感信息（用户资料、支付详情等）采用 AES 等加密算法加密存储，仅在合法业务流程中依权限解密使用，降低数据泄露风险。\n输入验证强化：\n在订单创建与修改的前端及后端接口，严格校验输入数据格式、范围与逻辑一致性，杜绝不合规数据进入系统，防止篡改尝试。\n权限精细管理：\n遵循最小权限原则设置订单处理相关角色与权限，限制不同人员对订单信息的操作范围，避免因权限滥用引发信息篡改风险。"
        },
        "test_case": {
          "name": "订单信息篡改",
          "details": "测试方法：使用 Fiddler 抓包修改关键参数（前端至灰或不允许修改的），查看是否修改成功。\n预期结果：修改失败。"
        },
        "industry_standard": {
          "name": "数据完整性",
          "details": null
        }
      },
      {
        "name": "订单信息泄露",
        "details": "",
        "security_requirement": {
          "name": "订单信息泄露",
          "details": "确保系统能够防止订单信息泄露，保护用户的隐私和订单数据安全。"
        },
        "security_design": {
          "name": "订单信息泄露",
          "details": "数据加密全流程：\n存储时，用 AES 等算法加密订单数据库敏感字段。传输时，以 SSL/TLS 协议加密数据，涵盖用户提交订单至与外部系统交互全过程，保障数据机密性。\n数据脱敏呈现：\n开发数据脱敏模块，在订单信息展示场景（如客服界面、商家统计页面），依预设规则对敏感信息模糊化或替换处理，如隐藏用户身份证号部分数字、替换真实姓名等，确保展示信息不涉隐私泄露。"
        },
        "test_case": {
          "name": "订单信息泄露",
          "details": "测试方法：\n1、使用 Fiddler 抓包，检查订单敏感信息在传输和存储过程中是否加密；\n2、前端显示订单信息时是否对敏感数据（如付款信息）进行了脱敏处理。\n预期结果： 1、敏感信息加密传输；2、前端脱敏展示。"
        },
        "industry_standard": null
      }
    ]
  },
  "订单购买": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "订单管理": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "定位信息获取": {
    "threats": [
      {
        "name": "位置信息篡改",
        "details": "",
        "security_requirement": {
          "name": "位置信息篡改",
          "details": "确保位置定位的准确性，不能被手动修改。"
        },
        "security_design": {
          "name": "位置信息篡改",
          "details": "位置信息获取与校验：\n直接从可靠的底层定位硬件（如 GPS 芯片、基站定位模块等）获取原始位置数据，避免中间环节被篡改数据注入。\n对获取到的位置数据进行多维度校验，包括与周边基站信号强度分布特征对比、与地图地理信息特征（如地形、道路走向等）匹配校验，确保位置信息符合实际逻辑，若出现明显偏差则拒绝采用并进行异常记录。\n防止篡改机制：\n将位置信息存储于只读存储区域或采用加密存储方式，限制应用程序或其他进程对位置数据的写入权限，防止被恶意软件手动修改。\n对位置信息传输通道进行加密，防止数据在传输过程中被拦截篡改，确保从定位源到应用服务端接收的位置数据的完整性和准确性。\n异常监测与响应：\n建立位置信息异常监测系统，实时监测位置数据的变化规律，若发现位置信息在短时间内出现不符合常理的大幅跳跃或频繁变动，判定为可能的篡改行为，及时触发警报并采取相应安全措施，如暂停相关服务、要求用户重新进行身份验证与位置校准等。"
        },
        "test_case": {
          "name": "位置信息篡改",
          "details": "测试方法：\n用chrome浏览器打开需要定位的页面，F12打开调试器，点击右上角的三个点，选择More tools / Sensors修改位置信息，尝试访问应用程序中受地理位置限制的资源或功能，例如根据地理位置显示不同的内容或者提供不同的服务。\n预期结果：应用程序对模拟的不同地理位置信息无任何响应。"
        },
        "industry_standard": {
          "name": "数据完整性",
          "details": null
        }
      }
    ]
  },
  "动态权限分配": {
    "threats": [
      {
        "name": "权限滥用",
        "details": "未按照最小授权原则进行授权，可能导致用户获得超出其实际需要的权限，从而滥用权限，进行非法操作或访问敏感数据，增加数据泄露的风险。",
        "security_requirement": {
          "name": "权限滥用",
          "details": "确保系统能够有效防止权限滥用行为，保护系统资源和用户数据的安全。"
        },
        "security_design": {
          "name": "权限滥用",
          "details": "权限细分管控：\n将系统权限依据功能模块、操作类型等进行精细划分，为不同角色、用户设定对应且精准的权限范围，避免权限宽泛易被滥用，确保各操作都有严格权限限制。\n操作审计机制：\n搭建完善的权限使用审计系统，实时记录权限操作详情，像操作时间、执行者、具体行为等，定期分析审计数据，及时发现频繁越权、异常操作等滥用行为。\n实时监控预警：\n设置监控规则，对权限使用频率、资源访问量等关键指标实时监测，一旦出现超出正常阈值的情况，如短时间内大量删除数据等，立即触发警报并阻断操作，防范权限滥用。\n权限回收调整：\n定期评估用户、角色的权限合理性，根据业务变动及权限使用情况，及时回收不必要权限，对存在滥用风险的权限进行调整，保障系统与数据安全。"
        },
        "test_case": {
          "name": "权限滥用",
          "details": "测试方法：用管理员账户登录应用系统后，进行一些敏感行为的操作，如删除数据库、重启系统服务、服务更新等敏感操作。\n预期结果：管理员账户仅能够访问自己授权内的功能。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "对返回的数据进行加密或签名处理": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "多因素认证": {
    "threats": [
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      }
    ]
  },
  "反垃圾信息": {
    "threats": [
      {
        "name": "不当推广",
        "details": "",
        "security_requirement": {
          "name": "不当推广",
          "details": "防止未经授权的广告或宣传信息发送"
        },
        "security_design": {
          "name": "不当推广",
          "details": "推广内容审核机制：\n建立严格的内容审核团队或采用智能审核系统，对准备发出的所有广告、宣传信息进行前置审核，依据相关法律法规、平台规则以及用户授权情况，仔细甄别内容的合法性、合规性与授权状态，禁止未经授权的信息发布。\n发送权限管理：\n明确划分不同角色、部门或用户在推广信息发送方面的权限，遵循最小权限原则，仅赋予经过正规授权流程的主体相应权限，并且对权限的使用情况进行严格记录与审计，防止权限滥用导致的不当推广。\n用户授权确认：\n在收集用户信息用于推广目的时，通过清晰明确、通俗易懂的方式告知用户授权范围、用途等关键信息，获取用户的明示同意，同时做好授权记录的留存与管理，确保每一次推广信息发送都有对应的合法授权依据。\n渠道管控：\n对各类推广信息发送渠道（如短信平台、邮件系统、社交媒体账号等）进行统一管理，限定只有符合要求且经过授权的渠道才能用于信息推送，定期排查渠道使用情况，避免非法渠道被用于不当推广。"
        },
        "test_case": {
          "name": "不当推广",
          "details": "测试方法：尝试订阅和退订推广信息，验证系统是否提供明确和易用的订阅和退订机制，并确保退订后不再收到推广信息。\n预期结果：取消/退订后不会再次受到信息。"
        },
        "industry_standard": null
      }
    ]
  },
  "访问控制列表（ACL）": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "服务器安全配置（针对新上线）": {
    "threats": [
      {
        "name": "端口安全",
        "details": "",
        "security_requirement": {
          "name": "端口安全",
          "details": "禁用非必要的服务端口暴露"
        },
        "security_design": {
          "name": "端口安全",
          "details": "端口扫描与清查：\n定期进行全面的端口扫描，精准识别系统中所有开启的端口，详细记录端口对应的服务信息，确保无遗漏，并与业务需求及安全策略严格比对，清查非必要开启的端口。\n端口访问控制列表（ACL）设置：\n为允许访问的必要端口配置精细的访问控制列表，明确指定可访问的源 IP 地址范围、访问时间等限制条件，严禁其他未授权来源的连接请求，将端口访问权限严格限定在最小化范围内。\n端口监控与预警：\n部署实时端口监控系统，对端口的连接状态、流量大小、连接频率等关键指标进行持续监测，一旦发现异常连接尝试（如来自陌生 IP 地址的大量连接请求、特定端口流量突增等），立即触发预警机制，及时通知安全运维人员进行处理。\n端口安全加固：\n对必要开放的服务端口，采用最新的安全补丁和升级策略，及时修复已知存在的安全漏洞，同时优化端口相关服务的配置，禁用不必要的功能模块，降低因端口服务自身缺陷导致的安全风险。"
        },
        "test_case": {
          "name": "端口安全",
          "details": "测试方法：使用Nmap（nmap -p- -sV -T4 <目标IP或域名>）扫描目标服务器的IP地址，列出当前开放的服务端口。\n预期结果：open 的端口只包含服务器上业务所需的端口。"
        },
        "industry_standard": null
      },
      {
        "name": "拒绝服务攻击",
        "details": "",
        "security_requirement": {
          "name": "拒绝服务攻击",
          "details": "确保系统能够有效防止拒绝服务攻击，保护系统的可用性和稳定性。"
        },
        "security_design": {
          "name": "拒绝服务攻击",
          "details": "输入验证强化：\n开发时对所有外部输入进行严格校验，包括数据格式、长度、类型等。例如对用户提交的表单数据、API 传入参数，通过正则表达式与数据类型检查确保其合法性，杜绝恶意构造的输入引发系统异常或资源耗尽，从而抵御攻击。\n并发控制策略：\n精心设计并发处理逻辑，利用线程池、信号量等技术限制同时处理的请求数量。依据系统硬件资源与正常业务负载，设定合理阈值，防止大量并发恶意请求使系统资源耗尽而瘫痪，保障服务稳定运行。\n资源监控与限制：\n在代码中嵌入资源监控模块，实时跟踪 CPU、内存、磁盘 I/O 等关键资源的使用情况。一旦资源使用接近危险阈值，自动限制非关键业务的资源分配，优先保障核心业务运行，避免因资源被恶意占用导致系统不可用。\n缓存机制优化：\n优化缓存策略，对频繁访问的数据进行合理缓存，设置缓存有效期与容量限制。既减少重复计算与数据库查询，提升系统响应速度，又防止缓存被恶意数据填满，影响正常业务数据缓存，保障系统高效稳定运行。\n异常处理完善：\n构建全面的异常处理体系，对于可能出现的各类异常情况，如网络中断、数据库连接失败、资源不足等，进行优雅处理。避免因未处理的异常导致系统崩溃或陷入无限循环，增强系统在面对异常与攻击时的韧性。\n代码模块化与隔离：\n将系统功能进行合理模块化，不同模块间设置清晰的边界与访问权限。当某个模块遭受攻击时，通过隔离机制限制影响范围，防止恶意攻击蔓延至整个系统，确保其他模块仍能正常提供服务，维持系统整体可用性。"
        },
        "test_case": {
          "name": "拒绝服务攻击",
          "details": "测试方法：功能测试压力测试"
        },
        "industry_standard": {
          "name": "入侵防范",
          "details": null
        }
      },
      {
        "name": "未安全配置",
        "details": "",
        "security_requirement": {
          "name": "未安全配置",
          "details": "安全配置审查：对系统、应用程序和网络设备的安全配置进行定期审查和评估，发现并修复安全配置问题。\n安全最佳实践：遵循安全最佳实践，对系统和应用程序进行安全配置，降低安全风险。"
        },
        "security_design": {
          "name": "未安全配置",
          "details": "安全配置审查：\n对系统、应用程序和网络设备的安全配置进行定期审查和评估，发现并修复安全配置问题。\n安全最佳实践：\n遵循安全最佳实践，对系统和应用程序进行安全配置，降低安全风险。"
        },
        "test_case": {
          "name": "未安全配置",
          "details": "测试方法：\n1、检查系统管理员账户、数据库账户、Web应用程序账户等常见账户的密码是否已经修改为强密码。可以使用弱密码去尝试登录，如123456、123qwe、admin888、test等。\n2、检查服务器上是否运行了不必要的服务或开放了不必要的端口，例如SSH服务（22端口）、Telnet服务（23端口）等，并向系统管理员确认是否需要打开这些端口。\n3、查看配置文件，检查其中是否包含了敏感信息，例如数据库连接密码、API密钥、加密密钥等。\n预期结果：无不安全的配置。"
        },
        "industry_standard": null
      }
    ]
  },
  "根据用户身份信息查询相关用户数据": {
    "threats": [
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "根据用户提供的资源或身份标识执行数据操作": {
    "threats": [
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "工作时长记录": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "关键业务逻辑被拆分为多个子流程进行处理": {
    "threats": [
      {
        "name": "业务逻辑漏洞",
        "details": "",
        "security_requirement": {
          "name": "业务逻辑漏洞",
          "details": "确保业务逻辑准确，步骤之间具有顺序校验。"
        },
        "security_design": {
          "name": "业务逻辑漏洞",
          "details": "流程梳理与规范：\n全面梳理业务流程，将各个业务步骤清晰罗列并明确先后顺序，制定详细的业务逻辑流程图。例如电商购物流程中，从挑选商品、加入购物车到下单支付等环节依次规范，防止出现步骤颠倒或缺失的情况，以此保障业务逻辑的准确性。\n顺序校验机制：\n在系统中构建严格的顺序校验功能，每进入一个业务步骤时，都检查前置步骤是否已按规定完成。比如在线考试系统，只有完成答题才能提交试卷，若未答题就提交会被系统拦截并提示，通过这种校验确保各步骤按正确顺序执行，避免业务逻辑漏洞被利用。\n异常监测与反馈：\n实时监测业务流程中的操作行为，对不符合既定业务逻辑顺序的异常情况及时捕捉，比如出现不该出现的回退操作或者跳跃式执行步骤等情况时，系统能快速反馈并提醒相关人员修正，确保业务逻辑始终处于准确有序状态。"
        },
        "test_case": {
          "name": "业务逻辑漏洞",
          "details": "功能测试包含"
        },
        "industry_standard": null
      }
    ]
  },
  "行情推送": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "垃圾信息推送",
        "details": "",
        "security_requirement": {
          "name": "垃圾信息推送",
          "details": "防止恶意用户或攻击者利用通知推送功能发送垃圾信息。\n加强对通知推送的许可控制和监控，确保只有合法的通知能够被发送。"
        },
        "security_design": {
          "name": "垃圾信息推送",
          "details": "许可获取机制完善：\n开发时设计清晰许可弹窗，展示推送目的、内容类别、频率等。用户充分知晓后主动授权开启，避免默认或诱导授权，从源头降低恶意推送风险，保障用户对通知推送的自主控制权，让推送行为建立在用户意愿基础之上。\n权限分级管理：\n依据业务功能、通知重要性等多维度细分权限。重要通知限高级管理员操作，一般业务通知依职责分配权限。严格的权限划分可防止越权与冒用，避免垃圾信息因权限失控而泛滥，确保推送权限与业务需求及用户角色精准匹配。\n内容审核机制：\n构建审核模块，借助关键词过滤、格式规范与语义分析技术。审核推送内容合法性、合规性，筛查违法、低俗、广告等垃圾信息。不符要求则阻止发送并记录，仅放行合法有价值通知，为用户接收信息把好质量关。\n推送监控系统：\n搭建监控系统，实时跟踪推送源、时间、内容与接收对象。运用数据挖掘与机器学习分析数据，及时发现异常，如短时间大量相似推送、内容与业务不符等。发现异常自动阻断并警报，保障推送过程安全有序，维护系统推送环境的健康稳定。\n黑白名单设置：\n设立黑白名单机制，审核授权的优质源与账号入白名单，给予优先推送权。有违规记录或疑似恶意的入黑名单封禁。精准动态管理约束推送主体，有效拦截垃圾信息，增强通知推送的安全性与可信度。\n反馈与调整机制：\n开辟用户反馈渠道，设垃圾信息标记按钮与文字框。开发团队定期整理分析反馈，依此优化许可流程、权限设置、审核规则与监控策略等。根据用户意见迭代系统防范能力，使推送服务贴合用户需求，持续健康运行。"
        },
        "test_case": {
          "name": "垃圾信息推送",
          "details": "测试方法：向目标系统发送大量垃圾信息，比如大量垃圾邮件或短信。\n预期结果：如果系统没有有效的防御措施，可能导致系统负载过大，用户受到骚扰，甚至系统崩溃。有效的防御措施应该能够过滤掉垃圾信息，保障系统正常运行和用户体验。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      }
    ]
  },
  "活动内容发布与推广": {
    "threats": [
      {
        "name": "不当推广",
        "details": "",
        "security_requirement": {
          "name": "不当推广",
          "details": "防止未经授权的广告或宣传信息发送"
        },
        "security_design": {
          "name": "不当推广",
          "details": "推广内容审核机制：\n建立严格的内容审核团队或采用智能审核系统，对准备发出的所有广告、宣传信息进行前置审核，依据相关法律法规、平台规则以及用户授权情况，仔细甄别内容的合法性、合规性与授权状态，禁止未经授权的信息发布。\n发送权限管理：\n明确划分不同角色、部门或用户在推广信息发送方面的权限，遵循最小权限原则，仅赋予经过正规授权流程的主体相应权限，并且对权限的使用情况进行严格记录与审计，防止权限滥用导致的不当推广。\n用户授权确认：\n在收集用户信息用于推广目的时，通过清晰明确、通俗易懂的方式告知用户授权范围、用途等关键信息，获取用户的明示同意，同时做好授权记录的留存与管理，确保每一次推广信息发送都有对应的合法授权依据。\n渠道管控：\n对各类推广信息发送渠道（如短信平台、邮件系统、社交媒体账号等）进行统一管理，限定只有符合要求且经过授权的渠道才能用于信息推送，定期排查渠道使用情况，避免非法渠道被用于不当推广。"
        },
        "test_case": {
          "name": "不当推广",
          "details": "测试方法：尝试订阅和退订推广信息，验证系统是否提供明确和易用的订阅和退订机制，并确保退订后不再收到推广信息。\n预期结果：取消/退订后不会再次受到信息。"
        },
        "industry_standard": null
      }
    ]
  },
  "活动讨论区": {
    "threats": [
      {
        "name": "XSS保护绕过",
        "details": "",
        "security_requirement": {
          "name": "XSS保护绕过",
          "details": "确保网站或应用程序实施了有效的 XSS 防护措施，包括输入验证、输出编码和内容安全策略等。\n加强对用户输入和输出的验证和过滤，防止 XSS 攻击的发生和影响。"
        },
        "security_design": {
          "name": "XSS保护绕过",
          "details": "输入验证强化：\n对用户输入的各类数据（如表单字段、查询参数等）进行深度验证，不仅检查数据格式、长度，还分析其语义内容，依据业务逻辑严格甄别合法与非法输入，拒绝可能用于构造 XSS 攻击的恶意输入。\n输出编码细化：\n根据输出内容的类型（如 HTML、JavaScript、CSS 等）采用针对性的编码方式，例如在 HTML 输出时对特殊字符（<、>、&、'、\" 等）进行 HTML 实体编码，确保输出内容无法被浏览器解析为恶意脚本，且覆盖所有可能的输出场景，避免遗漏导致绕过防护。\n内容安全策略优化：\n完善内容安全策略（CSP），采用严格的白名单机制，明确允许加载的脚本、样式等资源来源，禁止一切非授权来源的内容加载，同时定期审查和更新 CSP，使其能适应业务变化与新出现的绕过手段。\n上下文敏感过滤：\n考虑输入输出的上下文环境，比如在 JavaScript 字符串中、HTML 属性内等不同场景下，对输入内容进行差异化的过滤与转义处理，精准防止攻击者利用特定上下文进行 XSS 绕过攻击。\n安全框架更新与选用：\n及时更新应用程序所使用的安全框架，选用具有更强抗 XSS 绕过能力的框架，利用其内置的先进防护机制来加固整体安全防线，降低被绕过的风险。"
        },
        "test_case": {
          "name": "XSS保护绕过",
          "details": "测试方法：在输出的功能处输入恶意的JavaScript代码或HTML元素如alert()、<script></script>、\"></script>。\n预期结果：返回报错，或转义后返回前端，或原封不动文本形式返回前端。"
        },
        "industry_standard": null
      }
    ]
  },
  "获取请求的URL信息": {
    "threats": [
      {
        "name": "URL重定向",
        "details": "",
        "security_requirement": {
          "name": "URL重定向",
          "details": "确保URL重定向功能不会被恶意用户滥用或利用。\n加强对URL重定向的验证和过滤，确保重定向的目标URL是合法和可信的。"
        },
        "security_design": {
          "name": "URL重定向",
          "details": "重定向目标验证：\n在执行 URL 重定向操作前，对目标 URL 进行严格的格式验证，确保其符合标准 URL 语法结构，剔除格式错误、可能存在恶意构造的 URL。\n白名单机制：\n建立可信 URL 白名单，仅允许重定向到白名单内的目标 URL，以此限制重定向范围，防止跳转到未知或恶意的外部网站。\n安全校验逻辑：\n对重定向请求来源进行合法性判断，结合用户身份、当前会话状态等多因素综合考量，确保发起重定向的请求是符合业务预期且合规的。\n数据完整性检查：\n针对涉及重定向的传入参数等数据进行完整性检查，防止攻击者通过篡改数据来操控重定向目标，使其指向恶意网址。"
        },
        "test_case": {
          "name": "URL重定向",
          "details": "测试方法：在有 URL 重定向的地方替换 URL 链接（如百度地址）后继续访问。\n预期结果：不能重定向到百度网站。"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      }
    ]
  },
  "集权系统（如堡垒机）": {
    "threats": [
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "加密传输": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "将数据输出到日志文件或日志服务中": {
    "threats": [
      {
        "name": "日志伪造",
        "details": "",
        "security_requirement": {
          "name": "日志伪造",
          "details": "确保系统日志的完整性和真实性，防止日志被篡改或伪造。"
        },
        "security_design": {
          "name": "日志伪造",
          "details": "存储加密：\n采用加密算法对系统日志加密后存储，比如使用 AES 算法，确保日志内容以密文形式存在，让不法分子难以篡改原始内容，保障完整性与真实性。\n数字签名：\n运用数字签名技术，为每条日志添加唯一签名，凭借公私钥机制验证日志来源及完整性，一旦日志被篡改，签名验证就会失败，及时发现异常。\n权限严控：\n设置严格的访问权限，仅授权特定人员可查看、操作日志，并且对操作行为全程记录，防止内部人员违规篡改伪造，杜绝外部非法访问。\n实时监测：\n搭建日志监测系统，实时比对日志数据的变动情况，一旦发现有不符合正常模式的修改痕迹或异常新增等情况，立即发出警报并溯源，防范日志伪造行为。"
        },
        "test_case": {
          "name": "日志伪造",
          "details": "测试方法：\n1、在有日志记录的输入处，额外插入日志格式的伪造条目（如：%0a%0aINFO:+User+logged+out%3dbadguy），再查看日志是否新增成功。\n2、检查写入日志的敏感信息是否已经脱敏。\n预期结果：\n1、日志无法修改和新增。\n2、日志中存在敏感信息处已脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "敏感信息泄露",
        "details": "",
        "security_requirement": {
          "name": "敏感信息泄露",
          "details": "确保系统能够有效保护敏感信息，防止敏感信息泄露。"
        },
        "security_design": {
          "name": "敏感信息泄露",
          "details": "信息加密处理：\n运用强加密算法对敏感信息加密，如对称加密的 AES、非对称加密的 RSA 等，存储与传输时均保持加密状态，让攻击者难以获取明文内容，保障信息安全。\n访问严格管控：\n按角色、业务需求划分访问权限，实施多因素认证，像密码加指纹识别等，仅授权人员可接触敏感信息，杜绝越权访问引发泄露。\n监控预警机制：\n搭建监控系统，实时监测信息访问、传输情况，一旦有异常操作，如高频访问、异地访问等，及时发出警报并阻断，快速应对泄露隐患。"
        },
        "test_case": {
          "name": "敏感信息泄露",
          "details": "测试方法：\n1、是否使用HTTPS协议。\n2、应用系统界面关键地方如个人信息页面中的个人数据、财务信息等敏感信息是否加星号脱敏了。\n3、通过Fiddler抓包查看所有请求包、响应包中是否对敏感字段加密了。敏感字读如：name、phone、key、id等。\n预期结果：使用 HTTPS 协议传输；敏感信息在传输和存储时进行了加密或脱敏。"
        },
        "industry_standard": null
      }
    ]
  },
  "将用户重定向到其他URL": {
    "threats": [
      {
        "name": "URL重定向",
        "details": "",
        "security_requirement": {
          "name": "URL重定向",
          "details": "确保URL重定向功能不会被恶意用户滥用或利用。\n加强对URL重定向的验证和过滤，确保重定向的目标URL是合法和可信的。"
        },
        "security_design": {
          "name": "URL重定向",
          "details": "重定向目标验证：\n在执行 URL 重定向操作前，对目标 URL 进行严格的格式验证，确保其符合标准 URL 语法结构，剔除格式错误、可能存在恶意构造的 URL。\n白名单机制：\n建立可信 URL 白名单，仅允许重定向到白名单内的目标 URL，以此限制重定向范围，防止跳转到未知或恶意的外部网站。\n安全校验逻辑：\n对重定向请求来源进行合法性判断，结合用户身份、当前会话状态等多因素综合考量，确保发起重定向的请求是符合业务预期且合规的。\n数据完整性检查：\n针对涉及重定向的传入参数等数据进行完整性检查，防止攻击者通过篡改数据来操控重定向目标，使其指向恶意网址。"
        },
        "test_case": {
          "name": "URL重定向",
          "details": "测试方法：在有 URL 重定向的地方替换 URL 链接（如百度地址）后继续访问。\n预期结果：不能重定向到百度网站。"
        },
        "industry_standard": {
          "name": "通讯协议",
          "details": null
        }
      }
    ]
  },
  "交易记录": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "角色或权限验证": {
    "threats": [
      {
        "name": "角色权限蔓延",
        "details": "",
        "security_requirement": {
          "name": "角色权限蔓延",
          "details": "1. 完善的用户权限管理\n2. 禁止未授权访问"
        },
        "security_design": {
          "name": "角色权限蔓延",
          "details": "用户权限精准分配：\n根据用户的岗位职能与工作需求，精确设定其角色权限，避免权限过度授予。定期审查与更新用户权限，确保权限与实际业务要求始终匹配。\n权限变更审批流程：\n建立严格的权限变更审批机制，任何权限的增加、修改或删除都需经过相关部门或负责人的审批，并有详细记录可追溯，防止权限随意蔓延。\n访问控制强化：\n采用多层次的访问控制技术，如基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）等，对系统资源进行严格保护，确保只有经过授权的用户才能访问相应资源，有效禁止未授权访问行为。\n权限监控与审计：\n部署权限监控系统，实时跟踪用户权限的使用情况，对异常权限使用行为（如频繁访问未授权资源、权限使用时间异常等）及时预警。定期开展权限审计工作，检查是否存在权限蔓延迹象，发现问题及时整改。"
        },
        "test_case": {
          "name": "角色权限蔓延",
          "details": "测试方法：分别在不同的浏览器中登录两个账号，相互访问有差异性的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "角色权限提升",
        "details": "",
        "security_requirement": {
          "name": "角色权限提升",
          "details": "防止未经授权的用户获取系统中的高级权限或访问权限。\n加强对权限提升漏洞的识别和修复，及时堵塞潜在的安全漏洞。"
        },
        "security_design": {
          "name": "角色权限提升",
          "details": "权限分级与隔离：\n对系统内的权限进行细致分级，明确划分普通权限、中级权限、高级权限等不同层级，将不同层级权限对应的功能与资源严格隔离，确保低级别权限用户无法轻易触及高级权限相关内容，从架构层面防止权限的随意提升。\n身份验证强化：\n采用多因素身份验证手段，如在关键操作或涉及权限提升场景下，除常规用户名和密码外，增加指纹识别、动态口令、手机验证码等额外认证因素，全方位核实用户身份，提高非法获取高权限的门槛，避免未经授权用户提升权限。\n权限提升漏洞管理：\n定期开展全面的系统安全检测，运用专业的漏洞扫描工具以及人工渗透测试等方式，深度排查可能导致权限提升的各类漏洞，如权限绕过漏洞、越权访问漏洞等，建立详细的漏洞台账，对发现的漏洞及时安排修复，确保系统的安全性。\n行为监测与预警：\n搭建权限使用行为监测系统，实时关注用户在系统内的操作行为，尤其针对涉及权限变更、权限提升相关操作进行重点监测，一旦发现异常行为，例如低权限用户频繁尝试访问高级权限资源、短时间内出现不符合常规逻辑的权限提升请求等情况，立即触发预警机制，及时通知安全运维人员进行处置，防止未经授权的权限提升行为得逞。"
        },
        "test_case": {
          "name": "角色权限提升",
          "details": "测试方法：使用普通用户访问管理员特有的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "接口调用": {
    "threats": [
      {
        "name": "密钥劫持",
        "details": "",
        "security_requirement": {
          "name": "密钥劫持",
          "details": "确保 API 密钥的安全性，防止被恶意获取或滥用。\n加强对 API 访问的身份验证和授权，确保只有合法用户能够访问受保护的 API。"
        },
        "security_design": {
          "name": "密钥劫持",
          "details": "API 密钥生成安全：\n采用高强度随机数生成算法创建 API 密钥，结合时间戳、特定字符等元素，确保密钥的复杂性与唯一性，降低被暴力破解或猜测的风险，为其安全性奠定基础。\n传输加密措施：\n在 API 密钥于客户端与服务器端传输时，强制运用 HTTPS 等安全协议进行加密传输，防止密钥在网络传输途中被窃取，保障传输过程的保密性与完整性。\n存储安全机制：\n服务器端存储 API 密钥时，利用数据库加密功能或专用的密钥管理系统进行加密存储，并设置严格的访问权限，仅允许特定的授权服务或模块访问，防止因存储介质被攻破而导致密钥泄露。\n身份验证与授权强化：\n建立多重身份验证机制，如结合 API 密钥与用户密码、短信验证码或生物识别信息等进行综合验证。同时，细化授权策略，根据用户角色、IP 地址范围等因素，精确控制对不同 API 资源的访问权限，确保只有合法且经过授权的用户能够访问相应的 API，有效防止 API 密钥被恶意获取或滥用。"
        },
        "test_case": {
          "name": "密钥劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有密钥验证的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "密钥泄露",
        "details": "如果密钥被硬编码在代码中，一旦代码泄露或被逆向工程，攻击者可能会获取到密钥，从而对系统造成威胁，同时也增加了维护的复杂性。如果本地配置文件没有受到足够的保护，可能存在被泄露和篡改的风险，其中的密钥也会被泄露及篡改，导致敏感数据泄露或被攻击。",
        "security_requirement": {
          "name": "密钥泄露",
          "details": "确保 API 密钥的安全性，防止泄露给未经授权的第三方。\n加强对 API 密钥的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "密钥泄露",
          "details": "密钥生成强化：\n采用强加密算法与随机因子生成 API 密钥，使其具备高度复杂性与不可预测性，降低被破解获取的概率，构建密钥安全的首道防线。\n传输加密保障：\n借助安全传输协议如 HTTPS 传输 API 密钥，对其加密打包，防止在网络链路中被窃取，确保传输阶段的保密性与完整性。\n存储安全管控：\n利用加密存储技术与严格访问权限设置，将 API 密钥存储于安全区域，无论是数据库存储还是本地存储，都防止因存储介质暴露而引发泄露。\n定期更新机制：\n设定 API 密钥定期更新周期，促使使用者定期更换密钥，减少长期使用同一密钥带来的泄露风险，降低潜在危害的持续性。\n异常监测响应：\n搭建密钥使用异常监测体系，实时追踪密钥使用的频率、来源等，一旦发现异常，如短时间内异地频繁使用，立即暂停密钥并通知相关方，及时应对泄露危机。"
        },
        "test_case": {
          "name": "密钥泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有密钥验证的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "接口参数遍历",
        "details": "",
        "security_requirement": {
          "name": "接口参数遍历",
          "details": "调用API前，对请求的参数进行有效性校验"
        },
        "security_design": {
          "name": "接口参数遍历",
          "details": "参数格式校验：\n明确规定每个接口参数的正确格式，如数字类型参数应符合特定的数值范围与精度要求，字符串参数要遵循相应的长度限制与字符规范等。在接收请求时，严格按照既定格式标准对参数进行逐一核对，拒绝格式不符的参数进入后续处理流程，防止因格式错误引发的遍历风险。\n参数类型验证：\n仔细甄别每个参数的数据类型，确保传入的参数类型与接口定义的类型一致，例如，接口要求传入布尔值的参数就不能接收整数或字符串类型。通过代码逻辑或专门的验证工具，对参数类型进行严格验证，避免因类型不匹配被恶意利用进行参数遍历攻击。\n取值范围核查：\n针对有取值范围限定的参数，详细梳理并设定其合理的上下限，像日期参数限定在某个有效时间段内，数量参数处于一定的数值区间等。在处理请求前，认真检查参数的实际取值是否落在规定范围内，杜绝超出范围的参数参与接口调用，以此减少因参数取值异常导致的遍历漏洞。\n必选与可选参数判定：\n清晰界定每个接口的必选参数和可选参数清单，对于必选参数，严格要求请求中必须包含且内容完整有效；对于可选参数，验证其出现的合理性以及是否符合相应的使用条件。通过这种精准判定，防止攻击者通过遗漏必选参数或滥用可选参数来尝试参数遍历行为。\n合法性逻辑校验：\n依据业务逻辑和接口功能需求，对参数之间的关联性与合法性进行综合校验。例如，某个操作的多个参数之间存在特定的运算关系或逻辑约束，要确保传入的参数组合满足这些逻辑要求。这样能从更深层次杜绝不符合正常业务逻辑的参数组合进入系统，有效抵御参数遍历攻击。\n异常处理与反馈机制：\n构建完善的参数校验异常处理流程，当发现参数存在无效情况时，及时返回恰当且模糊的错误提示信息给请求方，避免透露过多有助于攻击者进行进一步遍历尝试的细节。同时，记录参数校验异常的相关情况，便于后续分析和排查潜在的安全隐患。\n"
        },
        "test_case": {
          "name": "接口参数遍历",
          "details": "测试方法：\n 1、在用过参数 id （或其他类似参数）访问的地方，访问无权访问的 id 值；\n2、观察 id 值是否是 随机hash 值\n预期结果：\n1、未经授权的用户无法访问受保护的接口和数据。\n2、id 值应为 hash 随机值。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      },
      {
        "name": "接口滥用",
        "details": "",
        "security_requirement": {
          "name": "接口滥用",
          "details": "防止恶意用户或攻击者滥用系统提供的接口进行非法操作。\n加强对接口访问的身份验证和访问控制，确保只有合法用户可以访问接口。"
        },
        "security_design": {
          "name": "接口滥用",
          "details": "身份验证强化：\n采用多因素认证，定期更新凭据，防身份冒用。\n访问控制细化：\n用 RBAC 依角色分权限，ABAC 多属性判访问，精准控接口访问。\n访问频率限制：\n设接口访问次数上限，依角色等级差异设限，防高频滥用。\n接口调用审计：\n记接口调用日志，定期审查，查异常并处理。\n异常行为监测：\n建监测系统，关注异常迹象，用机器学习精准识异常，及时阻断。"
        },
        "test_case": {
          "name": "接口滥用",
          "details": "测试方法：登录账户后，通过Fiddler抓包工具访问应用系统的资源，将会话信息删除如cookie、token、jwt，再次请求查看是否正常响应。\n预期结果：报错或拒绝访问。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      },
      {
        "name": "接口注入",
        "details": "",
        "security_requirement": {
          "name": "接口注入",
          "details": "防止恶意用户或攻击者利用接口漏洞进行注入攻击。\n加强对接口输入数据的验证和过滤，防止恶意数据的注入。"
        },
        "security_design": {
          "name": "接口注入",
          "details": "输入数据格式验证：\n明确各接口所接收数据的正确格式，如规定字符串类型数据应符合特定的长度、字符范围要求，数字类型要满足相应的数值区间与精度限制等，严格按格式标准对输入数据进行校验，拒绝格式不符的数据进入，降低注入攻击风险。\n数据类型严格甄别：\n仔细核对接口输入数据的类型，确保传入的数据类型与接口定义的类型精准匹配，像要求是布尔型的数据就不能接收整型或字符串型等其他类型，防止因类型混淆被恶意利用来实施注入攻击。\n危险字符过滤：\n梳理出常见的可用于注入攻击的危险字符（如 SQL 注入中的单引号、双引号、分号等，命令注入中的 &、| 等），在接口接收输入数据时，运用正则表达式等技术手段，将这些危险字符进行过滤或转义处理，避免其混入正常数据中造成安全隐患。\n语义完整性校验：\n依据接口对应的业务逻辑，对输入数据之间的关联性及语义完整性进行检查，确保数据组合符合正常业务流程和操作要求，防止攻击者通过构造特殊语义的数据来绕过验证机制并发起注入攻击。\n输入长度限制：\n为接口接收的各类输入数据设定合理的长度限制，根据实际业务场景确定最长允许的字符数或字节数，避免攻击者通过输入超长数据来触发缓冲区溢出等漏洞，进而实施注入攻击，从长度方面把控数据安全性。\n验证机制持续优化：\n定期回顾和分析接口注入攻击的案例及趋势，不断改进和完善数据验证与过滤机制，及时更新危险字符列表、优化验证逻辑等，确保能应对不断变化的注入攻击手段，持续保障接口安全。"
        },
        "test_case": {
          "name": "接口注入",
          "details": "测试方法：在输入的功能处，输入一些特殊字符如、‘ “” \">\" cat /etc/passwd ?id=1;ls等，查看服务器是否正常响应。\n预期结果：无任何内容显示并提示输入非法。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "拒绝服务攻击",
        "details": "",
        "security_requirement": {
          "name": "拒绝服务攻击",
          "details": "确保系统能够有效防止拒绝服务攻击，保护系统的可用性和稳定性。"
        },
        "security_design": {
          "name": "拒绝服务攻击",
          "details": "输入验证强化：\n开发时对所有外部输入进行严格校验，包括数据格式、长度、类型等。例如对用户提交的表单数据、API 传入参数，通过正则表达式与数据类型检查确保其合法性，杜绝恶意构造的输入引发系统异常或资源耗尽，从而抵御攻击。\n并发控制策略：\n精心设计并发处理逻辑，利用线程池、信号量等技术限制同时处理的请求数量。依据系统硬件资源与正常业务负载，设定合理阈值，防止大量并发恶意请求使系统资源耗尽而瘫痪，保障服务稳定运行。\n资源监控与限制：\n在代码中嵌入资源监控模块，实时跟踪 CPU、内存、磁盘 I/O 等关键资源的使用情况。一旦资源使用接近危险阈值，自动限制非关键业务的资源分配，优先保障核心业务运行，避免因资源被恶意占用导致系统不可用。\n缓存机制优化：\n优化缓存策略，对频繁访问的数据进行合理缓存，设置缓存有效期与容量限制。既减少重复计算与数据库查询，提升系统响应速度，又防止缓存被恶意数据填满，影响正常业务数据缓存，保障系统高效稳定运行。\n异常处理完善：\n构建全面的异常处理体系，对于可能出现的各类异常情况，如网络中断、数据库连接失败、资源不足等，进行优雅处理。避免因未处理的异常导致系统崩溃或陷入无限循环，增强系统在面对异常与攻击时的韧性。\n代码模块化与隔离：\n将系统功能进行合理模块化，不同模块间设置清晰的边界与访问权限。当某个模块遭受攻击时，通过隔离机制限制影响范围，防止恶意攻击蔓延至整个系统，确保其他模块仍能正常提供服务，维持系统整体可用性。"
        },
        "test_case": {
          "name": "拒绝服务攻击",
          "details": "测试方法：功能测试压力测试"
        },
        "industry_standard": null
      },
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "金融支付接口": {
    "threats": [
      {
        "name": "接口滥用",
        "details": "",
        "security_requirement": {
          "name": "接口滥用",
          "details": "防止恶意用户或攻击者滥用系统提供的接口进行非法操作。\n加强对接口访问的身份验证和访问控制，确保只有合法用户可以访问接口。"
        },
        "security_design": {
          "name": "接口滥用",
          "details": "身份验证强化：\n采用多因素认证，定期更新凭据，防身份冒用。\n访问控制细化：\n用 RBAC 依角色分权限，ABAC 多属性判访问，精准控接口访问。\n访问频率限制：\n设接口访问次数上限，依角色等级差异设限，防高频滥用。\n接口调用审计：\n记接口调用日志，定期审查，查异常并处理。\n异常行为监测：\n建监测系统，关注异常迹象，用机器学习精准识异常，及时阻断。"
        },
        "test_case": {
          "name": "接口滥用",
          "details": "测试方法：登录账户后，通过Fiddler抓包工具访问应用系统的资源，将会话信息删除如cookie、token、jwt，再次请求查看是否正常响应。\n预期结果：报错或拒绝访问。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "进行单点登录反向代理": {
    "threats": [
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": null
      }
    ]
  },
  "进行支付交易处理": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "支付漏洞",
        "details": "",
        "security_requirement": {
          "name": "支付漏洞",
          "details": "1. 服务器端在生成交易订单时，商品的价格从数据库中取出，禁止使用客户端发送的商品价格。\n2. 服务器端对客户端提交的交易数据（如商品ID、商品数量、商品价格等）的取值范围进行校验，将商品ID和商品价格与数据库中的数据对比校验，商品数量为大于零的整型数。\n3. 服务器端在生成支付订单时，对支付订单中影响支付金额的所有因素（比如商品ID、商品数量、商品价格、订单编号等）进行签名，对客户端提交的支付订单进行校验"
        },
        "security_design": {
          "name": "支付漏洞",
          "details": "价格获取规范：\n服务器生成交易订单时，务必从数据库取商品价格，杜绝用客户端发送价格，防止客户端篡改价格造成支付漏洞，保障交易金额准确。\n数据取值校验：\n服务器要校验客户端提交的交易数据取值范围，比对商品 ID、价格与数据库记录，限定商品数量为正整数，避免异常数据影响支付金额准确性。\n支付订单签名：\n生成支付订单时，对影响支付金额的各因素签名，校验客户端提交的支付订单，以此验证订单完整性与真实性，有效堵住支付漏洞，确保支付安全。"
        },
        "test_case": {
          "name": "支付漏洞",
          "details": "测试方法：创建订单时，尝试输入不同的数据，包括合法已存在或非法的数据，例如订单数量、价格、产品信息等。观察系统对输入数据的反应。\n预期结果：创建失败。"
        },
        "industry_standard": null
      }
    ]
  },
  "举报机制": {
    "threats": [
      {
        "name": "信息滥用",
        "details": "",
        "security_requirement": {
          "name": "信息滥用",
          "details": "信息访问权限最小化，防止信息泄露。"
        },
        "security_design": {
          "name": "信息滥用",
          "details": "信息权限管理：\n采用 RBAC 模型，依角色分配信息访问权限，遵循最小化原则，如客服仅能看客户基本信息，限制访问敏感数据，降低信息滥用风险。\n信息使用审计：\n构建审计机制，记录用户信息访问详情，定期审查日志，发现异常访问模式，如频繁访问无关信息，以便及时查处。\n数据脱敏与加密：\n敏感信息存储与传输时脱敏，模糊或替换身份证号等敏感字段，且加密重要信息，仅授权用户用解密密钥可访问，增加信息滥用难度。"
        },
        "test_case": {
          "name": "信息滥用",
          "details": "测试方法：查看应用程序的输出和日志，确认敏感数据（如身份证号码、银行卡号等）在显示时进行了脱敏处理（例如，只显示部分数据或替换为星号）。\n预期结果：敏感数据在显示和存储时脱敏处理得当。"
        },
        "industry_standard": null
      }
    ]
  },
  "拒绝": {
    "threats": [
      {
        "name": "基本身份认证",
        "details": "",
        "security_requirement": {
          "name": "基本身份认证",
          "details": "1. 需要有强密码策略；\n2. 应支持管理员后台锁定账号活动异常的用户账号；\n3. 用户在应用系统中输入密码时，不能明文显示密码，应显示为“*”号或者不显示\n4. 身份验证的失败提示信息采用模糊处理\n5. 应强制用户首次登录时修改初始口令（非用户自行注册且由系统后台直接添加的用户）\n6. 用户身份鉴别信息丢失或失效时，应采用技术措施确保鉴别信息重置过程的安全"
        },
        "security_design": {
          "name": "基本身份认证",
          "details": "强密码策略制定：\n设定密码长度、复杂度要求，如至少包含大小写字母、数字、特殊字符，长度不少于 8 位，定期提示用户更新密码，防止因密码简单导致账号被破解。\n账号锁定机制：\n管理员后台具备监控账号活动功能，当发现异常登录行为（如短时间内多次登录失败、异地登录等），可及时锁定相关账号，阻止非法访问进一步发生。\n密码显示安全：\n在用户输入密码时，应用系统界面将密码以 “*” 号或无显示形式呈现，避免密码明文暴露，防止他人偷窥获取密码信息。\n失败提示模糊处理：\n身份验证失败时，不提供具体错误原因，如用户名错误或密码错误等精确信息，仅给出通用模糊提示，防止攻击者利用提示信息进行暴力破解或账号猜测。\n初始口令修改：\n对于非用户自行注册且由系统后台直接添加的用户，首次登录时强制要求修改初始口令，避免初始口令泄露引发安全问题。\n鉴别信息重置安全：\n当用户身份鉴别信息丢失或失效时，通过多因素验证（如手机验证码、邮箱验证等）或安全问答等技术手段，确保重置过程安全可靠，防止非法重置他人账号鉴别信息。"
        },
        "test_case": {
          "name": "基本身份认证",
          "details": "测试方法：\n1、在注册或修改密码处测试，测试密码复杂度（例如是否满足最小长度、数字、字母、特殊字符几种的组合等）。\n2、确认错误提示信息是否模糊。\n预期结果：\n1、密码复杂度策略强制执行，不符合强度要求的密码不允许进入下一步流程；\n2、登录错误提示信息应模糊，只指出登录失败，而不透露具体错误原因（例如，用户名或密码不匹配）。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "可视化处理": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "链接验证": {
    "threats": [
      {
        "name": "恶意链接检测",
        "details": "",
        "security_requirement": {
          "name": "恶意链接检测",
          "details": "确保系统能够识别和阻止虚假链接，保护用户免受虚假链接的欺骗和攻击。"
        },
        "security_design": {
          "name": "恶意链接检测",
          "details": "链接信誉库查询：\n接入权威的链接信誉数据库，实时查询系统内出现的链接信誉评分。对于信誉不佳、被标记为恶意或可疑的链接，直接进行拦截，禁止用户访问，从而有效阻止已知恶意链接的传播。\n深度链接分析：\n采用先进的链接分析技术，对链接的目标 URL、域名注册信息、页面内容特征等多方面进行深度剖析。例如，检查域名是否存在异常字符组合、页面是否包含恶意脚本或钓鱼特征代码等，以此精准识别伪装巧妙的恶意链接。\n用户行为监测与预警：\n密切关注用户与链接的交互行为，如某个用户短时间内频繁点击来源不明的链接，或者大量用户集中点击同一可疑链接等异常行为。一旦发现，及时向用户发出风险预警，并对相关链接进行进一步审查和处理，防止恶意链接在用户群体中扩散。\n动态链接检测更新：\n随着恶意链接技术的不断演变，持续更新恶意链接检测算法和规则库。定期进行模拟攻击测试，及时发现系统检测机制的漏洞并加以完善，确保能够及时跟上新型恶意链接的变化趋势，始终保持对恶意链接的有效检测和拦截能力。"
        },
        "test_case": {
          "name": "恶意链接检测",
          "details": "测试方法：尝试在用户输入的文本中添加一个可疑链接，例如指向不信任的域名或包含特殊字符的链接。\n预期结果：系统应识别这些可疑链接并且进行标记，并在用户提交后显示警告或错误消息，阻止链接的传播。"
        },
        "industry_standard": null
      }
    ]
  },
  "令牌认证（Token）": {
    "threats": [
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "浏览器（针对新上线）": {
    "threats": [
      {
        "name": "HSTS绕过",
        "details": "",
        "security_requirement": {
          "name": "HSTS绕过",
          "details": "确保网站的HSTS策略能够有效地防止中间人攻击和SSL剥离攻击，保护用户数据在传输过程中的安全性和完整性。\n加强对HSTS策略的安全设计和实施，防止HSTS绕过导致的安全漏洞和数据泄露问题。"
        },
        "security_design": {
          "name": "HSTS绕过",
          "details": "HSTS 策略制定与部署：\n合理设置 HSTS 策略的最大年龄（max-age）参数，选择较长且合适的时长，确保浏览器能在较长时间内强制使用 HTTPS 进行连接，减少被绕过的机会。\n在网站的所有相关域名（包括子域名等）上统一、全面地部署 HSTS 策略，避免出现策略覆盖不全的情况，不给攻击者留下可利用的薄弱环节。\n服务器 SSL/TLS 配置强化：\n对网站服务器的 SSL/TLS 配置进行严格优化，采用最新且安全可靠的加密算法和协议版本，增强连接的安全性，使得攻击者难以突破 HSTS 防护进行中间人攻击等。\n网站代码安全校验逻辑嵌入：\n在网站代码中嵌入额外的安全校验逻辑，例如在页面加载、资源请求等环节再次验证连接是否遵循 HSTS 要求，若发现异常及时阻断并提示用户。\n连接监控与应急响应机制：\n建立针对网站连接情况的实时监控体系，重点关注是否存在不符合 HSTS 策略的连接请求，分析其来源、特征等信息，及时察觉潜在的 HSTS 绕过行为。\n一旦监测到有疑似 HSTS 绕过的情况发生，迅速启动应急响应流程，一方面阻断相关异常连接，另一方面向运维和安全团队发送告警信息，以便及时进行漏洞排查、修复以及溯源等工作，防止数据泄露和安全风险进一步扩大。"
        },
        "test_case": {
          "name": "HSTS绕过",
          "details": "测试方法：使用HTTP方式访问HTTPS的地址，查看是否能访问成功。\n预期结果：自动跳转 HTTPS 访问或拒绝访问提示网站开启 HSTS。"
        },
        "industry_standard": null
      },
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": null
      }
    ]
  },
  "抽奖活动": {
    "threats": [
      {
        "name": "篡改",
        "details": "",
        "security_requirement": {
          "name": "篡改",
          "details": "确保系统能够防止数据在传输或存储过程中被篡改，保护数据的完整性和准确性。"
        },
        "security_design": {
          "name": "篡改",
          "details": "传输加密：\n在数据传输阶段，采用强加密算法（如 SSL/TLS 协议等）对数据进行加密处理，确保数据在网络通道中以密文形式传输，即使被拦截，攻击者也难以对密文内容进行篡改，保障传输过程的数据完整性。\n存储加密：\n对于存储的数据，使用合适的加密方式（如对称加密、非对称加密等）进行加密存储，只有拥有正确解密密钥的授权主体才能访问原始数据，防止存储过程中数据被非法篡改。\n完整性校验：\n定期或在数据使用前，采用哈希算法（如 SHA-256 等）计算数据的哈希值，并与预先保存的正确哈希值进行比对，若两者不一致，则表明数据可能被篡改，需进一步排查处理。\n访问控制：\n严格设置数据的访问权限，依据用户角色、权限级别等因素，只允许授权人员对数据进行读写等操作，限制非授权访问，从源头上减少数据被篡改的风险。\n监控与告警：\n搭建数据状态的监控系统，实时关注数据传输、存储过程中的相关指标，如数据流量变化、加密状态、完整性校验结果等，一旦发现疑似数据篡改的异常情况，及时触发告警，通知安全运维人员进行深入调查和修复。\n备份恢复：\n制定合理的数据备份策略，定期对重要数据进行备份，存储在独立、安全的介质或位置，当发现数据被篡改时，可利用备份数据进行恢复，最大程度降低篡改带来的损失。"
        },
        "test_case": {
          "name": "篡改",
          "details": "测试方法：使用 Fiddler 抓包，检查传输过程中敏感数据是否进行了加密。\n预期结果：使用非 MD5、base64等弱加密算法。"
        },
        "industry_standard": null
      },
      {
        "name": "敏感信息泄露",
        "details": "",
        "security_requirement": {
          "name": "敏感信息泄露",
          "details": "确保系统能够有效保护敏感信息，防止敏感信息泄露。"
        },
        "security_design": {
          "name": "敏感信息泄露",
          "details": "信息加密处理：\n运用强加密算法对敏感信息加密，如对称加密的 AES、非对称加密的 RSA 等，存储与传输时均保持加密状态，让攻击者难以获取明文内容，保障信息安全。\n访问严格管控：\n按角色、业务需求划分访问权限，实施多因素认证，像密码加指纹识别等，仅授权人员可接触敏感信息，杜绝越权访问引发泄露。\n监控预警机制：\n搭建监控系统，实时监测信息访问、传输情况，一旦有异常操作，如高频访问、异地访问等，及时发出警报并阻断，快速应对泄露隐患。"
        },
        "test_case": {
          "name": "敏感信息泄露",
          "details": "测试方法：\n1、是否使用HTTPS协议。\n2、应用系统界面关键地方如个人信息页面中的个人数据、财务信息等敏感信息是否加星号脱敏了。\n3、通过Fiddler抓包查看所有请求包、响应包中是否对敏感字段加密了。敏感字读如：name、phone、key、id等。\n预期结果：使用 HTTPS 协议传输；敏感信息在传输和存储时进行了加密或脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "拒绝服务攻击",
        "details": "",
        "security_requirement": {
          "name": "拒绝服务攻击",
          "details": "确保系统能够有效防止拒绝服务攻击，保护系统的可用性和稳定性。"
        },
        "security_design": {
          "name": "拒绝服务攻击",
          "details": "输入验证强化：\n开发时对所有外部输入进行严格校验，包括数据格式、长度、类型等。例如对用户提交的表单数据、API 传入参数，通过正则表达式与数据类型检查确保其合法性，杜绝恶意构造的输入引发系统异常或资源耗尽，从而抵御攻击。\n并发控制策略：\n精心设计并发处理逻辑，利用线程池、信号量等技术限制同时处理的请求数量。依据系统硬件资源与正常业务负载，设定合理阈值，防止大量并发恶意请求使系统资源耗尽而瘫痪，保障服务稳定运行。\n资源监控与限制：\n在代码中嵌入资源监控模块，实时跟踪 CPU、内存、磁盘 I/O 等关键资源的使用情况。一旦资源使用接近危险阈值，自动限制非关键业务的资源分配，优先保障核心业务运行，避免因资源被恶意占用导致系统不可用。\n缓存机制优化：\n优化缓存策略，对频繁访问的数据进行合理缓存，设置缓存有效期与容量限制。既减少重复计算与数据库查询，提升系统响应速度，又防止缓存被恶意数据填满，影响正常业务数据缓存，保障系统高效稳定运行。\n异常处理完善：\n构建全面的异常处理体系，对于可能出现的各类异常情况，如网络中断、数据库连接失败、资源不足等，进行优雅处理。避免因未处理的异常导致系统崩溃或陷入无限循环，增强系统在面对异常与攻击时的韧性。\n代码模块化与隔离：\n将系统功能进行合理模块化，不同模块间设置清晰的边界与访问权限。当某个模块遭受攻击时，通过隔离机制限制影响范围，防止恶意攻击蔓延至整个系统，确保其他模块仍能正常提供服务，维持系统整体可用性。"
        },
        "test_case": {
          "name": "拒绝服务攻击",
          "details": "测试方法：功能测试压力测试"
        },
        "industry_standard": null
      },
      {
        "name": "角色权限提升",
        "details": "",
        "security_requirement": {
          "name": "角色权限提升",
          "details": "防止未经授权的用户获取系统中的高级权限或访问权限。\n加强对权限提升漏洞的识别和修复，及时堵塞潜在的安全漏洞。"
        },
        "security_design": {
          "name": "角色权限提升",
          "details": "权限分级与隔离：\n对系统内的权限进行细致分级，明确划分普通权限、中级权限、高级权限等不同层级，将不同层级权限对应的功能与资源严格隔离，确保低级别权限用户无法轻易触及高级权限相关内容，从架构层面防止权限的随意提升。\n身份验证强化：\n采用多因素身份验证手段，如在关键操作或涉及权限提升场景下，除常规用户名和密码外，增加指纹识别、动态口令、手机验证码等额外认证因素，全方位核实用户身份，提高非法获取高权限的门槛，避免未经授权用户提升权限。\n权限提升漏洞管理：\n定期开展全面的系统安全检测，运用专业的漏洞扫描工具以及人工渗透测试等方式，深度排查可能导致权限提升的各类漏洞，如权限绕过漏洞、越权访问漏洞等，建立详细的漏洞台账，对发现的漏洞及时安排修复，确保系统的安全性。\n行为监测与预警：\n搭建权限使用行为监测系统，实时关注用户在系统内的操作行为，尤其针对涉及权限变更、权限提升相关操作进行重点监测，一旦发现异常行为，例如低权限用户频繁尝试访问高级权限资源、短时间内出现不符合常规逻辑的权限提升请求等情况，立即触发预警机制，及时通知安全运维人员进行处置，防止未经授权的权限提升行为得逞。"
        },
        "test_case": {
          "name": "角色权限提升",
          "details": "测试方法：使用普通用户访问管理员特有的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "未接入互联网行为风控系统",
        "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统",
        "security_requirement": {
          "name": "接入互联网行为风控系统",
          "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统。"
        },
        "security_design": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "test_case": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》测试是否已接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "industry_standard": null
      }
    ]
  },
  "留言板": {
    "threats": [
      {
        "name": "XSS保护绕过",
        "details": "",
        "security_requirement": {
          "name": "XSS保护绕过",
          "details": "确保网站或应用程序实施了有效的 XSS 防护措施，包括输入验证、输出编码和内容安全策略等。\n加强对用户输入和输出的验证和过滤，防止 XSS 攻击的发生和影响。"
        },
        "security_design": {
          "name": "XSS保护绕过",
          "details": "输入验证强化：\n对用户输入的各类数据（如表单字段、查询参数等）进行深度验证，不仅检查数据格式、长度，还分析其语义内容，依据业务逻辑严格甄别合法与非法输入，拒绝可能用于构造 XSS 攻击的恶意输入。\n输出编码细化：\n根据输出内容的类型（如 HTML、JavaScript、CSS 等）采用针对性的编码方式，例如在 HTML 输出时对特殊字符（<、>、&、'、\" 等）进行 HTML 实体编码，确保输出内容无法被浏览器解析为恶意脚本，且覆盖所有可能的输出场景，避免遗漏导致绕过防护。\n内容安全策略优化：\n完善内容安全策略（CSP），采用严格的白名单机制，明确允许加载的脚本、样式等资源来源，禁止一切非授权来源的内容加载，同时定期审查和更新 CSP，使其能适应业务变化与新出现的绕过手段。\n上下文敏感过滤：\n考虑输入输出的上下文环境，比如在 JavaScript 字符串中、HTML 属性内等不同场景下，对输入内容进行差异化的过滤与转义处理，精准防止攻击者利用特定上下文进行 XSS 绕过攻击。\n安全框架更新与选用：\n及时更新应用程序所使用的安全框架，选用具有更强抗 XSS 绕过能力的框架，利用其内置的先进防护机制来加固整体安全防线，降低被绕过的风险。"
        },
        "test_case": {
          "name": "XSS保护绕过",
          "details": "测试方法：在输出的功能处输入恶意的JavaScript代码或HTML元素如alert()、<script></script>、\"></script>。\n预期结果：返回报错，或转义后返回前端，或原封不动文本形式返回前端。"
        },
        "industry_standard": null
      }
    ]
  },
  "密码重置": {
    "threats": [
      {
        "name": "用户名密码重置",
        "details": "",
        "security_requirement": {
          "name": "用户名密码重置",
          "details": "1. 针对敏感操作需要进行二次验证\n2. 保证敏感操作的二次验证的不可绕过"
        },
        "security_design": {
          "name": "用户名密码重置",
          "details": "双重验证机制：\n实施短信验证码与动态口令相结合的二次验证。用户发起密码重置时，先接收短信验证码，再输入动态口令。动态口令由专门的安全令牌生成，基于时间或事件同步算法，具有唯一性与时效性，增加验证难度。\n流程严格把控：\n验证流程中，各环节紧密相连且不可回退。每步都与用户注册时预留信息及当前设备特征绑定，如设备指纹识别。若检测到异常设备或信息不匹配，立即终止并告警，确保无法绕过验证。\n实时监测防护：\n建立实时监测系统，分析验证行为特征。对短时间内多次尝试、异地请求等异常行为进行识别拦截，锁定异常账号并通知用户，有效防止非法绕过二次验证进行密码重置。\n"
        },
        "test_case": {
          "name": "用户名密码重置",
          "details": "测试方法：在密码修改、忘记密码、密码充值功能处是否有二次认证。\n预期结果：存在有效的二次认证或短信验证码等。"
        },
        "industry_standard": {
          "name": "鉴别数据保护",
          "details": null
        }
      }
    ]
  },
  "密钥管理": {
    "threats": [
      {
        "name": "密钥存储安全",
        "details": "",
        "security_requirement": {
          "name": "密钥存储安全",
          "details": "确保密钥在存储和传输过程中的机密性和完整性。\n防止未经授权的访问和使用敏感密钥。"
        },
        "security_design": {
          "name": "密钥存储安全",
          "details": "存储加密：\n采用专业加密算法对密钥加密后存储，如 AES 算法，搭配安全的密钥管理系统，将其存于独立且有严格访问控制的区域，防止存储时被窃取，保障机密性与完整性。\n传输防护：\n运用安全传输协议（如 TLS/SSL）传输密钥，对其加密打包，杜绝传输中遭拦截篡改，同时认证通信双方身份，避免未经授权访问。\n权限管理：\n设置精细的权限体系，只允许特定授权角色对密钥进行操作，定期审计权限使用情况，确保密钥不被违规使用。"
        },
        "test_case": {
          "name": "密钥存储安全",
          "details": "测试方法：咨询开发，了解应用程序是否使用安全的加密方法存储密钥，如硬件安全模块（HSM）或密钥管理服务（KMS）。\n预期结果：密钥应加密安全存储，受加密保护，只有授权的应用程序或用户才能访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "敏感数据加密": {
    "threats": [
      {
        "name": "密钥及加密算法安全",
        "details": "",
        "security_requirement": {
          "name": "密钥及加密算法安全",
          "details": "应保证秘钥分发存储及加密算法的安全"
        },
        "security_design": {
          "name": "密钥及加密算法安全",
          "details": "密钥分发安全：\n采用安全的密钥分发协议，如基于公钥基础设施（PKI）的方式。在分发过程中，对密钥进行加密传输，结合数字签名确保其来源可靠、未被篡改，防止密钥在分发环节被窃取或替换。\n密钥存储安全：\n利用硬件安全模块（HSM）或加密文件系统存储密钥。对存储介质设置严格访问权限，仅授权进程或用户可访问，且密钥以加密形式保存，避免因存储设备被攻破而泄露。\n加密算法安全：\n选用成熟且经过广泛安全验证的加密算法，如 AES、RSA 等。定期关注加密算法的安全性动态，及时更新或替换存在潜在风险的算法，确保加密过程的可靠性与保密性。\n"
        },
        "test_case": {
          "name": "密钥及加密算法安全",
          "details": "测试方法：咨询开发使用的算法。\n预期结果：应用程序使用强度足够的加密算法，例如AES-256、符合国密要求的算法等。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据加解密",
        "details": "",
        "security_requirement": {
          "name": "数据加解密",
          "details": "使用安全的加密算法。"
        },
        "security_design": {
          "name": "数据加解密",
          "details": "对称加密算法选用\n可采用 AES（高级加密标准）算法，它运算速度快，密钥长度可选 128 位、192 位或 256 位，能高效加密大量数据。使用同一密钥进行加密和解密，只要妥善保管好密钥，就能保障数据在传输和存储时的保密性，常用于对文件、数据库等数据加密。\n非对称加密算法运用\n像 RSA 算法，有公钥和私钥之分，公钥可公开用于加密，私钥则保密用于解密。适用于密钥交换、数字签名等场景，能在不安全网络环境中安全传递信息，保证数据加解密的安全性，常辅助对称加密进行密钥管理等操作。\n哈希算法保障完整性\n例如 SHA-256 哈希算法，能将任意长度的数据转换为固定长度的哈希值。数据传输前后对比哈希值，若一致则说明数据未被篡改，虽不能还原数据本身，但可验证数据完整性，在保障数据安全方面起着重要作用。"
        },
        "test_case": {
          "name": "数据加解密",
          "details": "测试方法：咨询开发使用的加解密算法。\n预期结果：使用了安全的算法。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      }
    ]
  },
  "内容安全策略（CSP）（针对新上线）": {
    "threats": [
      {
        "name": "CSP绕过",
        "details": "",
        "security_requirement": {
          "name": "CSP绕过",
          "details": "确保网站能够有效地实施内容安全策略（CSP），防止恶意用户通过绕过CSP来执行恶意脚本或注入攻击。\n加强对网站的安全控制和监控，及时发现和阻止CSP绕过行为，保护用户的访问安全和数据安全。"
        },
        "security_design": {
          "name": "CSP绕过",
          "details": "CSP 策略制定与配置：\n依据网站实际功能与业务需求，制定严格且细致的内容安全策略（CSP），明确允许加载的资源来源（如脚本、样式表等），采用白名单机制，禁止一切非授权来源的资源加载。\n定期对 CSP 策略进行审查和更新，确保其能适应网站功能变化以及不断出现的新安全威胁，保持策略的有效性。\n安全增强措施：\n在网页代码开发过程中，对输入输出内容进行严格的过滤与验证，防止恶意内容混入，避免给攻击者提供可乘之机来绕过 CSP 执行恶意脚本。\n采用多层安全防护机制，如结合前端框架自带的安全特性以及服务器端的安全校验等，共同加固对内容安全的管控，降低 CSP 被绕过的风险。\n监控与响应机制：\n搭建全方位的网站安全监控系统，重点关注与 CSP 相关的资源加载、脚本执行等行为，实时收集访问日志等数据进行分析，及时发现异常访问模式或疑似 CSP 绕过的行为迹象。\n一旦检测到 CSP 绕过行为，迅速触发警报，同时自动采取应急措施，如阻断相关恶意请求、暂停受影响的页面功能等，并通知安全运维人员及时进行深入排查与修复，防止安全事件进一步扩大。"
        },
        "test_case": {
          "name": "CSP绕过",
          "details": "测试方法：访问网站并查看HTTP响应头中是否包含Content-Security-Policy，且已经设置。\n预期结果：该字段已配置特定的域名规则或策略文件名称，而非“*”或未配置。"
        },
        "industry_standard": null
      }
    ]
  },
  "内容加密传输": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "批准": {
    "threats": [
      {
        "name": "基本身份认证",
        "details": "",
        "security_requirement": {
          "name": "基本身份认证",
          "details": "1. 需要有强密码策略；\n2. 应支持管理员后台锁定账号活动异常的用户账号；\n3. 用户在应用系统中输入密码时，不能明文显示密码，应显示为“*”号或者不显示\n4. 身份验证的失败提示信息采用模糊处理\n5. 应强制用户首次登录时修改初始口令（非用户自行注册且由系统后台直接添加的用户）\n6. 用户身份鉴别信息丢失或失效时，应采用技术措施确保鉴别信息重置过程的安全"
        },
        "security_design": {
          "name": "基本身份认证",
          "details": "强密码策略制定：\n设定密码长度、复杂度要求，如至少包含大小写字母、数字、特殊字符，长度不少于 8 位，定期提示用户更新密码，防止因密码简单导致账号被破解。\n账号锁定机制：\n管理员后台具备监控账号活动功能，当发现异常登录行为（如短时间内多次登录失败、异地登录等），可及时锁定相关账号，阻止非法访问进一步发生。\n密码显示安全：\n在用户输入密码时，应用系统界面将密码以 “*” 号或无显示形式呈现，避免密码明文暴露，防止他人偷窥获取密码信息。\n失败提示模糊处理：\n身份验证失败时，不提供具体错误原因，如用户名错误或密码错误等精确信息，仅给出通用模糊提示，防止攻击者利用提示信息进行暴力破解或账号猜测。\n初始口令修改：\n对于非用户自行注册且由系统后台直接添加的用户，首次登录时强制要求修改初始口令，避免初始口令泄露引发安全问题。\n鉴别信息重置安全：\n当用户身份鉴别信息丢失或失效时，通过多因素验证（如手机验证码、邮箱验证等）或安全问答等技术手段，确保重置过程安全可靠，防止非法重置他人账号鉴别信息。"
        },
        "test_case": {
          "name": "基本身份认证",
          "details": "测试方法：\n1、在注册或修改密码处测试，测试密码复杂度（例如是否满足最小长度、数字、字母、特殊字符几种的组合等）。\n2、确认错误提示信息是否模糊。\n预期结果：\n1、密码复杂度策略强制执行，不符合强度要求的密码不允许进入下一步流程；\n2、登录错误提示信息应模糊，只指出登录失败，而不透露具体错误原因（例如，用户名或密码不匹配）。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "票务信息": {
    "threats": [
      {
        "name": "票务盗用",
        "details": "",
        "security_requirement": {
          "name": "票务盗用",
          "details": "确保票务信息的安全性，防止票务被盗用或篡改。"
        },
        "security_design": {
          "name": "票务盗用",
          "details": "票务信息加密：\n采用可靠的加密算法，如 AES 等，对票务关键信息（像票务编号、座位号、使用权限等）进行加密存储与传输，使不法分子难以获取明文信息进行盗用或篡改。\n身份验证强化：\n设置多因素身份验证机制，例如结合手机号、身份证号及动态验证码等，在票务使用环节严格核验使用者身份，确保是合法持票人，防止他人冒用盗用。\n票务状态实时监控：\n搭建系统实时追踪票务的状态变化，如是否已被使用、是否有异常修改记录等，一旦发现可疑操作，像同一票务短时间内多次验证等情况，立即触发警报并进行处置。\n权限管理严控：\n依据业务流程精细划分票务相关操作的权限，仅允许授权人员进行票务的售卖、改签、退票等操作，杜绝内部权限滥用导致的票务盗用风险。\n"
        },
        "test_case": {
          "name": "票务盗用",
          "details": "\n测试方法：\n1、正常登录账户后，新建一个票务订单信息后，将票务订单信息的URL复制保留后，使用浏览器无痕模式访问，查看是否能正常访问到票务订单信息。\n2、在理解票务订单业务流程后，通过Fiddler抓包工具截取数据流量包后，根据票务订单业务生成规则伪造一个新的票务业务订单信息，发送请求包后，查看响应包是否成功。\n预期结果：\n1、URL访问提示失败。\n2、抓包发送请求包后无法正常响应信息或提示访问失败。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "虚假信息提交",
        "details": "",
        "security_requirement": {
          "name": "虚假信息提交",
          "details": "确保系统能够有效防止虚假注册，保护系统资源和用户权益。"
        },
        "security_design": {
          "name": "虚假信息提交",
          "details": "身份验证强化：\n采用多因素认证方式，除常规的用户名密码外，增加手机验证码、人脸识别等环节，确保注册者身份真实可靠，减少虚假信息提交的可能，比如新用户注册时需通过短信验证码验证手机号归属。\n信息比对核查：\n与权威数据源（如身份证信息库、手机号实名库等）进行信息比对，对提交的关键注册信息进行校验，若发现不一致或异常情况则拒绝注册，保障进入系统的用户信息都是真实准确的。\n行为分析监测：\n分析注册过程中的行为模式，例如填写速度是否异常、IP 地址是否频繁变动等，对于存在可疑行为特征的注册尝试判定为虚假信息提交，及时拦截并提醒，以此维护系统资源以及其他合法用户的权益。"
        },
        "test_case": {
          "name": "虚假信息提交",
          "details": "测试方法：在应用程序中尝试创建新的账户，分别使用真实和虚假的注册信息进行测试。例如，输入虚假的姓名、邮箱、电话号码等信息。测试也可以包括尝试重复使用已经存在的用户名、邮箱等信息。\n预期结果：具备真实性和各数据之间匹配性验证，如果错误返回失败。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "其他官方接口调用": {
    "threats": [
      {
        "name": "接口滥用",
        "details": "",
        "security_requirement": {
          "name": "接口滥用",
          "details": "防止恶意用户或攻击者滥用系统提供的接口进行非法操作。\n加强对接口访问的身份验证和访问控制，确保只有合法用户可以访问接口。"
        },
        "security_design": {
          "name": "接口滥用",
          "details": "身份验证强化：\n采用多因素认证，定期更新凭据，防身份冒用。\n访问控制细化：\n用 RBAC 依角色分权限，ABAC 多属性判访问，精准控接口访问。\n访问频率限制：\n设接口访问次数上限，依角色等级差异设限，防高频滥用。\n接口调用审计：\n记接口调用日志，定期审查，查异常并处理。\n异常行为监测：\n建监测系统，关注异常迹象，用机器学习精准识异常，及时阻断。"
        },
        "test_case": {
          "name": "接口滥用",
          "details": "测试方法：登录账户后，通过Fiddler抓包工具访问应用系统的资源，将会话信息删除如cookie、token、jwt，再次请求查看是否正常响应。\n预期结果：报错或拒绝访问。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "签到打卡": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "签到记录与统计": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "权限管理": {
    "threats": [
      {
        "name": "角色权限蔓延",
        "details": "",
        "security_requirement": {
          "name": "角色权限蔓延",
          "details": "1. 完善的用户权限管理\n2. 禁止未授权访问"
        },
        "security_design": {
          "name": "角色权限蔓延",
          "details": "用户权限精准分配：\n根据用户的岗位职能与工作需求，精确设定其角色权限，避免权限过度授予。定期审查与更新用户权限，确保权限与实际业务要求始终匹配。\n权限变更审批流程：\n建立严格的权限变更审批机制，任何权限的增加、修改或删除都需经过相关部门或负责人的审批，并有详细记录可追溯，防止权限随意蔓延。\n访问控制强化：\n采用多层次的访问控制技术，如基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）等，对系统资源进行严格保护，确保只有经过授权的用户才能访问相应资源，有效禁止未授权访问行为。\n权限监控与审计：\n部署权限监控系统，实时跟踪用户权限的使用情况，对异常权限使用行为（如频繁访问未授权资源、权限使用时间异常等）及时预警。定期开展权限审计工作，检查是否存在权限蔓延迹象，发现问题及时整改。"
        },
        "test_case": {
          "name": "角色权限蔓延",
          "details": "测试方法：分别在不同的浏览器中登录两个账号，相互访问有差异性的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": null
      },
      {
        "name": "角色权限提升",
        "details": "",
        "security_requirement": {
          "name": "角色权限提升",
          "details": "防止未经授权的用户获取系统中的高级权限或访问权限。\n加强对权限提升漏洞的识别和修复，及时堵塞潜在的安全漏洞。"
        },
        "security_design": {
          "name": "角色权限提升",
          "details": "权限分级与隔离：\n对系统内的权限进行细致分级，明确划分普通权限、中级权限、高级权限等不同层级，将不同层级权限对应的功能与资源严格隔离，确保低级别权限用户无法轻易触及高级权限相关内容，从架构层面防止权限的随意提升。\n身份验证强化：\n采用多因素身份验证手段，如在关键操作或涉及权限提升场景下，除常规用户名和密码外，增加指纹识别、动态口令、手机验证码等额外认证因素，全方位核实用户身份，提高非法获取高权限的门槛，避免未经授权用户提升权限。\n权限提升漏洞管理：\n定期开展全面的系统安全检测，运用专业的漏洞扫描工具以及人工渗透测试等方式，深度排查可能导致权限提升的各类漏洞，如权限绕过漏洞、越权访问漏洞等，建立详细的漏洞台账，对发现的漏洞及时安排修复，确保系统的安全性。\n行为监测与预警：\n搭建权限使用行为监测系统，实时关注用户在系统内的操作行为，尤其针对涉及权限变更、权限提升相关操作进行重点监测，一旦发现异常行为，例如低权限用户频繁尝试访问高级权限资源、短时间内出现不符合常规逻辑的权限提升请求等情况，立即触发预警机制，及时通知安全运维人员进行处置，防止未经授权的权限提升行为得逞。"
        },
        "test_case": {
          "name": "角色权限提升",
          "details": "测试方法：使用普通用户访问管理员特有的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": null
      },
      {
        "name": "权限滥用",
        "details": "未按照最小授权原则进行授权，可能导致用户获得超出其实际需要的权限，从而滥用权限，进行非法操作或访问敏感数据，增加数据泄露的风险。",
        "security_requirement": {
          "name": "权限滥用",
          "details": "确保系统能够有效防止权限滥用行为，保护系统资源和用户数据的安全。"
        },
        "security_design": {
          "name": "权限滥用",
          "details": "权限细分管控：\n将系统权限依据功能模块、操作类型等进行精细划分，为不同角色、用户设定对应且精准的权限范围，避免权限宽泛易被滥用，确保各操作都有严格权限限制。\n操作审计机制：\n搭建完善的权限使用审计系统，实时记录权限操作详情，像操作时间、执行者、具体行为等，定期分析审计数据，及时发现频繁越权、异常操作等滥用行为。\n实时监控预警：\n设置监控规则，对权限使用频率、资源访问量等关键指标实时监测，一旦出现超出正常阈值的情况，如短时间内大量删除数据等，立即触发警报并阻断操作，防范权限滥用。\n权限回收调整：\n定期评估用户、角色的权限合理性，根据业务变动及权限使用情况，及时回收不必要权限，对存在滥用风险的权限进行调整，保障系统与数据安全。"
        },
        "test_case": {
          "name": "权限滥用",
          "details": "测试方法：用管理员账户登录应用系统后，进行一些敏感行为的操作，如删除数据库、重启系统服务、服务更新等敏感操作。\n预期结果：管理员账户仅能够访问自己授权内的功能。"
        },
        "industry_standard": null
      },
      {
        "name": "角色权限提升",
        "details": "",
        "security_requirement": {
          "name": "角色权限提升",
          "details": "防止未经授权的用户获取系统中的高级权限或访问权限。\n加强对权限提升漏洞的识别和修复，及时堵塞潜在的安全漏洞。"
        },
        "security_design": {
          "name": "角色权限提升",
          "details": "权限分级与隔离：\n对系统内的权限进行细致分级，明确划分普通权限、中级权限、高级权限等不同层级，将不同层级权限对应的功能与资源严格隔离，确保低级别权限用户无法轻易触及高级权限相关内容，从架构层面防止权限的随意提升。\n身份验证强化：\n采用多因素身份验证手段，如在关键操作或涉及权限提升场景下，除常规用户名和密码外，增加指纹识别、动态口令、手机验证码等额外认证因素，全方位核实用户身份，提高非法获取高权限的门槛，避免未经授权用户提升权限。\n权限提升漏洞管理：\n定期开展全面的系统安全检测，运用专业的漏洞扫描工具以及人工渗透测试等方式，深度排查可能导致权限提升的各类漏洞，如权限绕过漏洞、越权访问漏洞等，建立详细的漏洞台账，对发现的漏洞及时安排修复，确保系统的安全性。\n行为监测与预警：\n搭建权限使用行为监测系统，实时关注用户在系统内的操作行为，尤其针对涉及权限变更、权限提升相关操作进行重点监测，一旦发现异常行为，例如低权限用户频繁尝试访问高级权限资源、短时间内出现不符合常规逻辑的权限提升请求等情况，立即触发预警机制，及时通知安全运维人员进行处置，防止未经授权的权限提升行为得逞。"
        },
        "test_case": {
          "name": "角色权限提升",
          "details": "测试方法：使用普通用户访问管理员特有的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": null
      },
      {
        "name": "权限最小化",
        "details": "",
        "security_requirement": {
          "name": "权限最小化",
          "details": "1. 应用系统对用户/管理员、数据库连接等应采取最小权限原则\n2. 应用系统启动的相关进程、系统各组件不得使用特权账户"
        },
        "security_design": {
          "name": "权限最小化",
          "details": "权限梳理与分配：\n细致梳理应用系统各功能所需权限，无论是用户操作还是管理员管理，以及数据库连接场景，均按实际需求精准分配，杜绝多余权限赋予，严格践行最小权限原则。\n账户权限管控：\n针对应用系统启动的进程及各组件，禁用特权账户，改为设立专用的普通权限账户，仅赋予其完成对应任务必需的权限，防止因特权账户带来权限滥用、安全漏洞等风险。\n定期复核更新：\n定期重新审视权限分配情况，依据业务变化、功能增减等及时调整，持续确保各主体、各环节都维持在最小且合理的权限状态，保障系统安全稳定运行。\n权限使用审计：\n建立权限使用审计机制，详细记录权限调用情况，便于监测分析是否存在超出最小权限范围的异常操作，发现问题及时纠正，强化最小权限落实。"
        },
        "test_case": {
          "name": "权限最小化",
          "details": "测试方法：咨询发布人员，是否以非 root 用户发布 web 服务。\n预期结果：文件访问用户、服务启动的用户是普通账户，不是root或者administrator账户。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "权限码验证": {
    "threats": [
      {
        "name": "动态权限码泄露",
        "details": "",
        "security_requirement": {
          "name": "动态权限码泄露",
          "details": "确保动态权限码的安全性，防止被泄露给未经授权的第三方。\n及时识别和应对动态权限码泄露事件，降低安全风险。"
        },
        "security_design": {
          "name": "动态权限码泄露",
          "details": "数据加密存储：对订单中的敏感信息，如用户姓名、地址、联系方式、支付信息等，采用强加密算法进行加密存储，确保数据在数据库中以密文形式存在，防止数据泄露后被轻易解读。\n访问控制：严格限制对订单数据的访问权限，仅授权特定角色（如订单处理员、客服主管等）在必要业务场景下访问相关订单信息，并采用多因素身份验证确保访问者身份合法。\n网络传输加密：在订单数据于客户端与服务器端传输过程中，使用 SSL/TLS 等加密协议，保障数据在网络传输过程中的机密性与完整性，防止信息被窃取或篡改。\n数据脱敏展示：在非必要场景下，对订单信息进行脱敏处理后展示，如隐藏用户身份证号中间几位数字、电话号码部分数字等，降低信息泄露风险。"
        },
        "test_case": {
          "name": "动态权限码泄露",
          "details": "测试方法：短信验证码、OTP等验证码具有较短时间的有效性。\n预期结果：如1分钟内失效，或二次及之后重复使用则失效。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      }
    ]
  },
  "日志记录": {
    "threats": [
      {
        "name": "日志伪造",
        "details": "",
        "security_requirement": {
          "name": "日志伪造",
          "details": "确保系统日志的完整性和真实性，防止日志被篡改或伪造。"
        },
        "security_design": {
          "name": "日志伪造",
          "details": "存储加密：\n采用加密算法对系统日志加密后存储，比如使用 AES 算法，确保日志内容以密文形式存在，让不法分子难以篡改原始内容，保障完整性与真实性。\n数字签名：\n运用数字签名技术，为每条日志添加唯一签名，凭借公私钥机制验证日志来源及完整性，一旦日志被篡改，签名验证就会失败，及时发现异常。\n权限严控：\n设置严格的访问权限，仅授权特定人员可查看、操作日志，并且对操作行为全程记录，防止内部人员违规篡改伪造，杜绝外部非法访问。\n实时监测：\n搭建日志监测系统，实时比对日志数据的变动情况，一旦发现有不符合正常模式的修改痕迹或异常新增等情况，立即发出警报并溯源，防范日志伪造行为。"
        },
        "test_case": {
          "name": "日志伪造",
          "details": "测试方法：\n1、在有日志记录的输入处，额外插入日志格式的伪造条目（如：%0a%0aINFO:+User+logged+out%3dbadguy），再查看日志是否新增成功。\n2、检查写入日志的敏感信息是否已经脱敏。\n预期结果：\n1、日志无法修改和新增。\n2、日志中存在敏感信息处已脱敏。"
        },
        "industry_standard": null
      }
    ]
  },
  "上传": {
    "threats": [
      {
        "name": "文件解析漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n恶意代码检测：使用恶意代码检测工具或技术，对上传的文件进行扫描，及时发现和处理潜在的恶意代码。\n安全配置：确保系统和应用程序的文件解析配置安全，避免存在不安全的解析器或配置。"
        },
        "security_design": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：\n建立全面且严格的文件类型白名单机制，针对上传的文件，详细检查其文件头信息、扩展名等多方面特征，与白名单中的合法文件类型进行精确匹配，坚决拒绝任何不在白名单内的文件上传，有效防止恶意文件（如含有脚本代码的伪装文件）混入系统。\n恶意代码检测：\n集成先进的恶意代码检测工具，在文件上传环节或定期对系统内已存储的文件进行深度扫描，运用特征码匹配、行为分析等多种检测技术，及时精准地识别潜在的恶意代码片段，一旦发现，立即采取隔离、删除等处理措施，并记录相关信息以便追溯分析。\n安全配置：\n全面审查系统和应用程序的文件解析配置，禁用或更新存在安全隐患的解析器，如老旧版本的 XML 解析器等容易遭受攻击的组件；同时，对文件解析的相关参数进行安全设置，限制解析的深度、范围等，避免因不安全的配置导致文件解析漏洞被利用，确保整个文件解析过程在安全可控的环境下进行。"
        },
        "test_case": {
          "name": "文件解析漏洞",
          "details": "测试方法：合法上传文件过程中，使用 Fiddler 拦截上传数据包，修改为非法文件名（1.jsp、2.ASp、shell.PHP等执行脚本名称。），在取消拦截查看是否成功。\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      },
      {
        "name": "文件上传漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n文件大小限制：限制上传文件的大小，防止攻击者上传过大的文件导致服务器资源耗尽。\n安全权限设置：确保上传文件的存储目录具有适当的权限设置，防止恶意文件被执行或访问。"
        },
        "security_design": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：\n构建严谨的文件类型验证体系，采用多种验证方式相结合，例如不仅检查文件扩展名，还深入分析文件头特征信息，与预定义的安全文件类型白名单进行细致比对，严禁任何不在白名单中的文件类型上传，有效阻拦恶意脚本文件、可执行文件等非法文件进入系统。\n文件大小限制：\n在文件上传功能模块中，设定合理的文件大小上限值，此值应综合考虑服务器性能、业务需求以及安全风险等多方面因素。当用户上传文件时，系统自动检查文件大小，若超出限制则立即中断上传过程，并向用户反馈相应提示信息，防止攻击者通过上传超大文件耗尽服务器资源，如磁盘空间、内存等，保障服务器稳定运行。\n安全权限设置：\n针对上传文件的存储目录，精心规划并设置严格的权限策略。赋予该目录仅允许特定合法进程进行写入操作的权限，而禁止其他非授权进程或用户对上传文件进行读取、执行等操作，防止恶意上传的文件被意外执行或非法访问，降低因文件上传漏洞引发的安全风险，确保服务器文件系统的安全性与完整性。"
        },
        "test_case": {
          "name": "文件上传漏洞",
          "details": "测试方法：检查应用程序是否只接受特定扩展名（如.jpg、.pdf）和类型（如图像、文档）的文件上传。\n预期结果：应用程序应拒绝上传可疑或不符合规定的文件类型或扩展名。"
        },
        "industry_standard": null
      }
    ]
  },
  "社区数据安全传输": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "社区数据加密": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "身份验证与授权": {
    "threats": [
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      }
    ]
  },
  "审计日志记录": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "日志管理",
          "details": null
        }
      },
      {
        "name": "日志伪造",
        "details": "",
        "security_requirement": {
          "name": "日志伪造",
          "details": "确保系统日志的完整性和真实性，防止日志被篡改或伪造。"
        },
        "security_design": {
          "name": "日志伪造",
          "details": "存储加密：\n采用加密算法对系统日志加密后存储，比如使用 AES 算法，确保日志内容以密文形式存在，让不法分子难以篡改原始内容，保障完整性与真实性。\n数字签名：\n运用数字签名技术，为每条日志添加唯一签名，凭借公私钥机制验证日志来源及完整性，一旦日志被篡改，签名验证就会失败，及时发现异常。\n权限严控：\n设置严格的访问权限，仅授权特定人员可查看、操作日志，并且对操作行为全程记录，防止内部人员违规篡改伪造，杜绝外部非法访问。\n实时监测：\n搭建日志监测系统，实时比对日志数据的变动情况，一旦发现有不符合正常模式的修改痕迹或异常新增等情况，立即发出警报并溯源，防范日志伪造行为。"
        },
        "test_case": {
          "name": "日志伪造",
          "details": "测试方法：\n1、在有日志记录的输入处，额外插入日志格式的伪造条目（如：%0a%0aINFO:+User+logged+out%3dbadguy），再查看日志是否新增成功。\n2、检查写入日志的敏感信息是否已经脱敏。\n预期结果：\n1、日志无法修改和新增。\n2、日志中存在敏感信息处已脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "日志泄露",
        "details": "",
        "security_requirement": {
          "name": "日志泄露",
          "details": "确保系统能够防止日志泄露，保护系统日志的敏感信息不被未授权访问。"
        },
        "security_design": {
          "name": "日志泄露",
          "details": "存储加密保障：\n采用可靠的加密算法（如 AES 等）对系统日志加密存储，使得即便存储介质被非法获取，日志内容也难以被解读，保障敏感信息安全，防止因存储环节出问题而泄露。\n访问权限设置：\n依据角色和业务需求精细划分访问日志的权限，仅允许经过授权的特定人员查看、操作日志，比如运维人员、安全审计人员等，同时采用多因素认证加强把关，杜绝未授权访问。\n传输安全把控：\n在日志需要远程传输时，运用安全传输协议（如 HTTPS）进行加密打包传输，防止在网络传输过程中被窃取，确保日志从产生到传输的各环节保密性良好。\n监控预警机制：\n搭建日志访问监控系统，实时关注日志的访问情况，一旦出现异常访问行为，像频繁尝试突破权限等，及时发出警报并采取措施阻断访问，防范日志泄露风险。"
        },
        "test_case": {
          "name": "日志泄露",
          "details": "测试方法：通过直接拼接现有的域名，将下面的文件路径组合后访问，查看能否有数据内容显示。\n\t/.git/\n\t/.git/config\n\t/.DS_Store\n\t/WEB-INF/web.xml\n\t/WEB-INF/classes/\n\t/WEB-INF/lib/\n\t/WEB-INF/src/\n\t/WEB-INF/database.properties\n预期结果：访问这些敏感路径后提示拒绝访问或无任何数据内容。"
        },
        "industry_standard": {
          "name": "日志管理",
          "details": null
        }
      }
    ]
  },
  "审批流程的监控": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "系统管理",
          "details": null
        }
      },
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      },
      {
        "name": "日志泄露",
        "details": "",
        "security_requirement": {
          "name": "日志泄露",
          "details": "确保系统能够防止日志泄露，保护系统日志的敏感信息不被未授权访问。"
        },
        "security_design": {
          "name": "日志泄露",
          "details": "存储加密保障：\n采用可靠的加密算法（如 AES 等）对系统日志加密存储，使得即便存储介质被非法获取，日志内容也难以被解读，保障敏感信息安全，防止因存储环节出问题而泄露。\n访问权限设置：\n依据角色和业务需求精细划分访问日志的权限，仅允许经过授权的特定人员查看、操作日志，比如运维人员、安全审计人员等，同时采用多因素认证加强把关，杜绝未授权访问。\n传输安全把控：\n在日志需要远程传输时，运用安全传输协议（如 HTTPS）进行加密打包传输，防止在网络传输过程中被窃取，确保日志从产生到传输的各环节保密性良好。\n监控预警机制：\n搭建日志访问监控系统，实时关注日志的访问情况，一旦出现异常访问行为，像频繁尝试突破权限等，及时发出警报并采取措施阻断访问，防范日志泄露风险。"
        },
        "test_case": {
          "name": "日志泄露",
          "details": "测试方法：通过直接拼接现有的域名，将下面的文件路径组合后访问，查看能否有数据内容显示。\n\t/.git/\n\t/.git/config\n\t/.DS_Store\n\t/WEB-INF/web.xml\n\t/WEB-INF/classes/\n\t/WEB-INF/lib/\n\t/WEB-INF/src/\n\t/WEB-INF/database.properties\n预期结果：访问这些敏感路径后提示拒绝访问或无任何数据内容。"
        },
        "industry_standard": null
      }
    ]
  },
  "审批日志的记录": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "日志管理",
          "details": null
        }
      },
      {
        "name": "日志伪造",
        "details": "",
        "security_requirement": {
          "name": "日志伪造",
          "details": "确保系统日志的完整性和真实性，防止日志被篡改或伪造。"
        },
        "security_design": {
          "name": "日志伪造",
          "details": "存储加密：\n采用加密算法对系统日志加密后存储，比如使用 AES 算法，确保日志内容以密文形式存在，让不法分子难以篡改原始内容，保障完整性与真实性。\n数字签名：\n运用数字签名技术，为每条日志添加唯一签名，凭借公私钥机制验证日志来源及完整性，一旦日志被篡改，签名验证就会失败，及时发现异常。\n权限严控：\n设置严格的访问权限，仅授权特定人员可查看、操作日志，并且对操作行为全程记录，防止内部人员违规篡改伪造，杜绝外部非法访问。\n实时监测：\n搭建日志监测系统，实时比对日志数据的变动情况，一旦发现有不符合正常模式的修改痕迹或异常新增等情况，立即发出警报并溯源，防范日志伪造行为。"
        },
        "test_case": {
          "name": "日志伪造",
          "details": "测试方法：\n1、在有日志记录的输入处，额外插入日志格式的伪造条目（如：%0a%0aINFO:+User+logged+out%3dbadguy），再查看日志是否新增成功。\n2、检查写入日志的敏感信息是否已经脱敏。\n预期结果：\n1、日志无法修改和新增。\n2、日志中存在敏感信息处已脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "日志泄露",
        "details": "",
        "security_requirement": {
          "name": "日志泄露",
          "details": "确保系统能够防止日志泄露，保护系统日志的敏感信息不被未授权访问。"
        },
        "security_design": {
          "name": "日志泄露",
          "details": "存储加密保障：\n采用可靠的加密算法（如 AES 等）对系统日志加密存储，使得即便存储介质被非法获取，日志内容也难以被解读，保障敏感信息安全，防止因存储环节出问题而泄露。\n访问权限设置：\n依据角色和业务需求精细划分访问日志的权限，仅允许经过授权的特定人员查看、操作日志，比如运维人员、安全审计人员等，同时采用多因素认证加强把关，杜绝未授权访问。\n传输安全把控：\n在日志需要远程传输时，运用安全传输协议（如 HTTPS）进行加密打包传输，防止在网络传输过程中被窃取，确保日志从产生到传输的各环节保密性良好。\n监控预警机制：\n搭建日志访问监控系统，实时关注日志的访问情况，一旦出现异常访问行为，像频繁尝试突破权限等，及时发出警报并采取措施阻断访问，防范日志泄露风险。"
        },
        "test_case": {
          "name": "日志泄露",
          "details": "测试方法：通过直接拼接现有的域名，将下面的文件路径组合后访问，查看能否有数据内容显示。\n\t/.git/\n\t/.git/config\n\t/.DS_Store\n\t/WEB-INF/web.xml\n\t/WEB-INF/classes/\n\t/WEB-INF/lib/\n\t/WEB-INF/src/\n\t/WEB-INF/database.properties\n预期结果：访问这些敏感路径后提示拒绝访问或无任何数据内容。"
        },
        "industry_standard": null
      }
    ]
  },
  "生物特征认证（指纹、面部识别等）": {
    "threats": [
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      }
    ]
  },
  "实名校验接口": {
    "threats": [
      {
        "name": "密钥劫持",
        "details": "",
        "security_requirement": {
          "name": "密钥劫持",
          "details": "确保 API 密钥的安全性，防止被恶意获取或滥用。\n加强对 API 访问的身份验证和授权，确保只有合法用户能够访问受保护的 API。"
        },
        "security_design": {
          "name": "密钥劫持",
          "details": "API 密钥生成安全：\n采用高强度随机数生成算法创建 API 密钥，结合时间戳、特定字符等元素，确保密钥的复杂性与唯一性，降低被暴力破解或猜测的风险，为其安全性奠定基础。\n传输加密措施：\n在 API 密钥于客户端与服务器端传输时，强制运用 HTTPS 等安全协议进行加密传输，防止密钥在网络传输途中被窃取，保障传输过程的保密性与完整性。\n存储安全机制：\n服务器端存储 API 密钥时，利用数据库加密功能或专用的密钥管理系统进行加密存储，并设置严格的访问权限，仅允许特定的授权服务或模块访问，防止因存储介质被攻破而导致密钥泄露。\n身份验证与授权强化：\n建立多重身份验证机制，如结合 API 密钥与用户密码、短信验证码或生物识别信息等进行综合验证。同时，细化授权策略，根据用户角色、IP 地址范围等因素，精确控制对不同 API 资源的访问权限，确保只有合法且经过授权的用户能够访问相应的 API，有效防止 API 密钥被恶意获取或滥用。"
        },
        "test_case": {
          "name": "密钥劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有密钥验证的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "密钥泄露",
        "details": "如果密钥被硬编码在代码中，一旦代码泄露或被逆向工程，攻击者可能会获取到密钥，从而对系统造成威胁，同时也增加了维护的复杂性。如果本地配置文件没有受到足够的保护，可能存在被泄露和篡改的风险，其中的密钥也会被泄露及篡改，导致敏感数据泄露或被攻击。",
        "security_requirement": {
          "name": "密钥泄露",
          "details": "确保 API 密钥的安全性，防止泄露给未经授权的第三方。\n加强对 API 密钥的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "密钥泄露",
          "details": "密钥生成强化：\n采用强加密算法与随机因子生成 API 密钥，使其具备高度复杂性与不可预测性，降低被破解获取的概率，构建密钥安全的首道防线。\n传输加密保障：\n借助安全传输协议如 HTTPS 传输 API 密钥，对其加密打包，防止在网络链路中被窃取，确保传输阶段的保密性与完整性。\n存储安全管控：\n利用加密存储技术与严格访问权限设置，将 API 密钥存储于安全区域，无论是数据库存储还是本地存储，都防止因存储介质暴露而引发泄露。\n定期更新机制：\n设定 API 密钥定期更新周期，促使使用者定期更换密钥，减少长期使用同一密钥带来的泄露风险，降低潜在危害的持续性。\n异常监测响应：\n搭建密钥使用异常监测体系，实时追踪密钥使用的频率、来源等，一旦发现异常，如短时间内异地频繁使用，立即暂停密钥并通知相关方，及时应对泄露危机。"
        },
        "test_case": {
          "name": "密钥泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有密钥验证的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "接口参数遍历",
        "details": "",
        "security_requirement": {
          "name": "接口参数遍历",
          "details": "调用API前，对请求的参数进行有效性校验"
        },
        "security_design": {
          "name": "接口参数遍历",
          "details": "参数格式校验：\n明确规定每个接口参数的正确格式，如数字类型参数应符合特定的数值范围与精度要求，字符串参数要遵循相应的长度限制与字符规范等。在接收请求时，严格按照既定格式标准对参数进行逐一核对，拒绝格式不符的参数进入后续处理流程，防止因格式错误引发的遍历风险。\n参数类型验证：\n仔细甄别每个参数的数据类型，确保传入的参数类型与接口定义的类型一致，例如，接口要求传入布尔值的参数就不能接收整数或字符串类型。通过代码逻辑或专门的验证工具，对参数类型进行严格验证，避免因类型不匹配被恶意利用进行参数遍历攻击。\n取值范围核查：\n针对有取值范围限定的参数，详细梳理并设定其合理的上下限，像日期参数限定在某个有效时间段内，数量参数处于一定的数值区间等。在处理请求前，认真检查参数的实际取值是否落在规定范围内，杜绝超出范围的参数参与接口调用，以此减少因参数取值异常导致的遍历漏洞。\n必选与可选参数判定：\n清晰界定每个接口的必选参数和可选参数清单，对于必选参数，严格要求请求中必须包含且内容完整有效；对于可选参数，验证其出现的合理性以及是否符合相应的使用条件。通过这种精准判定，防止攻击者通过遗漏必选参数或滥用可选参数来尝试参数遍历行为。\n合法性逻辑校验：\n依据业务逻辑和接口功能需求，对参数之间的关联性与合法性进行综合校验。例如，某个操作的多个参数之间存在特定的运算关系或逻辑约束，要确保传入的参数组合满足这些逻辑要求。这样能从更深层次杜绝不符合正常业务逻辑的参数组合进入系统，有效抵御参数遍历攻击。\n异常处理与反馈机制：\n构建完善的参数校验异常处理流程，当发现参数存在无效情况时，及时返回恰当且模糊的错误提示信息给请求方，避免透露过多有助于攻击者进行进一步遍历尝试的细节。同时，记录参数校验异常的相关情况，便于后续分析和排查潜在的安全隐患。\n"
        },
        "test_case": {
          "name": "接口参数遍历",
          "details": "测试方法：\n 1、在用过参数 id （或其他类似参数）访问的地方，访问无权访问的 id 值；\n2、观察 id 值是否是 随机hash 值\n预期结果：\n1、未经授权的用户无法访问受保护的接口和数据。\n2、id 值应为 hash 随机值。"
        },
        "industry_standard": null
      },
      {
        "name": "接口滥用",
        "details": "",
        "security_requirement": {
          "name": "接口滥用",
          "details": "防止恶意用户或攻击者滥用系统提供的接口进行非法操作。\n加强对接口访问的身份验证和访问控制，确保只有合法用户可以访问接口。"
        },
        "security_design": {
          "name": "接口滥用",
          "details": "身份验证强化：\n采用多因素认证，定期更新凭据，防身份冒用。\n访问控制细化：\n用 RBAC 依角色分权限，ABAC 多属性判访问，精准控接口访问。\n访问频率限制：\n设接口访问次数上限，依角色等级差异设限，防高频滥用。\n接口调用审计：\n记接口调用日志，定期审查，查异常并处理。\n异常行为监测：\n建监测系统，关注异常迹象，用机器学习精准识异常，及时阻断。"
        },
        "test_case": {
          "name": "接口滥用",
          "details": "测试方法：登录账户后，通过Fiddler抓包工具访问应用系统的资源，将会话信息删除如cookie、token、jwt，再次请求查看是否正常响应。\n预期结果：报错或拒绝访问。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      },
      {
        "name": "接口注入",
        "details": "",
        "security_requirement": {
          "name": "接口注入",
          "details": "防止恶意用户或攻击者利用接口漏洞进行注入攻击。\n加强对接口输入数据的验证和过滤，防止恶意数据的注入。"
        },
        "security_design": {
          "name": "接口注入",
          "details": "输入数据格式验证：\n明确各接口所接收数据的正确格式，如规定字符串类型数据应符合特定的长度、字符范围要求，数字类型要满足相应的数值区间与精度限制等，严格按格式标准对输入数据进行校验，拒绝格式不符的数据进入，降低注入攻击风险。\n数据类型严格甄别：\n仔细核对接口输入数据的类型，确保传入的数据类型与接口定义的类型精准匹配，像要求是布尔型的数据就不能接收整型或字符串型等其他类型，防止因类型混淆被恶意利用来实施注入攻击。\n危险字符过滤：\n梳理出常见的可用于注入攻击的危险字符（如 SQL 注入中的单引号、双引号、分号等，命令注入中的 &、| 等），在接口接收输入数据时，运用正则表达式等技术手段，将这些危险字符进行过滤或转义处理，避免其混入正常数据中造成安全隐患。\n语义完整性校验：\n依据接口对应的业务逻辑，对输入数据之间的关联性及语义完整性进行检查，确保数据组合符合正常业务流程和操作要求，防止攻击者通过构造特殊语义的数据来绕过验证机制并发起注入攻击。\n输入长度限制：\n为接口接收的各类输入数据设定合理的长度限制，根据实际业务场景确定最长允许的字符数或字节数，避免攻击者通过输入超长数据来触发缓冲区溢出等漏洞，进而实施注入攻击，从长度方面把控数据安全性。\n验证机制持续优化：\n定期回顾和分析接口注入攻击的案例及趋势，不断改进和完善数据验证与过滤机制，及时更新危险字符列表、优化验证逻辑等，确保能应对不断变化的注入攻击手段，持续保障接口安全。"
        },
        "test_case": {
          "name": "接口注入",
          "details": "测试方法：在输入的功能处，输入一些特殊字符如、‘ “” \">\" cat /etc/passwd ?id=1;ls等，查看服务器是否正常响应。\n预期结果：无任何内容显示并提示输入非法。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "拒绝服务攻击",
        "details": "",
        "security_requirement": {
          "name": "拒绝服务攻击",
          "details": "确保系统能够有效防止拒绝服务攻击，保护系统的可用性和稳定性。"
        },
        "security_design": {
          "name": "拒绝服务攻击",
          "details": "输入验证强化：\n开发时对所有外部输入进行严格校验，包括数据格式、长度、类型等。例如对用户提交的表单数据、API 传入参数，通过正则表达式与数据类型检查确保其合法性，杜绝恶意构造的输入引发系统异常或资源耗尽，从而抵御攻击。\n并发控制策略：\n精心设计并发处理逻辑，利用线程池、信号量等技术限制同时处理的请求数量。依据系统硬件资源与正常业务负载，设定合理阈值，防止大量并发恶意请求使系统资源耗尽而瘫痪，保障服务稳定运行。\n资源监控与限制：\n在代码中嵌入资源监控模块，实时跟踪 CPU、内存、磁盘 I/O 等关键资源的使用情况。一旦资源使用接近危险阈值，自动限制非关键业务的资源分配，优先保障核心业务运行，避免因资源被恶意占用导致系统不可用。\n缓存机制优化：\n优化缓存策略，对频繁访问的数据进行合理缓存，设置缓存有效期与容量限制。既减少重复计算与数据库查询，提升系统响应速度，又防止缓存被恶意数据填满，影响正常业务数据缓存，保障系统高效稳定运行。\n异常处理完善：\n构建全面的异常处理体系，对于可能出现的各类异常情况，如网络中断、数据库连接失败、资源不足等，进行优雅处理。避免因未处理的异常导致系统崩溃或陷入无限循环，增强系统在面对异常与攻击时的韧性。\n代码模块化与隔离：\n将系统功能进行合理模块化，不同模块间设置清晰的边界与访问权限。当某个模块遭受攻击时，通过隔离机制限制影响范围，防止恶意攻击蔓延至整个系统，确保其他模块仍能正常提供服务，维持系统整体可用性。"
        },
        "test_case": {
          "name": "拒绝服务攻击",
          "details": "测试方法：功能测试压力测试"
        },
        "industry_standard": null
      },
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "使用正则表达式对输入进行匹配": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      }
    ]
  },
  "事件监控": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "安全审计",
          "details": null
        }
      },
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      }
    ]
  },
  "视频": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "输出编码": {
    "threats": [
      {
        "name": "输出编码绕过",
        "details": "",
        "security_requirement": {
          "name": "输出编码绕过",
          "details": "对输出的内容需要校验或检测，防止恶意内容被展示或被执行。"
        },
        "security_design": {
          "name": "输出编码绕过",
          "details": "格式校验机制：\n明确规定输出内容应符合的格式标准，例如文本输出限定字符类型、长度范围等，利用正则表达式等工具仔细检查，不符合格式的内容直接拦截，避免恶意构造内容混入展示。\n危险标签过滤：\n梳理如 HTML、JavaScript 等语言里能引发安全问题的危险标签、脚本代码，在输出时将其精准过滤，防止这些恶意内容被执行，保障展示环境安全。\n转义处理策略：\n针对特殊字符、代码片段等进行转义操作，改变其原本表意，使其输出后仅作为普通文本展示，无法被解析执行，有效堵住输出编码绕过漏洞。"
        },
        "test_case": {
          "name": "输出编码绕过",
          "details": "测试方法：\n1、检查应用程序交互并查看其输出，尤其是包含用户提供的数据的地方，如URL、表单字段、Cookie等，浏览目标应用程序，并找到可能存在输出编码绕过漏洞的地方，例如搜索框、评论框、用户个人资料页面等。\n2、开始输入一些特殊字符，如<script>、alert('XSS')、;ls、' OR '1'='1、$(ls)等去查看页面的显示是什么。\n预期结果：输入特殊字符后，页面正常响应或显示输入的信息非法。"
        },
        "industry_standard": null
      }
    ]
  },
  "反馈与投诉": {
    "threats": [
      {
        "name": "输出编码绕过",
        "details": "",
        "security_requirement": {
          "name": "输出编码绕过",
          "details": "对输出的内容需要校验或检测，防止恶意内容被展示或被执行。"
        },
        "security_design": {
          "name": "输出编码绕过",
          "details": "格式校验机制：\n明确规定输出内容应符合的格式标准，例如文本输出限定字符类型、长度范围等，利用正则表达式等工具仔细检查，不符合格式的内容直接拦截，避免恶意构造内容混入展示。\n危险标签过滤：\n梳理如 HTML、JavaScript 等语言里能引发安全问题的危险标签、脚本代码，在输出时将其精准过滤，防止这些恶意内容被执行，保障展示环境安全。\n转义处理策略：\n针对特殊字符、代码片段等进行转义操作，改变其原本表意，使其输出后仅作为普通文本展示，无法被解析执行，有效堵住输出编码绕过漏洞。"
        },
        "test_case": {
          "name": "输出编码绕过",
          "details": "测试方法：\n1、检查应用程序交互并查看其输出，尤其是包含用户提供的数据的地方，如URL、表单字段、Cookie等，浏览目标应用程序，并找到可能存在输出编码绕过漏洞的地方，例如搜索框、评论框、用户个人资料页面等。\n2、开始输入一些特殊字符，如<script>、alert('XSS')、;ls、' OR '1'='1、$(ls)等去查看页面的显示是什么。\n预期结果：输入特殊字符后，页面正常响应或显示输入的信息非法。"
        },
        "industry_standard": null
      },
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": {
          "name": "安全测试",
          "details": null
        }
      }
    ]
  },
  "输入验证与过滤": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据安全": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "数据缓存安全",
        "details": "",
        "security_requirement": {
          "name": "数据缓存安全",
          "details": "安全的缓存机制。"
        },
        "security_design": {
          "name": "数据缓存安全",
          "details": "缓存数据加密\n对缓存中的数据采用加密算法（如 AES）进行加密。在数据存入缓存时加密，读取时解密，确保缓存数据以密文形式存在，防止缓存数据泄露后被非法获取和利用。\n缓存访问控制\n设置严格的缓存访问权限，明确规定哪些用户或系统组件可以访问缓存。通过身份验证和授权机制，如基于角色的访问控制（RBAC），只有经过授权的用户才能读取或修改缓存数据。\n缓存更新策略\n建立安全的缓存更新策略，确保缓存数据与原始数据源的一致性和及时性。当数据源中的数据发生变化时，及时更新缓存，避免缓存数据过期导致的安全风险，如使用数据版本号或时间戳来判断数据是否需要更新。\n缓存清理机制\n定期清理缓存中不再需要的数据，防止缓存数据过度积累。对于包含敏感信息的缓存数据，在使用后及时清理，并且确保清理过程的完整性，避免残留数据造成安全隐患。"
        },
        "test_case": {
          "name": "数据缓存安全",
          "details": "测试方法：\n1、缓存过期时间：访问一次后，间隔长时间再次刷新，查看是否需要再次加载。\n2、访问控制：使用高权限登录过的浏览器或终端，更换低权限账号登录之后访问浏览记录中的历史敏感记录，查看是否能访问成功。\n预期结果：1、再次加载大量数据；2、无法访问。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "数据加解密",
        "details": "",
        "security_requirement": {
          "name": "数据加解密",
          "details": "使用安全的加密算法。"
        },
        "security_design": {
          "name": "数据加解密",
          "details": "对称加密算法选用\n可采用 AES（高级加密标准）算法，它运算速度快，密钥长度可选 128 位、192 位或 256 位，能高效加密大量数据。使用同一密钥进行加密和解密，只要妥善保管好密钥，就能保障数据在传输和存储时的保密性，常用于对文件、数据库等数据加密。\n非对称加密算法运用\n像 RSA 算法，有公钥和私钥之分，公钥可公开用于加密，私钥则保密用于解密。适用于密钥交换、数字签名等场景，能在不安全网络环境中安全传递信息，保证数据加解密的安全性，常辅助对称加密进行密钥管理等操作。\n哈希算法保障完整性\n例如 SHA-256 哈希算法，能将任意长度的数据转换为固定长度的哈希值。数据传输前后对比哈希值，若一致则说明数据未被篡改，虽不能还原数据本身，但可验证数据完整性，在保障数据安全方面起着重要作用。"
        },
        "test_case": {
          "name": "数据加解密",
          "details": "测试方法：咨询开发使用的加解密算法。\n预期结果：使用了安全的算法。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "信息滥用",
        "details": "",
        "security_requirement": {
          "name": "信息滥用",
          "details": "信息访问权限最小化，防止信息泄露。"
        },
        "security_design": {
          "name": "信息滥用",
          "details": "信息权限管理：\n采用 RBAC 模型，依角色分配信息访问权限，遵循最小化原则，如客服仅能看客户基本信息，限制访问敏感数据，降低信息滥用风险。\n信息使用审计：\n构建审计机制，记录用户信息访问详情，定期审查日志，发现异常访问模式，如频繁访问无关信息，以便及时查处。\n数据脱敏与加密：\n敏感信息存储与传输时脱敏，模糊或替换身份证号等敏感字段，且加密重要信息，仅授权用户用解密密钥可访问，增加信息滥用难度。"
        },
        "test_case": {
          "name": "信息滥用",
          "details": "测试方法：查看应用程序的输出和日志，确认敏感数据（如身份证号码、银行卡号等）在显示时进行了脱敏处理（例如，只显示部分数据或替换为星号）。\n预期结果：敏感数据在显示和存储时脱敏处理得当。"
        },
        "industry_standard": null
      },
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据备份与恢复": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据存储": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "数据的展示": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据访问控制": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "数据分析": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "数据分析与反馈": {
    "threats": [
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据管理": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "数据解析": {
    "threats": [
      {
        "name": "JSON注入",
        "details": "",
        "security_requirement": {
          "name": "JSON注入",
          "details": "确保从客户端接收到的JSON数据不包含恶意代码或特殊字符，以防止JSON注入攻击。\n加强对JSON数据的验证和过滤，确保只接受合法和预期的JSON格式数据，防止恶意用户利用JSON注入漏洞进行攻击。"
        },
        "security_design": {
          "name": "JSON注入",
          "details": "JSON 数据接收验证：\n在服务器端接收 JSON 数据的入口点，对数据的格式进行严格验证，确保其符合标准 JSON 语法结构，拒绝格式错误的数据，防止攻击者通过构造畸形 JSON 数据进行注入攻击。\n特殊字符过滤：\n针对 JSON 数据中的特殊字符，如引号、尖括号、反斜杠等，进行全面过滤或转义处理，防止这些字符被恶意利用来改变数据语义或执行恶意脚本。\n数据类型检查：\n对 JSON 数据中的各个字段进行数据类型检查，确保接收到的数据类型与预期一致，例如数值型字段不能接收字符串型的恶意输入，避免因数据类型不一致引发的安全问题。\n深度 JSON 数据解析安全：\n在对复杂嵌套的 JSON 数据进行解析时，采用安全的解析库和算法，避免解析过程中出现代码执行漏洞或内存溢出等问题，确保解析过程的安全性和稳定性。\n监控与审计机制：\n建立 JSON 数据交互的监控系统，记录所有 JSON 数据的接收和处理情况，包括数据来源、内容和处理结果等。\n定期进行审计，分析 JSON 数据交互日志，及时发现异常的 JSON 数据流量或潜在的注入攻击迹象，以便及时采取措施进行防范和修复。\n"
        },
        "test_case": {
          "name": "JSON注入",
          "details": "测试方法：在 JSON 格式传递数据的参数对象中插入特殊字符（如：@$%&*<>';/）或构造 SQL 语句。\n预期结果：返回失败或报错（报错但不抛出过多错误信息，重定向定制错误页面）"
        },
        "industry_standard": null
      }
    ]
  },
  "数据库安全配置（针对新上线）": {
    "threats": [
      {
        "name": "数据库连接地址泄露",
        "details": "",
        "security_requirement": {
          "name": "数据库连接地址泄露",
          "details": "敏感信息保护：确保数据库连接地址等敏感信息不被泄露给未经授权的用户或系统。\n访问控制：实施有效的访问控制策略，限制对数据库连接地址的访问权限，防止未经授权的访问。\n日志审计：建立日志审计机制，记录对数据库连接地址的访问情况，及时发现并应对异常行为。"
        },
        "security_design": {
          "name": "数据库连接地址泄露",
          "details": "敏感信息保护\n对数据库连接地址采用加密存储，比如运用 AES 等加密算法处理，仅特定的运维或授权人员掌握解密密钥，确保即便存储介质被获取，信息也不会轻易泄露，同时在配置文件等中避免明文显示该地址。\n访问控制\n运用基于角色的访问控制（RBAC）机制，依据岗位职能精准分配权限，只有数据库管理员、相关开发及运维核心人员可访问连接地址，且通过多因素认证增强准入门槛，严格限制非授权访问。\n日志审计\n详细记录访问数据库连接地址的时间、来源 IP、操作账号等信息，借助数据分析工具定期审计日志，一旦发现异常频繁访问、陌生 IP 尝试访问等情况，迅速告警并溯源，采取措施防范地址泄露风险。"
        },
        "test_case": {
          "name": "数据库连接地址泄露",
          "details": "测试方法：查看 web 程序中代码或数据库配置文件，查看地址、账号密码等相关字段，是否铭文写入了配置文件中。\n预期结果：代码或配置文件中未包含明文的数据库连接地址或凭据。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据库缓存": {
    "threats": [
      {
        "name": "数据缓存安全",
        "details": "",
        "security_requirement": {
          "name": "数据缓存安全",
          "details": "安全的缓存机制。"
        },
        "security_design": {
          "name": "数据缓存安全",
          "details": "缓存数据加密\n对缓存中的数据采用加密算法（如 AES）进行加密。在数据存入缓存时加密，读取时解密，确保缓存数据以密文形式存在，防止缓存数据泄露后被非法获取和利用。\n缓存访问控制\n设置严格的缓存访问权限，明确规定哪些用户或系统组件可以访问缓存。通过身份验证和授权机制，如基于角色的访问控制（RBAC），只有经过授权的用户才能读取或修改缓存数据。\n缓存更新策略\n建立安全的缓存更新策略，确保缓存数据与原始数据源的一致性和及时性。当数据源中的数据发生变化时，及时更新缓存，避免缓存数据过期导致的安全风险，如使用数据版本号或时间戳来判断数据是否需要更新。\n缓存清理机制\n定期清理缓存中不再需要的数据，防止缓存数据过度积累。对于包含敏感信息的缓存数据，在使用后及时清理，并且确保清理过程的完整性，避免残留数据造成安全隐患。"
        },
        "test_case": {
          "name": "数据缓存安全",
          "details": "测试方法：\n1、缓存过期时间：访问一次后，间隔长时间再次刷新，查看是否需要再次加载。\n2、访问控制：使用高权限登录过的浏览器或终端，更换低权限账号登录之后访问浏览记录中的历史敏感记录，查看是否能访问成功。\n预期结果：1、再次加载大量数据；2、无法访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "数据签名": {
    "threats": [
      {
        "name": "签名算法漏洞",
        "details": "",
        "security_requirement": {
          "name": "签名算法漏洞",
          "details": "使用安全且经过充分测试的签名算法。\n对签名算法的实现进行审查和测试，确保其安全性和正确性。"
        },
        "security_design": {
          "name": "签名算法漏洞",
          "details": "算法选型把关：\n优先选用成熟、广泛认可且安全评级高的签名算法，比如 RSA、ECDSA 等，避免使用存在已知漏洞或未经验证的小众算法，从根源保障安全性。\n代码审查落实：\n组织专业人员仔细审查签名算法实现的代码逻辑，查看是否遵循标准规范，有无可能被利用的逻辑错误或安全缺陷，及时修正发现的问题。\n测试全面开展：\n通过多种测试手段，如单元测试、集成测试、模拟攻击测试等，检验签名算法在不同场景下的运行情况，验证其生成的签名是否准确、能否抵御常见攻击，确保其正确性与安全性。\n版本更新跟踪：\n持续关注签名算法领域的发展动态，及时更新到更安全的版本，对于已发现漏洞的旧版本，尽快完成替换，保持算法的高安全性状态。"
        },
        "test_case": {
          "name": "签名算法漏洞",
          "details": "测试方法：扫描工具或专有工具（JWT爆破工具：https://github.com/Devllench/jwtbrute）。\n预期结果：通过漏扫工具扫描后未发现签名算法相关漏洞，JWT密钥未爆破成功。"
        },
        "industry_standard": {
          "name": "数安第四章第二十七条第一款1",
          "details": null
        }
      },
      {
        "name": "数据加解密",
        "details": "",
        "security_requirement": {
          "name": "数据加解密",
          "details": "使用安全的加密算法。"
        },
        "security_design": {
          "name": "数据加解密",
          "details": "对称加密算法选用\n可采用 AES（高级加密标准）算法，它运算速度快，密钥长度可选 128 位、192 位或 256 位，能高效加密大量数据。使用同一密钥进行加密和解密，只要妥善保管好密钥，就能保障数据在传输和存储时的保密性，常用于对文件、数据库等数据加密。\n非对称加密算法运用\n像 RSA 算法，有公钥和私钥之分，公钥可公开用于加密，私钥则保密用于解密。适用于密钥交换、数字签名等场景，能在不安全网络环境中安全传递信息，保证数据加解密的安全性，常辅助对称加密进行密钥管理等操作。\n哈希算法保障完整性\n例如 SHA-256 哈希算法，能将任意长度的数据转换为固定长度的哈希值。数据传输前后对比哈希值，若一致则说明数据未被篡改，虽不能还原数据本身，但可验证数据完整性，在保障数据安全方面起着重要作用。"
        },
        "test_case": {
          "name": "数据加解密",
          "details": "测试方法：咨询开发使用的加解密算法。\n预期结果：使用了安全的算法。"
        },
        "industry_standard": null
      }
    ]
  },
  "双重提交Cookie": {
    "threats": [
      {
        "name": "跨站请求伪造｜CSRF",
        "details": "",
        "security_requirement": {
          "name": "跨站请求伪造｜CSRF",
          "details": "1. 对重要api操作进行会话校验\n2. 防止恶意表单、数据的提交\n3. 在执行关键操作时增加验证判断"
        },
        "security_design": {
          "name": "跨站请求伪造｜CSRF",
          "details": "会话校验强化：\n在开发涉及重要 API 操作的功能时，务必在服务器端对会话进行严格校验。每次 API 请求到达时，检查会话的合法性、有效性以及与当前用户的关联性，确保只有通过合法会话发起的请求才被允许处理，防止攻击者冒用他人会话进行跨站请求伪造攻击。\n表单提交防护：\n对于系统中的表单，无论是用户注册、登录还是其他数据提交表单，都要添加防伪造令牌（CSRF Token）机制。在表单生成时，为每个表单生成唯一且不可预测的令牌，并将其嵌入表单隐藏字段中。当表单提交时，服务器端验证该令牌是否与当前用户会话对应的令牌一致，若不一致则拒绝提交，有效阻止恶意表单提交。\n关键操作验证：\n在执行如修改密码、资金转账、重要数据修改等关键操作的代码逻辑中，增加多因素验证判断。除了常规的会话校验外，还可结合用户的其他身份特征进行验证，如短信验证码、指纹识别（若支持）等，进一步提高关键操作的安全性，降低因 CSRF 攻击导致的风险。\n数据来源验证：\n在处理任何请求数据时，尤其是来自外部的请求，开发代码对数据来源进行验证。检查请求的 Referer 字段（虽然该字段可被伪造但仍有一定参考性）以及请求的 IP 地址等信息，判断请求是否来自合法的源，若发现数据来源可疑则拒绝处理，减少恶意数据提交成功的可能性。\n页面链接保护：\n对于系统内的重要页面链接，特别是那些涉及敏感操作或数据的链接，在生成链接时添加额外的验证参数或加密信息。当用户点击链接时，服务器端对链接中的验证信息进行解密和验证，只有验证通过的链接才允许访问相应页面并执行后续操作，防止攻击者构造恶意链接诱导用户点击从而发起 CSRF 攻击。"
        },
        "test_case": {
          "name": "跨站请求伪造｜CSRF",
          "details": "测试方法：\n1、在重要业务功能处使用 Fiddler 抓包，查看数据包的 POST Data段是否包含一个随机 token 字符串（或csrftoken等类似的参数）。可以找开发确认\n2、抓包修改 referer 中的 url 地址，再次发包，查看是否发送成功。（如不存在 1 中的随机*token 字符串）\n3、在重要业务功能处是否有二次验证；（如不存在 1和2中的防御措施）\n预期结果： \n1、包含此随机 token，用来防止 CSRF 攻击。\n2、发送失败或报错，但报错信息不包含过多错误敏感信息\n3、在重要业务功能处应该有二次验证"
        },
        "industry_standard": {
          "name": "会话管理",
          "details": null
        }
      }
    ]
  },
  "私有仓库": {
    "threats": [
      {
        "name": "代码信息泄露",
        "details": "",
        "security_requirement": {
          "name": "代码信息泄露",
          "details": "防止敏感代码信息泄露，包括源代码、配置文件、注释等，以避免攻击者获取系统架构和逻辑信息，从而进行更精确的攻击。"
        },
        "security_design": {
          "name": "代码信息泄露",
          "details": "代码混淆：\n对源代码进行混淆处理，通过重命名变量、函数等标识符，打乱代码逻辑结构，让攻击者难以直接读懂代码内容，增加逆向分析获取有效信息的难度，保护代码逻辑不被轻易窥探。\n访问权限控制：\n严格限制对源代码、配置文件存储位置的访问权限，依据职责和工作需求，仅允许相关的开发、运维等授权人员进行查看、修改，禁止非授权访问，防止内部人员误操作或外部攻击者直接获取敏感代码信息。\n生产环境清理：\n在将代码部署到生产环境前，仔细去除不必要的调试信息、注释内容以及测试相关代码，确保生产环境中留存的都是与实际运行相关且不包含敏感信息的代码，减少可被攻击者利用的信息暴露。\n加密存储：\n对于包含敏感信息的配置文件，采用加密的方式进行存储，只有在运行时通过安全的解密机制、凭借正确的密钥才能获取并使用其中的内容，防止配置信息被窃取查看。\n网络隔离：\n划分不同的网络区域，将开发环境、测试环境与生产环境进行有效隔离，限制不同区域间随意的数据传输，避免因网络安全漏洞导致代码信息从相对安全的区域泄露到外部，增加整体防护层级。\n版本管理安全：\n在使用代码版本管理工具（如 Git 等）时，合理配置访问权限，设置强密码和多因素认证，对重要的代码仓库设置为私有，同时定期审查版本管理系统中的操作记录，防止代码被非法下载或查看。"
        },
        "test_case": {
          "name": "代码信息泄露",
          "details": "测试方法：查看源码中是否存在Git存储库地址、账户、数据库凭据、API密钥等信息。\n预期结果：不存在。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      },
      {
        "name": "文件读取漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件读取漏洞",
          "details": "访问控制：实施严格的文件访问控制策略，确保只有授权用户可以访问特定的文件。\n文件路径验证：对用户提供的文件路径进行验证和过滤，防止恶意构造的路径导致文件读取漏洞。\n最小权限原则：为应用程序分配最小权限，限制其对文件系统的访问，减少潜在的漏洞风险。"
        },
        "security_design": {
          "name": "文件读取漏洞",
          "details": "访问控制：\n依据用户角色、业务需求等因素，制定精细的文件访问控制策略，明确不同用户、不同业务模块所能访问的具体文件范围，严格限制非授权用户对任何敏感或关键文件的访问，例如，财务文件仅允许财务部门相关授权人员读取操作。\n文件路径验证：\n在接收用户输入的文件路径时，运用严格的正则表达式等验证手段，对路径进行合法性检查，过滤掉包含特殊字符、非法目录跳转符号（如 “../” 等可能导致目录穿越的符号）的恶意构造路径，保证文件路径指向符合安全预期的范围，杜绝因路径被恶意操控而引发的文件读取漏洞。\n最小权限原则：\n遵循最小权限分配理念，精准评估应用程序实际运行所需的文件系统访问权限，只为其赋予必要的最低限度权限，比如只允许读取特定目录下的配置文件，禁止对其他无关目录及文件进行写、删除等操作，以此最大程度降低因权限过大而产生文件读取方面潜在漏洞的风险。"
        },
        "test_case": {
          "name": "文件读取漏洞",
          "details": "测试方法：对带有路径的文件访问 URL，使用Fiddler抓包截取流量，然后拼接文件路径。例如\"../etc/passwd\"、\"../../../etc/passwd“\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "随机令牌（CSRF Token）": {
    "threats": [
      {
        "name": "跨站请求伪造｜CSRF",
        "details": "",
        "security_requirement": {
          "name": "跨站请求伪造｜CSRF",
          "details": "1. 对重要api操作进行会话校验\n2. 防止恶意表单、数据的提交\n3. 在执行关键操作时增加验证判断"
        },
        "security_design": {
          "name": "跨站请求伪造｜CSRF",
          "details": "会话校验强化：\n在开发涉及重要 API 操作的功能时，务必在服务器端对会话进行严格校验。每次 API 请求到达时，检查会话的合法性、有效性以及与当前用户的关联性，确保只有通过合法会话发起的请求才被允许处理，防止攻击者冒用他人会话进行跨站请求伪造攻击。\n表单提交防护：\n对于系统中的表单，无论是用户注册、登录还是其他数据提交表单，都要添加防伪造令牌（CSRF Token）机制。在表单生成时，为每个表单生成唯一且不可预测的令牌，并将其嵌入表单隐藏字段中。当表单提交时，服务器端验证该令牌是否与当前用户会话对应的令牌一致，若不一致则拒绝提交，有效阻止恶意表单提交。\n关键操作验证：\n在执行如修改密码、资金转账、重要数据修改等关键操作的代码逻辑中，增加多因素验证判断。除了常规的会话校验外，还可结合用户的其他身份特征进行验证，如短信验证码、指纹识别（若支持）等，进一步提高关键操作的安全性，降低因 CSRF 攻击导致的风险。\n数据来源验证：\n在处理任何请求数据时，尤其是来自外部的请求，开发代码对数据来源进行验证。检查请求的 Referer 字段（虽然该字段可被伪造但仍有一定参考性）以及请求的 IP 地址等信息，判断请求是否来自合法的源，若发现数据来源可疑则拒绝处理，减少恶意数据提交成功的可能性。\n页面链接保护：\n对于系统内的重要页面链接，特别是那些涉及敏感操作或数据的链接，在生成链接时添加额外的验证参数或加密信息。当用户点击链接时，服务器端对链接中的验证信息进行解密和验证，只有验证通过的链接才允许访问相应页面并执行后续操作，防止攻击者构造恶意链接诱导用户点击从而发起 CSRF 攻击。"
        },
        "test_case": {
          "name": "跨站请求伪造｜CSRF",
          "details": "测试方法：\n1、在重要业务功能处使用 Fiddler 抓包，查看数据包的 POST Data段是否包含一个随机 token 字符串（或csrftoken等类似的参数）。可以找开发确认\n2、抓包修改 referer 中的 url 地址，再次发包，查看是否发送成功。（如不存在 1 中的随机*token 字符串）\n3、在重要业务功能处是否有二次验证；（如不存在 1和2中的防御措施）\n预期结果： \n1、包含此随机 token，用来防止 CSRF 攻击。\n2、发送失败或报错，但报错信息不包含过多错误敏感信息\n3、在重要业务功能处应该有二次验证"
        },
        "industry_standard": null
      }
    ]
  },
  "通讯录信息": {
    "threats": [
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      },
      {
        "name": "跨站请求伪造｜CSRF",
        "details": "",
        "security_requirement": {
          "name": "跨站请求伪造｜CSRF",
          "details": "1. 对重要api操作进行会话校验\n2. 防止恶意表单、数据的提交\n3. 在执行关键操作时增加验证判断"
        },
        "security_design": {
          "name": "跨站请求伪造｜CSRF",
          "details": "会话校验强化：\n在开发涉及重要 API 操作的功能时，务必在服务器端对会话进行严格校验。每次 API 请求到达时，检查会话的合法性、有效性以及与当前用户的关联性，确保只有通过合法会话发起的请求才被允许处理，防止攻击者冒用他人会话进行跨站请求伪造攻击。\n表单提交防护：\n对于系统中的表单，无论是用户注册、登录还是其他数据提交表单，都要添加防伪造令牌（CSRF Token）机制。在表单生成时，为每个表单生成唯一且不可预测的令牌，并将其嵌入表单隐藏字段中。当表单提交时，服务器端验证该令牌是否与当前用户会话对应的令牌一致，若不一致则拒绝提交，有效阻止恶意表单提交。\n关键操作验证：\n在执行如修改密码、资金转账、重要数据修改等关键操作的代码逻辑中，增加多因素验证判断。除了常规的会话校验外，还可结合用户的其他身份特征进行验证，如短信验证码、指纹识别（若支持）等，进一步提高关键操作的安全性，降低因 CSRF 攻击导致的风险。\n数据来源验证：\n在处理任何请求数据时，尤其是来自外部的请求，开发代码对数据来源进行验证。检查请求的 Referer 字段（虽然该字段可被伪造但仍有一定参考性）以及请求的 IP 地址等信息，判断请求是否来自合法的源，若发现数据来源可疑则拒绝处理，减少恶意数据提交成功的可能性。\n页面链接保护：\n对于系统内的重要页面链接，特别是那些涉及敏感操作或数据的链接，在生成链接时添加额外的验证参数或加密信息。当用户点击链接时，服务器端对链接中的验证信息进行解密和验证，只有验证通过的链接才允许访问相应页面并执行后续操作，防止攻击者构造恶意链接诱导用户点击从而发起 CSRF 攻击。"
        },
        "test_case": {
          "name": "跨站请求伪造｜CSRF",
          "details": "测试方法：\n1、在重要业务功能处使用 Fiddler 抓包，查看数据包的 POST Data段是否包含一个随机 token 字符串（或csrftoken等类似的参数）。可以找开发确认\n2、抓包修改 referer 中的 url 地址，再次发包，查看是否发送成功。（如不存在 1 中的随机*token 字符串）\n3、在重要业务功能处是否有二次验证；（如不存在 1和2中的防御措施）\n预期结果： \n1、包含此随机 token，用来防止 CSRF 攻击。\n2、发送失败或报错，但报错信息不包含过多错误敏感信息\n3、在重要业务功能处应该有二次验证"
        },
        "industry_standard": null
      },
      {
        "name": "跨站脚本攻击｜XSS",
        "details": "",
        "security_requirement": {
          "name": "跨站脚本攻击｜XSS",
          "details": "1. 对用户的输入信息进行过滤或者转义\n2. 确保前端显示的文本内容不可被浏览器解析"
        },
        "security_design": {
          "name": "跨站脚本攻击｜XSS",
          "details": "输入信息过滤机制：\n在开发中，针对用户输入的各类信息（比如表单填写内容、评论框输入等），运用正则表达式等技术手段，仔细甄别并过滤掉常见的用于跨站脚本攻击的危险字符，像 “<”“>”“script” 等标签及相关脚本关键字。通过严格的过滤逻辑，防止恶意输入进入系统后端，从源头阻断攻击可能。\n输入转义处理：\n对于无法过滤掉的特殊字符，编写代码将其进行转义处理，使其失去原本在浏览器中可被解析成脚本的能力。例如，把 “<” 转义为 “<”，“>” 转义为 “>”，确保即便有恶意输入混入，在前端展示时也不会被浏览器当作脚本代码来执行，保障页面安全。\n前端渲染控制：\n在前端代码编写时，采用安全的渲染方式，对于从后端获取的文本内容，明确设置为纯文本渲染模式，禁用浏览器默认的 HTML 解析功能，避免文本内容里隐藏的恶意脚本被浏览器误解析，让显示的内容只以文本形式呈现，杜绝 XSS 攻击隐患。\n内容输出验证：\n在将数据输出到前端页面进行展示前，再次对内容进行验证，检查是否存在被转义后又还原或者新混入的可导致浏览器解析的脚本元素，通过多重验证，确保最终展示给用户的文本内容始终处于不可被浏览器解析的安全状态，全方位保护系统免受 XSS 攻击。\n"
        },
        "test_case": {
          "name": "跨站脚本攻击｜XSS",
          "details": "测试方法：在输出的功能处输入恶意的JavaScript代码或HTML元素如alert()、<script></script>、\"></script>。\n预期结果：返回报错，或转义后返回前端，或原封不动文本形式返回前端。"
        },
        "industry_standard": null
      },
      {
        "name": "文件上传漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n文件大小限制：限制上传文件的大小，防止攻击者上传过大的文件导致服务器资源耗尽。\n安全权限设置：确保上传文件的存储目录具有适当的权限设置，防止恶意文件被执行或访问。"
        },
        "security_design": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：\n构建严谨的文件类型验证体系，采用多种验证方式相结合，例如不仅检查文件扩展名，还深入分析文件头特征信息，与预定义的安全文件类型白名单进行细致比对，严禁任何不在白名单中的文件类型上传，有效阻拦恶意脚本文件、可执行文件等非法文件进入系统。\n文件大小限制：\n在文件上传功能模块中，设定合理的文件大小上限值，此值应综合考虑服务器性能、业务需求以及安全风险等多方面因素。当用户上传文件时，系统自动检查文件大小，若超出限制则立即中断上传过程，并向用户反馈相应提示信息，防止攻击者通过上传超大文件耗尽服务器资源，如磁盘空间、内存等，保障服务器稳定运行。\n安全权限设置：\n针对上传文件的存储目录，精心规划并设置严格的权限策略。赋予该目录仅允许特定合法进程进行写入操作的权限，而禁止其他非授权进程或用户对上传文件进行读取、执行等操作，防止恶意上传的文件被意外执行或非法访问，降低因文件上传漏洞引发的安全风险，确保服务器文件系统的安全性与完整性。"
        },
        "test_case": {
          "name": "文件上传漏洞",
          "details": "测试方法：检查应用程序是否只接受特定扩展名（如.jpg、.pdf）和类型（如图像、文档）的文件上传。\n预期结果：应用程序应拒绝上传可疑或不符合规定的文件类型或扩展名。"
        },
        "industry_standard": null
      },
      {
        "name": "文件下载漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件下载漏洞",
          "details": "访问控制：确保只有授权用户可以访问特定的文件，并且对敏感文件进行适当的权限控制。\n文件路径验证：对用户提供的文件路径进行验证和过滤，防止恶意构造的路径导致文件下载漏洞。\n安全配置：确保系统和应用程序的文件下载配置安全，避免存在不安全的下载接口或配置。"
        },
        "security_design": {
          "name": "文件下载漏洞",
          "details": "访问控制：\n依据不同用户的角色、职责以及业务需求，细致规划访问控制规则，明确规定哪些用户能够访问哪些特定文件，针对包含重要信息的敏感文件，比如机密文档、用户隐私数据文件等，设置更为严格的权限级别，仅开放给有高度相关业务需要的授权人员，通过这种精准的权限把控，防止未授权的下载行为发生。\n文件路径验证：\n在处理用户发起的文件下载请求时，对所提供的文件路径运用严格的验证机制，例如借助正则表达式等技术手段，过滤掉那些包含可能导致目录穿越的特殊字符（像 “../” 这类可跳出当前目录层级去访问其他非预期目录文件的符号）以及不符合系统逻辑的非法路径构造，确保用户只能从合法、预期的路径下载文件，杜绝因恶意路径构造而引发的文件下载漏洞。\n安全配置：\n全面排查系统和应用程序中涉及文件下载的接口及相关配置情况，及时关闭或更新那些存在安全隐患的下载接口，例如缺乏身份验证机制或对下载请求验证不充分的接口；同时，对文件下载相关的配置参数进行严谨审核与优化，比如限制下载的并发数、控制下载的速率等，避免因不安全的配置使得文件下载功能被恶意利用，保障整个文件下载过程处于安全可靠的状态。\n"
        },
        "test_case": {
          "name": "文件下载漏洞",
          "details": "测试方法：修改下载链接中的 id 或遍历文件名或目录，查看能否下载预期之外的文件。\n预期结果：受限制或报错。"
        },
        "industry_standard": null
      },
      {
        "name": "敏感信息泄露",
        "details": "",
        "security_requirement": {
          "name": "敏感信息泄露",
          "details": "确保系统能够有效保护敏感信息，防止敏感信息泄露。"
        },
        "security_design": {
          "name": "敏感信息泄露",
          "details": "信息加密处理：\n运用强加密算法对敏感信息加密，如对称加密的 AES、非对称加密的 RSA 等，存储与传输时均保持加密状态，让攻击者难以获取明文内容，保障信息安全。\n访问严格管控：\n按角色、业务需求划分访问权限，实施多因素认证，像密码加指纹识别等，仅授权人员可接触敏感信息，杜绝越权访问引发泄露。\n监控预警机制：\n搭建监控系统，实时监测信息访问、传输情况，一旦有异常操作，如高频访问、异地访问等，及时发出警报并阻断，快速应对泄露隐患。"
        },
        "test_case": {
          "name": "敏感信息泄露",
          "details": "测试方法：\n1、是否使用HTTPS协议。\n2、应用系统界面关键地方如个人信息页面中的个人数据、财务信息等敏感信息是否加星号脱敏了。\n3、通过Fiddler抓包查看所有请求包、响应包中是否对敏感字段加密了。敏感字读如：name、phone、key、id等。\n预期结果：使用 HTTPS 协议传输；敏感信息在传输和存储时进行了加密或脱敏。"
        },
        "industry_standard": null
      }
    ]
  },
  "统一身份认证": {
    "threats": [
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "图片": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "推送过滤": {
    "threats": [
      {
        "name": "不当推广",
        "details": "",
        "security_requirement": {
          "name": "不当推广",
          "details": "防止未经授权的广告或宣传信息发送"
        },
        "security_design": {
          "name": "不当推广",
          "details": "推广内容审核机制：\n建立严格的内容审核团队或采用智能审核系统，对准备发出的所有广告、宣传信息进行前置审核，依据相关法律法规、平台规则以及用户授权情况，仔细甄别内容的合法性、合规性与授权状态，禁止未经授权的信息发布。\n发送权限管理：\n明确划分不同角色、部门或用户在推广信息发送方面的权限，遵循最小权限原则，仅赋予经过正规授权流程的主体相应权限，并且对权限的使用情况进行严格记录与审计，防止权限滥用导致的不当推广。\n用户授权确认：\n在收集用户信息用于推广目的时，通过清晰明确、通俗易懂的方式告知用户授权范围、用途等关键信息，获取用户的明示同意，同时做好授权记录的留存与管理，确保每一次推广信息发送都有对应的合法授权依据。\n渠道管控：\n对各类推广信息发送渠道（如短信平台、邮件系统、社交媒体账号等）进行统一管理，限定只有符合要求且经过授权的渠道才能用于信息推送，定期排查渠道使用情况，避免非法渠道被用于不当推广。"
        },
        "test_case": {
          "name": "不当推广",
          "details": "测试方法：尝试订阅和退订推广信息，验证系统是否提供明确和易用的订阅和退订机制，并确保退订后不再收到推广信息。\n预期结果：取消/退订后不会再次受到信息。"
        },
        "industry_standard": null
      },
      {
        "name": "垃圾信息推送",
        "details": "",
        "security_requirement": {
          "name": "垃圾信息推送",
          "details": "防止恶意用户或攻击者利用通知推送功能发送垃圾信息。\n加强对通知推送的许可控制和监控，确保只有合法的通知能够被发送。"
        },
        "security_design": {
          "name": "垃圾信息推送",
          "details": "许可获取机制完善：\n开发时设计清晰许可弹窗，展示推送目的、内容类别、频率等。用户充分知晓后主动授权开启，避免默认或诱导授权，从源头降低恶意推送风险，保障用户对通知推送的自主控制权，让推送行为建立在用户意愿基础之上。\n权限分级管理：\n依据业务功能、通知重要性等多维度细分权限。重要通知限高级管理员操作，一般业务通知依职责分配权限。严格的权限划分可防止越权与冒用，避免垃圾信息因权限失控而泛滥，确保推送权限与业务需求及用户角色精准匹配。\n内容审核机制：\n构建审核模块，借助关键词过滤、格式规范与语义分析技术。审核推送内容合法性、合规性，筛查违法、低俗、广告等垃圾信息。不符要求则阻止发送并记录，仅放行合法有价值通知，为用户接收信息把好质量关。\n推送监控系统：\n搭建监控系统，实时跟踪推送源、时间、内容与接收对象。运用数据挖掘与机器学习分析数据，及时发现异常，如短时间大量相似推送、内容与业务不符等。发现异常自动阻断并警报，保障推送过程安全有序，维护系统推送环境的健康稳定。\n黑白名单设置：\n设立黑白名单机制，审核授权的优质源与账号入白名单，给予优先推送权。有违规记录或疑似恶意的入黑名单封禁。精准动态管理约束推送主体，有效拦截垃圾信息，增强通知推送的安全性与可信度。\n反馈与调整机制：\n开辟用户反馈渠道，设垃圾信息标记按钮与文字框。开发团队定期整理分析反馈，依此优化许可流程、权限设置、审核规则与监控策略等。根据用户意见迭代系统防范能力，使推送服务贴合用户需求，持续健康运行。"
        },
        "test_case": {
          "name": "垃圾信息推送",
          "details": "测试方法：向目标系统发送大量垃圾信息，比如大量垃圾邮件或短信。\n预期结果：如果系统没有有效的防御措施，可能导致系统负载过大，用户受到骚扰，甚至系统崩溃。有效的防御措施应该能够过滤掉垃圾信息，保障系统正常运行和用户体验。"
        },
        "industry_standard": null
      }
    ]
  },
  "网络安全配置（针对新上线）": {
    "threats": [
      {
        "name": "端口安全",
        "details": "",
        "security_requirement": {
          "name": "端口安全",
          "details": "禁用非必要的服务端口暴露"
        },
        "security_design": {
          "name": "端口安全",
          "details": "端口扫描与清查：\n定期进行全面的端口扫描，精准识别系统中所有开启的端口，详细记录端口对应的服务信息，确保无遗漏，并与业务需求及安全策略严格比对，清查非必要开启的端口。\n端口访问控制列表（ACL）设置：\n为允许访问的必要端口配置精细的访问控制列表，明确指定可访问的源 IP 地址范围、访问时间等限制条件，严禁其他未授权来源的连接请求，将端口访问权限严格限定在最小化范围内。\n端口监控与预警：\n部署实时端口监控系统，对端口的连接状态、流量大小、连接频率等关键指标进行持续监测，一旦发现异常连接尝试（如来自陌生 IP 地址的大量连接请求、特定端口流量突增等），立即触发预警机制，及时通知安全运维人员进行处理。\n端口安全加固：\n对必要开放的服务端口，采用最新的安全补丁和升级策略，及时修复已知存在的安全漏洞，同时优化端口相关服务的配置，禁用不必要的功能模块，降低因端口服务自身缺陷导致的安全风险。"
        },
        "test_case": {
          "name": "端口安全",
          "details": "测试方法：使用Nmap（nmap -p- -sV -T4 <目标IP或域名>）扫描目标服务器的IP地址，列出当前开放的服务端口。\n预期结果：open 的端口只包含服务器上业务所需的端口。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "未安全配置",
        "details": "",
        "security_requirement": {
          "name": "未安全配置",
          "details": "安全配置审查：对系统、应用程序和网络设备的安全配置进行定期审查和评估，发现并修复安全配置问题。\n安全最佳实践：遵循安全最佳实践，对系统和应用程序进行安全配置，降低安全风险。"
        },
        "security_design": {
          "name": "未安全配置",
          "details": "安全配置审查：\n对系统、应用程序和网络设备的安全配置进行定期审查和评估，发现并修复安全配置问题。\n安全最佳实践：\n遵循安全最佳实践，对系统和应用程序进行安全配置，降低安全风险。"
        },
        "test_case": {
          "name": "未安全配置",
          "details": "测试方法：\n1、检查系统管理员账户、数据库账户、Web应用程序账户等常见账户的密码是否已经修改为强密码。可以使用弱密码去尝试登录，如123456、123qwe、admin888、test等。\n2、检查服务器上是否运行了不必要的服务或开放了不必要的端口，例如SSH服务（22端口）、Telnet服务（23端口）等，并向系统管理员确认是否需要打开这些端口。\n3、查看配置文件，检查其中是否包含了敏感信息，例如数据库连接密码、API密钥、加密密钥等。\n预期结果：无不安全的配置。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "文件导出": {
    "threats": [
      {
        "name": "文件读取漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件读取漏洞",
          "details": "访问控制：实施严格的文件访问控制策略，确保只有授权用户可以访问特定的文件。\n文件路径验证：对用户提供的文件路径进行验证和过滤，防止恶意构造的路径导致文件读取漏洞。\n最小权限原则：为应用程序分配最小权限，限制其对文件系统的访问，减少潜在的漏洞风险。"
        },
        "security_design": {
          "name": "文件读取漏洞",
          "details": "访问控制：\n依据用户角色、业务需求等因素，制定精细的文件访问控制策略，明确不同用户、不同业务模块所能访问的具体文件范围，严格限制非授权用户对任何敏感或关键文件的访问，例如，财务文件仅允许财务部门相关授权人员读取操作。\n文件路径验证：\n在接收用户输入的文件路径时，运用严格的正则表达式等验证手段，对路径进行合法性检查，过滤掉包含特殊字符、非法目录跳转符号（如 “../” 等可能导致目录穿越的符号）的恶意构造路径，保证文件路径指向符合安全预期的范围，杜绝因路径被恶意操控而引发的文件读取漏洞。\n最小权限原则：\n遵循最小权限分配理念，精准评估应用程序实际运行所需的文件系统访问权限，只为其赋予必要的最低限度权限，比如只允许读取特定目录下的配置文件，禁止对其他无关目录及文件进行写、删除等操作，以此最大程度降低因权限过大而产生文件读取方面潜在漏洞的风险。"
        },
        "test_case": {
          "name": "文件读取漏洞",
          "details": "测试方法：对带有路径的文件访问 URL，使用Fiddler抓包截取流量，然后拼接文件路径。例如\"../etc/passwd\"、\"../../../etc/passwd“\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      },
      {
        "name": "文件下载漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件下载漏洞",
          "details": "访问控制：确保只有授权用户可以访问特定的文件，并且对敏感文件进行适当的权限控制。\n文件路径验证：对用户提供的文件路径进行验证和过滤，防止恶意构造的路径导致文件下载漏洞。\n安全配置：确保系统和应用程序的文件下载配置安全，避免存在不安全的下载接口或配置。"
        },
        "security_design": {
          "name": "文件下载漏洞",
          "details": "访问控制：\n依据不同用户的角色、职责以及业务需求，细致规划访问控制规则，明确规定哪些用户能够访问哪些特定文件，针对包含重要信息的敏感文件，比如机密文档、用户隐私数据文件等，设置更为严格的权限级别，仅开放给有高度相关业务需要的授权人员，通过这种精准的权限把控，防止未授权的下载行为发生。\n文件路径验证：\n在处理用户发起的文件下载请求时，对所提供的文件路径运用严格的验证机制，例如借助正则表达式等技术手段，过滤掉那些包含可能导致目录穿越的特殊字符（像 “../” 这类可跳出当前目录层级去访问其他非预期目录文件的符号）以及不符合系统逻辑的非法路径构造，确保用户只能从合法、预期的路径下载文件，杜绝因恶意路径构造而引发的文件下载漏洞。\n安全配置：\n全面排查系统和应用程序中涉及文件下载的接口及相关配置情况，及时关闭或更新那些存在安全隐患的下载接口，例如缺乏身份验证机制或对下载请求验证不充分的接口；同时，对文件下载相关的配置参数进行严谨审核与优化，比如限制下载的并发数、控制下载的速率等，避免因不安全的配置使得文件下载功能被恶意利用，保障整个文件下载过程处于安全可靠的状态。\n"
        },
        "test_case": {
          "name": "文件下载漏洞",
          "details": "测试方法：修改下载链接中的 id 或遍历文件名或目录，查看能否下载预期之外的文件。\n预期结果：受限制或报错。"
        },
        "industry_standard": null
      }
    ]
  },
  "文件导入": {
    "threats": [
      {
        "name": "文件解析漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n恶意代码检测：使用恶意代码检测工具或技术，对上传的文件进行扫描，及时发现和处理潜在的恶意代码。\n安全配置：确保系统和应用程序的文件解析配置安全，避免存在不安全的解析器或配置。"
        },
        "security_design": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：\n建立全面且严格的文件类型白名单机制，针对上传的文件，详细检查其文件头信息、扩展名等多方面特征，与白名单中的合法文件类型进行精确匹配，坚决拒绝任何不在白名单内的文件上传，有效防止恶意文件（如含有脚本代码的伪装文件）混入系统。\n恶意代码检测：\n集成先进的恶意代码检测工具，在文件上传环节或定期对系统内已存储的文件进行深度扫描，运用特征码匹配、行为分析等多种检测技术，及时精准地识别潜在的恶意代码片段，一旦发现，立即采取隔离、删除等处理措施，并记录相关信息以便追溯分析。\n安全配置：\n全面审查系统和应用程序的文件解析配置，禁用或更新存在安全隐患的解析器，如老旧版本的 XML 解析器等容易遭受攻击的组件；同时，对文件解析的相关参数进行安全设置，限制解析的深度、范围等，避免因不安全的配置导致文件解析漏洞被利用，确保整个文件解析过程在安全可控的环境下进行。"
        },
        "test_case": {
          "name": "文件解析漏洞",
          "details": "测试方法：合法上传文件过程中，使用 Fiddler 拦截上传数据包，修改为非法文件名（1.jsp、2.ASp、shell.PHP等执行脚本名称。），在取消拦截查看是否成功。\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      },
      {
        "name": "文件上传漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n文件大小限制：限制上传文件的大小，防止攻击者上传过大的文件导致服务器资源耗尽。\n安全权限设置：确保上传文件的存储目录具有适当的权限设置，防止恶意文件被执行或访问。"
        },
        "security_design": {
          "name": "文件上传漏洞",
          "details": "文件类型验证：\n构建严谨的文件类型验证体系，采用多种验证方式相结合，例如不仅检查文件扩展名，还深入分析文件头特征信息，与预定义的安全文件类型白名单进行细致比对，严禁任何不在白名单中的文件类型上传，有效阻拦恶意脚本文件、可执行文件等非法文件进入系统。\n文件大小限制：\n在文件上传功能模块中，设定合理的文件大小上限值，此值应综合考虑服务器性能、业务需求以及安全风险等多方面因素。当用户上传文件时，系统自动检查文件大小，若超出限制则立即中断上传过程，并向用户反馈相应提示信息，防止攻击者通过上传超大文件耗尽服务器资源，如磁盘空间、内存等，保障服务器稳定运行。\n安全权限设置：\n针对上传文件的存储目录，精心规划并设置严格的权限策略。赋予该目录仅允许特定合法进程进行写入操作的权限，而禁止其他非授权进程或用户对上传文件进行读取、执行等操作，防止恶意上传的文件被意外执行或非法访问，降低因文件上传漏洞引发的安全风险，确保服务器文件系统的安全性与完整性。"
        },
        "test_case": {
          "name": "文件上传漏洞",
          "details": "测试方法：检查应用程序是否只接受特定扩展名（如.jpg、.pdf）和类型（如图像、文档）的文件上传。\n预期结果：应用程序应拒绝上传可疑或不符合规定的文件类型或扩展名。"
        },
        "industry_standard": null
      }
    ]
  },
  "文件共享": {
    "threats": [
      {
        "name": "数据泄露",
        "details": "",
        "security_requirement": {
          "name": "数据泄露",
          "details": "1. 禁止无参数的请求返回数据\n2. 不返回除必须业务要素外的敏感信息、内部信息（系统资源地址等）"
        },
        "security_design": {
          "name": "数据泄露",
          "details": "严格请求参数校验\n在数据交互接口处，强化对请求参数的检查机制。明确要求所有请求必须携带符合规范的参数，对于无参数的请求直接拒绝响应，从源头杜绝因不合理请求导致数据意外泄露的风险，确保只有合规请求才能获取相应数据。\n精准数据筛选返回\n梳理业务流程，明确各业务场景下必须的业务要素，在返回数据时，严格按照此标准进行筛选。对敏感信息（如用户隐私数据）、内部信息（像系统资源地址）等非必要内容进行剔除，防止多余且敏感的数据被返回，最大程度保障数据安全，避免不必要的数据泄露情况发生。"
        },
        "test_case": {
          "name": "数据泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "文件解析": {
    "threats": [
      {
        "name": "文件解析漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：对上传的文件进行有效的文件类型验证和过滤，防止上传恶意文件。\n恶意代码检测：使用恶意代码检测工具或技术，对上传的文件进行扫描，及时发现和处理潜在的恶意代码。\n安全配置：确保系统和应用程序的文件解析配置安全，避免存在不安全的解析器或配置。"
        },
        "security_design": {
          "name": "文件解析漏洞",
          "details": "文件类型验证：\n建立全面且严格的文件类型白名单机制，针对上传的文件，详细检查其文件头信息、扩展名等多方面特征，与白名单中的合法文件类型进行精确匹配，坚决拒绝任何不在白名单内的文件上传，有效防止恶意文件（如含有脚本代码的伪装文件）混入系统。\n恶意代码检测：\n集成先进的恶意代码检测工具，在文件上传环节或定期对系统内已存储的文件进行深度扫描，运用特征码匹配、行为分析等多种检测技术，及时精准地识别潜在的恶意代码片段，一旦发现，立即采取隔离、删除等处理措施，并记录相关信息以便追溯分析。\n安全配置：\n全面审查系统和应用程序的文件解析配置，禁用或更新存在安全隐患的解析器，如老旧版本的 XML 解析器等容易遭受攻击的组件；同时，对文件解析的相关参数进行安全设置，限制解析的深度、范围等，避免因不安全的配置导致文件解析漏洞被利用，确保整个文件解析过程在安全可控的环境下进行。"
        },
        "test_case": {
          "name": "文件解析漏洞",
          "details": "测试方法：合法上传文件过程中，使用 Fiddler 拦截上传数据包，修改为非法文件名（1.jsp、2.ASp、shell.PHP等执行脚本名称。），在取消拦截查看是否成功。\n预期结果：应用程序应正确限制文件访问，只允许读取授权的文件路径，并在输入参数中防止路径遍历和非法文件访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "文件删除操作": {
    "threats": [
      {
        "name": "目录遍历",
        "details": "",
        "security_requirement": {
          "name": "目录遍历",
          "details": "确保应用程序对文件系统的访问受到适当的限制，仅允许合法的文件访问。\n加强对用户输入的验证和过滤，防止恶意用户利用目录遍历漏洞进行攻击。"
        },
        "security_design": {
          "name": "目录遍历",
          "details": "访问权限限制：\n明确设定应用程序在文件系统中的访问范围，依据业务需求划分出可访问区域与禁止访问区域，仅授予访问合法文件的权限，如限定只能读取特定文件夹内文件，避免触及其他敏感目录。\n输入验证规则：\n制定严格的用户输入验证机制，用正则表达式等检查输入是否符合预期格式，像只允许输入合法文件名格式的内容，拒绝包含 “../”“..\\” 这类可用于目录遍历的特殊字符组合的输入。\n输入过滤处理：\n对用户输入仔细筛查，将诸如 “../” 等能引发目录遍历的字符及相关构造进行过滤，确保输入无法被利用来突破限定目录，访问不该访问的文件。\n异常监测反馈：\n搭建异常监测体系，实时留意文件访问中的异常情况，若出现频繁尝试突破访问限制等行为，及时记录并反馈，以便快速采取措施应对目录遍历攻击风险。"
        },
        "test_case": {
          "name": "目录遍历",
          "details": "测试方法：在传参 filepath 的地方或URL带有路径的文件下载 的地方，尝试输入\"../../../../../etc/passwd\"\n预期结果：已经过滤\"../\"，访问失败或报错。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "文章": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "下单与支付": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "支付漏洞",
        "details": "",
        "security_requirement": {
          "name": "支付漏洞",
          "details": "1. 服务器端在生成交易订单时，商品的价格从数据库中取出，禁止使用客户端发送的商品价格。\n2. 服务器端对客户端提交的交易数据（如商品ID、商品数量、商品价格等）的取值范围进行校验，将商品ID和商品价格与数据库中的数据对比校验，商品数量为大于零的整型数。\n3. 服务器端在生成支付订单时，对支付订单中影响支付金额的所有因素（比如商品ID、商品数量、商品价格、订单编号等）进行签名，对客户端提交的支付订单进行校验"
        },
        "security_design": {
          "name": "支付漏洞",
          "details": "价格获取规范：\n服务器生成交易订单时，务必从数据库取商品价格，杜绝用客户端发送价格，防止客户端篡改价格造成支付漏洞，保障交易金额准确。\n数据取值校验：\n服务器要校验客户端提交的交易数据取值范围，比对商品 ID、价格与数据库记录，限定商品数量为正整数，避免异常数据影响支付金额准确性。\n支付订单签名：\n生成支付订单时，对影响支付金额的各因素签名，校验客户端提交的支付订单，以此验证订单完整性与真实性，有效堵住支付漏洞，确保支付安全。"
        },
        "test_case": {
          "name": "支付漏洞",
          "details": "测试方法：创建订单时，尝试输入不同的数据，包括合法已存在或非法的数据，例如订单数量、价格、产品信息等。观察系统对输入数据的反应。\n预期结果：创建失败。"
        },
        "industry_standard": null
      }
    ]
  },
  "下载": {
    "threats": [
      {
        "name": "文件下载漏洞",
        "details": "",
        "security_requirement": {
          "name": "文件下载漏洞",
          "details": "访问控制：确保只有授权用户可以访问特定的文件，并且对敏感文件进行适当的权限控制。\n文件路径验证：对用户提供的文件路径进行验证和过滤，防止恶意构造的路径导致文件下载漏洞。\n安全配置：确保系统和应用程序的文件下载配置安全，避免存在不安全的下载接口或配置。"
        },
        "security_design": {
          "name": "文件下载漏洞",
          "details": "访问控制：\n依据不同用户的角色、职责以及业务需求，细致规划访问控制规则，明确规定哪些用户能够访问哪些特定文件，针对包含重要信息的敏感文件，比如机密文档、用户隐私数据文件等，设置更为严格的权限级别，仅开放给有高度相关业务需要的授权人员，通过这种精准的权限把控，防止未授权的下载行为发生。\n文件路径验证：\n在处理用户发起的文件下载请求时，对所提供的文件路径运用严格的验证机制，例如借助正则表达式等技术手段，过滤掉那些包含可能导致目录穿越的特殊字符（像 “../” 这类可跳出当前目录层级去访问其他非预期目录文件的符号）以及不符合系统逻辑的非法路径构造，确保用户只能从合法、预期的路径下载文件，杜绝因恶意路径构造而引发的文件下载漏洞。\n安全配置：\n全面排查系统和应用程序中涉及文件下载的接口及相关配置情况，及时关闭或更新那些存在安全隐患的下载接口，例如缺乏身份验证机制或对下载请求验证不充分的接口；同时，对文件下载相关的配置参数进行严谨审核与优化，比如限制下载的并发数、控制下载的速率等，避免因不安全的配置使得文件下载功能被恶意利用，保障整个文件下载过程处于安全可靠的状态。\n"
        },
        "test_case": {
          "name": "文件下载漏洞",
          "details": "测试方法：修改下载链接中的 id 或遍历文件名或目录，查看能否下载预期之外的文件。\n预期结果：受限制或报错。"
        },
        "industry_standard": null
      }
    ]
  },
  "响应头设置（针对新上线）": {
    "threats": [
      {
        "name": "安全头部绕过",
        "details": "",
        "security_requirement": {
          "name": "安全头部绕过",
          "details": "正确设置和验证安全头部，防止绕过攻击"
        },
        "security_design": {
          "name": "安全头部绕过",
          "details": "安全头部规范设置：\n严格按照安全最佳实践，为网站或应用配置关键安全头部，如 Content-Security-Policy（CSP）用于控制资源加载、X-Frame-Options 限制页面嵌入、X-XSS-Protection 防范跨站脚本攻击等，确保各安全头部的参数准确合理。\n多头部协同验证：\n在服务器端建立综合的验证机制，对多个安全头部同时进行检查和校验，避免攻击者通过利用单一头部验证的薄弱点来绕过整体防护，确保各头部设置相互配合、形成严密的安全防线。\n定期检查更新：\n定期对已设置的安全头部进行全面检查，依据业务变化、新出现的安全威胁以及浏览器等技术环境的更新情况，及时调整和优化安全头部的参数及配置，保持防护的有效性。"
        },
        "test_case": {
          "name": "安全头部绕过",
          "details": "测试方法：修改 HTTP 头信息中的参数，如Content Security Policy、X-Frame-Options、X-XSS-Protection等，再次发送修改的数据包。\n预期结果：发送失败或报错。"
        },
        "industry_standard": null
      }
    ]
  },
  "消息队列": {
    "threats": [
      {
        "name": "服务权限控制",
        "details": "",
        "security_requirement": {
          "name": "服务权限控制",
          "details": "使用普通权限的运行服务"
        },
        "security_design": {
          "name": "服务权限控制",
          "details": "最小权限原则应用：\n详细梳理服务所需的各类操作权限，严格按照最小权限原则为服务分配权限。例如，仅赋予服务读取其运行必需配置文件的权限，而非整个文件系统的读取权限；仅允许服务与特定数据库表进行交互，且限制其操作类型为仅查询或仅特定条件下的更新，避免赋予不必要的增删改权限。\n权限分组与角色管理：\n将服务可能涉及的权限进行分类分组，创建与之对应的角色。每个服务仅关联其实际所需的角色，而非直接分配大量零散权限。通过角色的集中管理和调整，便于权限的统一管控和审计，降低因权限设置混乱导致的安全风险。\n权限动态调整机制：\n根据服务的运行状态和业务需求变化，建立动态的权限调整机制。例如，在服务进行非关键数据处理阶段，可适当降低其部分权限；当服务需要执行特定重要任务时，临时提升其所需的最小权限范围，任务完成后及时恢复原有权限设置，确保服务权限始终处于合理且安全的状态。"
        },
        "test_case": {
          "name": "服务权限控制",
          "details": "测试方法：咨询发布人员，是否以非 root 用户发布 web 服务。\n预期结果：文件访问用户、服务启动的用户是普通账户，不是root或者administrator账户。"
        },
        "industry_standard": {
          "name": "网安第四章第四十九条第二款",
          "details": null
        }
      },
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": null
      },
      {
        "name": "篡改",
        "details": "",
        "security_requirement": {
          "name": "篡改",
          "details": "确保系统能够防止数据在传输或存储过程中被篡改，保护数据的完整性和准确性。"
        },
        "security_design": {
          "name": "篡改",
          "details": "传输加密：\n在数据传输阶段，采用强加密算法（如 SSL/TLS 协议等）对数据进行加密处理，确保数据在网络通道中以密文形式传输，即使被拦截，攻击者也难以对密文内容进行篡改，保障传输过程的数据完整性。\n存储加密：\n对于存储的数据，使用合适的加密方式（如对称加密、非对称加密等）进行加密存储，只有拥有正确解密密钥的授权主体才能访问原始数据，防止存储过程中数据被非法篡改。\n完整性校验：\n定期或在数据使用前，采用哈希算法（如 SHA-256 等）计算数据的哈希值，并与预先保存的正确哈希值进行比对，若两者不一致，则表明数据可能被篡改，需进一步排查处理。\n访问控制：\n严格设置数据的访问权限，依据用户角色、权限级别等因素，只允许授权人员对数据进行读写等操作，限制非授权访问，从源头上减少数据被篡改的风险。\n监控与告警：\n搭建数据状态的监控系统，实时关注数据传输、存储过程中的相关指标，如数据流量变化、加密状态、完整性校验结果等，一旦发现疑似数据篡改的异常情况，及时触发告警，通知安全运维人员进行深入调查和修复。\n备份恢复：\n制定合理的数据备份策略，定期对重要数据进行备份，存储在独立、安全的介质或位置，当发现数据被篡改时，可利用备份数据进行恢复，最大程度降低篡改带来的损失。"
        },
        "test_case": {
          "name": "篡改",
          "details": "测试方法：使用 Fiddler 抓包，检查传输过程中敏感数据是否进行了加密。\n预期结果：使用非 MD5、base64等弱加密算法。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      }
    ]
  },
  "通知与提醒": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "小程序交互（针对新上线）": {
    "threats": [
      {
        "name": "代码信息泄露",
        "details": "",
        "security_requirement": {
          "name": "代码信息泄露",
          "details": "防止敏感代码信息泄露，包括源代码、配置文件、注释等，以避免攻击者获取系统架构和逻辑信息，从而进行更精确的攻击。"
        },
        "security_design": {
          "name": "代码信息泄露",
          "details": "代码混淆：\n对源代码进行混淆处理，通过重命名变量、函数等标识符，打乱代码逻辑结构，让攻击者难以直接读懂代码内容，增加逆向分析获取有效信息的难度，保护代码逻辑不被轻易窥探。\n访问权限控制：\n严格限制对源代码、配置文件存储位置的访问权限，依据职责和工作需求，仅允许相关的开发、运维等授权人员进行查看、修改，禁止非授权访问，防止内部人员误操作或外部攻击者直接获取敏感代码信息。\n生产环境清理：\n在将代码部署到生产环境前，仔细去除不必要的调试信息、注释内容以及测试相关代码，确保生产环境中留存的都是与实际运行相关且不包含敏感信息的代码，减少可被攻击者利用的信息暴露。\n加密存储：\n对于包含敏感信息的配置文件，采用加密的方式进行存储，只有在运行时通过安全的解密机制、凭借正确的密钥才能获取并使用其中的内容，防止配置信息被窃取查看。\n网络隔离：\n划分不同的网络区域，将开发环境、测试环境与生产环境进行有效隔离，限制不同区域间随意的数据传输，避免因网络安全漏洞导致代码信息从相对安全的区域泄露到外部，增加整体防护层级。\n版本管理安全：\n在使用代码版本管理工具（如 Git 等）时，合理配置访问权限，设置强密码和多因素认证，对重要的代码仓库设置为私有，同时定期审查版本管理系统中的操作记录，防止代码被非法下载或查看。"
        },
        "test_case": {
          "name": "代码信息泄露",
          "details": "测试方法：查看源码中是否存在Git存储库地址、账户、数据库凭据、API密钥等信息。\n预期结果：不存在。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "信息注册": {
    "threats": [
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "业务查询": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "业务记录": {
    "threats": [
      {
        "name": "日志伪造",
        "details": "",
        "security_requirement": {
          "name": "日志伪造",
          "details": "确保系统日志的完整性和真实性，防止日志被篡改或伪造。"
        },
        "security_design": {
          "name": "日志伪造",
          "details": "存储加密：\n采用加密算法对系统日志加密后存储，比如使用 AES 算法，确保日志内容以密文形式存在，让不法分子难以篡改原始内容，保障完整性与真实性。\n数字签名：\n运用数字签名技术，为每条日志添加唯一签名，凭借公私钥机制验证日志来源及完整性，一旦日志被篡改，签名验证就会失败，及时发现异常。\n权限严控：\n设置严格的访问权限，仅授权特定人员可查看、操作日志，并且对操作行为全程记录，防止内部人员违规篡改伪造，杜绝外部非法访问。\n实时监测：\n搭建日志监测系统，实时比对日志数据的变动情况，一旦发现有不符合正常模式的修改痕迹或异常新增等情况，立即发出警报并溯源，防范日志伪造行为。"
        },
        "test_case": {
          "name": "日志伪造",
          "details": "测试方法：\n1、在有日志记录的输入处，额外插入日志格式的伪造条目（如：%0a%0aINFO:+User+logged+out%3dbadguy），再查看日志是否新增成功。\n2、检查写入日志的敏感信息是否已经脱敏。\n预期结果：\n1、日志无法修改和新增。\n2、日志中存在敏感信息处已脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "日志泄露",
        "details": "",
        "security_requirement": {
          "name": "日志泄露",
          "details": "确保系统能够防止日志泄露，保护系统日志的敏感信息不被未授权访问。"
        },
        "security_design": {
          "name": "日志泄露",
          "details": "存储加密保障：\n采用可靠的加密算法（如 AES 等）对系统日志加密存储，使得即便存储介质被非法获取，日志内容也难以被解读，保障敏感信息安全，防止因存储环节出问题而泄露。\n访问权限设置：\n依据角色和业务需求精细划分访问日志的权限，仅允许经过授权的特定人员查看、操作日志，比如运维人员、安全审计人员等，同时采用多因素认证加强把关，杜绝未授权访问。\n传输安全把控：\n在日志需要远程传输时，运用安全传输协议（如 HTTPS）进行加密打包传输，防止在网络传输过程中被窃取，确保日志从产生到传输的各环节保密性良好。\n监控预警机制：\n搭建日志访问监控系统，实时关注日志的访问情况，一旦出现异常访问行为，像频繁尝试突破权限等，及时发出警报并采取措施阻断访问，防范日志泄露风险。"
        },
        "test_case": {
          "name": "日志泄露",
          "details": "测试方法：通过直接拼接现有的域名，将下面的文件路径组合后访问，查看能否有数据内容显示。\n\t/.git/\n\t/.git/config\n\t/.DS_Store\n\t/WEB-INF/web.xml\n\t/WEB-INF/classes/\n\t/WEB-INF/lib/\n\t/WEB-INF/src/\n\t/WEB-INF/database.properties\n预期结果：访问这些敏感路径后提示拒绝访问或无任何数据内容。"
        },
        "industry_standard": null
      }
    ]
  },
  "异常行为检测": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "数据保密性",
          "details": null
        }
      }
    ]
  },
  "异常检测": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "安全审计",
          "details": null
        }
      }
    ]
  },
  "用户进行投资操作（如买入、卖出、调整仓位）": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "支付漏洞",
        "details": "",
        "security_requirement": {
          "name": "支付漏洞",
          "details": "1. 服务器端在生成交易订单时，商品的价格从数据库中取出，禁止使用客户端发送的商品价格。\n2. 服务器端对客户端提交的交易数据（如商品ID、商品数量、商品价格等）的取值范围进行校验，将商品ID和商品价格与数据库中的数据对比校验，商品数量为大于零的整型数。\n3. 服务器端在生成支付订单时，对支付订单中影响支付金额的所有因素（比如商品ID、商品数量、商品价格、订单编号等）进行签名，对客户端提交的支付订单进行校验"
        },
        "security_design": {
          "name": "支付漏洞",
          "details": "价格获取规范：\n服务器生成交易订单时，务必从数据库取商品价格，杜绝用客户端发送价格，防止客户端篡改价格造成支付漏洞，保障交易金额准确。\n数据取值校验：\n服务器要校验客户端提交的交易数据取值范围，比对商品 ID、价格与数据库记录，限定商品数量为正整数，避免异常数据影响支付金额准确性。\n支付订单签名：\n生成支付订单时，对影响支付金额的各因素签名，校验客户端提交的支付订单，以此验证订单完整性与真实性，有效堵住支付漏洞，确保支付安全。"
        },
        "test_case": {
          "name": "支付漏洞",
          "details": "测试方法：创建订单时，尝试输入不同的数据，包括合法已存在或非法的数据，例如订单数量、价格、产品信息等。观察系统对输入数据的反应。\n预期结果：创建失败。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "用户浏览金融产品信息（如股票、基金、理财产品）": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "用户名密码认证": {
    "threats": [
      {
        "name": "基本身份认证",
        "details": "",
        "security_requirement": {
          "name": "基本身份认证",
          "details": "1. 需要有强密码策略；\n2. 应支持管理员后台锁定账号活动异常的用户账号；\n3. 用户在应用系统中输入密码时，不能明文显示密码，应显示为“*”号或者不显示\n4. 身份验证的失败提示信息采用模糊处理\n5. 应强制用户首次登录时修改初始口令（非用户自行注册且由系统后台直接添加的用户）\n6. 用户身份鉴别信息丢失或失效时，应采用技术措施确保鉴别信息重置过程的安全"
        },
        "security_design": {
          "name": "基本身份认证",
          "details": "强密码策略制定：\n设定密码长度、复杂度要求，如至少包含大小写字母、数字、特殊字符，长度不少于 8 位，定期提示用户更新密码，防止因密码简单导致账号被破解。\n账号锁定机制：\n管理员后台具备监控账号活动功能，当发现异常登录行为（如短时间内多次登录失败、异地登录等），可及时锁定相关账号，阻止非法访问进一步发生。\n密码显示安全：\n在用户输入密码时，应用系统界面将密码以 “*” 号或无显示形式呈现，避免密码明文暴露，防止他人偷窥获取密码信息。\n失败提示模糊处理：\n身份验证失败时，不提供具体错误原因，如用户名错误或密码错误等精确信息，仅给出通用模糊提示，防止攻击者利用提示信息进行暴力破解或账号猜测。\n初始口令修改：\n对于非用户自行注册且由系统后台直接添加的用户，首次登录时强制要求修改初始口令，避免初始口令泄露引发安全问题。\n鉴别信息重置安全：\n当用户身份鉴别信息丢失或失效时，通过多因素验证（如手机验证码、邮箱验证等）或安全问答等技术手段，确保重置过程安全可靠，防止非法重置他人账号鉴别信息。"
        },
        "test_case": {
          "name": "基本身份认证",
          "details": "测试方法：\n1、在注册或修改密码处测试，测试密码复杂度（例如是否满足最小长度、数字、字母、特殊字符几种的组合等）。\n2、确认错误提示信息是否模糊。\n预期结果：\n1、密码复杂度策略强制执行，不符合强度要求的密码不允许进入下一步流程；\n2、登录错误提示信息应模糊，只指出登录失败，而不透露具体错误原因（例如，用户名或密码不匹配）。"
        },
        "industry_standard": {
          "name": "身份鉴别",
          "details": null
        }
      }
    ]
  },
  "用户权限管理": {
    "threats": [
      {
        "name": "权限获取",
        "details": "",
        "security_requirement": {
          "name": "权限获取",
          "details": "用户明确授权：用户在应用程序或系统中提供权限时，应该明确知晓并同意所授予的权限范围。\n最小权限原则：系统只应该获取必要的权限，避免获取过多权限造成滥用或泄露风险。"
        },
        "security_design": {
          "name": "权限获取",
          "details": "清晰授权提示：\n在应用界面显著位置展示权限说明，详细列出每项权限对应的功能及影响，让用户清楚了解后再决定是否授予，保障其知情权与选择权。\n按需申请权限：\n系统开发时精准梳理业务所需权限，仅在必要功能执行时向用户申请，避免一次性索要过多不必要权限，比如仅拍照功能启用时申请相机权限，防止权限滥用隐患。\n权限使用记录：\n搭建权限使用监控机制，记录每次权限调用情况，包括时间、操作内容等，方便用户查看，也便于及时发现异常使用行为，有效管控权限风险。\n定期权限复核：\n定期审查系统获取的权限是否依然必要，根据业务变化及时调整，去除冗余权限，始终遵循最小权限原则，确保权限运用的合理性与安全性。"
        },
        "test_case": {
          "name": "权限获取",
          "details": "测试方法：使用普通账户登录应用系统后，访问管理员账户才允许访问的URL资源，查看是否能成功访问。\n预期结果：普通账户无法访问管理员账户才能访问的资源。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "权限滥用",
        "details": "未按照最小授权原则进行授权，可能导致用户获得超出其实际需要的权限，从而滥用权限，进行非法操作或访问敏感数据，增加数据泄露的风险。",
        "security_requirement": {
          "name": "权限滥用",
          "details": "确保系统能够有效防止权限滥用行为，保护系统资源和用户数据的安全。"
        },
        "security_design": {
          "name": "权限滥用",
          "details": "权限细分管控：\n将系统权限依据功能模块、操作类型等进行精细划分，为不同角色、用户设定对应且精准的权限范围，避免权限宽泛易被滥用，确保各操作都有严格权限限制。\n操作审计机制：\n搭建完善的权限使用审计系统，实时记录权限操作详情，像操作时间、执行者、具体行为等，定期分析审计数据，及时发现频繁越权、异常操作等滥用行为。\n实时监控预警：\n设置监控规则，对权限使用频率、资源访问量等关键指标实时监测，一旦出现超出正常阈值的情况，如短时间内大量删除数据等，立即触发警报并阻断操作，防范权限滥用。\n权限回收调整：\n定期评估用户、角色的权限合理性，根据业务变动及权限使用情况，及时回收不必要权限，对存在滥用风险的权限进行调整，保障系统与数据安全。"
        },
        "test_case": {
          "name": "权限滥用",
          "details": "测试方法：用管理员账户登录应用系统后，进行一些敏感行为的操作，如删除数据库、重启系统服务、服务更新等敏感操作。\n预期结果：管理员账户仅能够访问自己授权内的功能。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      },
      {
        "name": "权限最小化",
        "details": "",
        "security_requirement": {
          "name": "权限最小化",
          "details": "1. 应用系统对用户/管理员、数据库连接等应采取最小权限原则\n2. 应用系统启动的相关进程、系统各组件不得使用特权账户"
        },
        "security_design": {
          "name": "权限最小化",
          "details": "权限梳理与分配：\n细致梳理应用系统各功能所需权限，无论是用户操作还是管理员管理，以及数据库连接场景，均按实际需求精准分配，杜绝多余权限赋予，严格践行最小权限原则。\n账户权限管控：\n针对应用系统启动的进程及各组件，禁用特权账户，改为设立专用的普通权限账户，仅赋予其完成对应任务必需的权限，防止因特权账户带来权限滥用、安全漏洞等风险。\n定期复核更新：\n定期重新审视权限分配情况，依据业务变化、功能增减等及时调整，持续确保各主体、各环节都维持在最小且合理的权限状态，保障系统安全稳定运行。\n权限使用审计：\n建立权限使用审计机制，详细记录权限调用情况，便于监测分析是否存在超出最小权限范围的异常操作，发现问题及时纠正，强化最小权限落实。"
        },
        "test_case": {
          "name": "权限最小化",
          "details": "测试方法：咨询发布人员，是否以非 root 用户发布 web 服务。\n预期结果：文件访问用户、服务启动的用户是普通账户，不是root或者administrator账户。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "用户添加感兴趣的产品到投资组合或关注列表": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "用户习惯": {
    "threats": [
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "个保第一章第十条",
          "details": null
        }
      }
    ]
  },
  "用户信息修改": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "用户执行交易结算（如资金结算、交易确认）": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "支付漏洞",
        "details": "",
        "security_requirement": {
          "name": "支付漏洞",
          "details": "1. 服务器端在生成交易订单时，商品的价格从数据库中取出，禁止使用客户端发送的商品价格。\n2. 服务器端对客户端提交的交易数据（如商品ID、商品数量、商品价格等）的取值范围进行校验，将商品ID和商品价格与数据库中的数据对比校验，商品数量为大于零的整型数。\n3. 服务器端在生成支付订单时，对支付订单中影响支付金额的所有因素（比如商品ID、商品数量、商品价格、订单编号等）进行签名，对客户端提交的支付订单进行校验"
        },
        "security_design": {
          "name": "支付漏洞",
          "details": "价格获取规范：\n服务器生成交易订单时，务必从数据库取商品价格，杜绝用客户端发送价格，防止客户端篡改价格造成支付漏洞，保障交易金额准确。\n数据取值校验：\n服务器要校验客户端提交的交易数据取值范围，比对商品 ID、价格与数据库记录，限定商品数量为正整数，避免异常数据影响支付金额准确性。\n支付订单签名：\n生成支付订单时，对影响支付金额的各因素签名，校验客户端提交的支付订单，以此验证订单完整性与真实性，有效堵住支付漏洞，确保支付安全。"
        },
        "test_case": {
          "name": "支付漏洞",
          "details": "测试方法：创建订单时，尝试输入不同的数据，包括合法已存在或非法的数据，例如订单数量、价格、产品信息等。观察系统对输入数据的反应。\n预期结果：创建失败。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      }
    ]
  },
  "与其他服务器进行通信，发送HTTP请求或建立TCP连接": {
    "threats": [
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": null
      }
    ]
  },
  "与数据库进行交互，包括查询、插入、更新、删除等操作": {
    "threats": [
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "SQL注入",
          "details": "对用户的输入信息过滤或者转义"
        },
        "security_design": {
          "name": "SQL注入",
          "details": "输入验证：\n严格校验用户输入数据类型、长度与格式，拒绝非法输入。\n字符过滤与转义：\n过滤或转义单引号、双引号等 SQL 特殊字符。\n预编译语句：\n采用预编译技术处理 SQL 查询，分离代码与数据。\n数据库权限：\n依最小权限原则设置数据库用户权限。"
        },
        "test_case": {
          "name": "SQL注入",
          "details": "测试方法：在输入处写入特殊字符（如：@$%&*<>';/）或构造 SQL 语句。\n预期结果：拒绝执行该功能的正确处理，或报错但无过多错误信息。"
        },
        "industry_standard": {
          "name": "数安第三章第二十一条第二款",
          "details": null
        }
      }
    ]
  },
  "允许用户输入的数据直接或间接地作为代码、脚本、模板或表达式进行解析、编译或执行": {
    "threats": [
      {
        "name": "代码执行漏洞",
        "details": "",
        "security_requirement": {
          "name": "代码执行漏洞",
          "details": "防止恶意用户通过漏洞执行恶意代码或命令，从而获取未授权的系统访问权限或导致系统崩溃。"
        },
        "security_design": {
          "name": "代码执行漏洞",
          "details": "输入验证：\n在接收用户输入的各处接口，严格验证输入内容的数据类型、格式、长度等，确保输入符合预期的业务规则，拒绝任何不符合要求、可能包含恶意代码构造的输入，从源头阻断恶意代码进入执行环节。\n代码审查：\n定期开展全面的代码审查工作，利用静态分析工具以及人工审查相结合的方式，查找代码中诸如拼接 SQL 语句、动态执行脚本等容易引发代码执行漏洞的代码片段，及时修复发现的安全隐患。\n安全编码规范：\n制定并遵循严格的安全编码规范，比如避免使用危险的函数（如 eval、exec 等易造成代码执行漏洞的函数），要求开发人员采用更安全的替代方案实现相应功能，从编码层面减少漏洞产生的可能性。\n沙箱机制：\n对于涉及执行外部代码或用户输入内容可能参与执行的场景，构建沙箱环境，将代码执行限制在安全可控的范围内，即使存在恶意代码，也能防止其突破沙箱影响到整个系统，保障系统主体安全。\n权限管理：\n细化系统内的权限设置，遵循最小权限原则，确保执行代码的相关模块、用户仅有必要的权限，限制其所能操作的资源范围，避免恶意代码借助过高权限造成大规模破坏或获取过多未授权访问权限。"
        },
        "test_case": {
          "name": "代码执行漏洞",
          "details": "测试方法：在传参处输出特殊字符，如：$%&*>;'等。\n预期结果：未触发抛出敏感信息的报错或数据库错误信息等"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "允许用户输入的数据直接或间接地作为系统命令执行": {
    "threats": [
      {
        "name": "命令注入",
        "details": "",
        "security_requirement": {
          "name": "命令注入",
          "details": "防止恶意用户向系统中注入恶意命令。\n对用户输入进行有效的验证和过滤，确保输入不会被误解为命令执行。"
        },
        "security_design": {
          "name": "命令注入",
          "details": "输入格式校验：\n开发时明确限定用户输入的格式，比如规定只能输入数字、特定字符范围等。利用正则表达式等技术严格检查输入内容，不符合格式要求的直接拒绝，从源头防止恶意构造的命令混入。\n危险字符过滤：\n梳理出如 “;”“&&”“||” 这类常用于命令注入的危险字符，编写代码在接收用户输入后，自动将这些字符过滤掉，使其无法拼凑成可执行命令，避免被误解执行。\n输入转义处理：\n对于无法过滤的特殊字符，进行转义操作，改变其原本在命令执行语境下的表意，让它们即使进入系统也不会触发命令执行，确保输入安全。\n白名单机制：\n建立输入白名单，只允许符合白名单规则的内容进入系统执行环节，比如仅认可预定义的安全指令，其他一概拒绝，以此精准把控输入内容，防范命令注入攻击。"
        },
        "test_case": {
          "name": "命令注入",
          "details": "测试方法：在应用系统的WEB界面找到输入字段的功能位置，如表单、URL参数等位置，输入常见的系统命令、脚本命令、shell命令等，如ls、ping sss.dnslog.cn、cat /etc/passwd、 ; 、&& 等。\n预期结果：在web界面提示非法输入，抓包的响应信息正常显示业务内容，无其他额外的内容。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "即时通讯": {
    "threats": [
      {
        "name": "篡改",
        "details": "",
        "security_requirement": {
          "name": "篡改",
          "details": "确保系统能够防止数据在传输或存储过程中被篡改，保护数据的完整性和准确性。"
        },
        "security_design": {
          "name": "篡改",
          "details": "传输加密：\n在数据传输阶段，采用强加密算法（如 SSL/TLS 协议等）对数据进行加密处理，确保数据在网络通道中以密文形式传输，即使被拦截，攻击者也难以对密文内容进行篡改，保障传输过程的数据完整性。\n存储加密：\n对于存储的数据，使用合适的加密方式（如对称加密、非对称加密等）进行加密存储，只有拥有正确解密密钥的授权主体才能访问原始数据，防止存储过程中数据被非法篡改。\n完整性校验：\n定期或在数据使用前，采用哈希算法（如 SHA-256 等）计算数据的哈希值，并与预先保存的正确哈希值进行比对，若两者不一致，则表明数据可能被篡改，需进一步排查处理。\n访问控制：\n严格设置数据的访问权限，依据用户角色、权限级别等因素，只允许授权人员对数据进行读写等操作，限制非授权访问，从源头上减少数据被篡改的风险。\n监控与告警：\n搭建数据状态的监控系统，实时关注数据传输、存储过程中的相关指标，如数据流量变化、加密状态、完整性校验结果等，一旦发现疑似数据篡改的异常情况，及时触发告警，通知安全运维人员进行深入调查和修复。\n备份恢复：\n制定合理的数据备份策略，定期对重要数据进行备份，存储在独立、安全的介质或位置，当发现数据被篡改时，可利用备份数据进行恢复，最大程度降低篡改带来的损失。"
        },
        "test_case": {
          "name": "篡改",
          "details": "测试方法：使用 Fiddler 抓包，检查传输过程中敏感数据是否进行了加密。\n预期结果：使用非 MD5、base64等弱加密算法。"
        },
        "industry_standard": null
      },
      {
        "name": "敏感信息泄露",
        "details": "",
        "security_requirement": {
          "name": "敏感信息泄露",
          "details": "确保系统能够有效保护敏感信息，防止敏感信息泄露。"
        },
        "security_design": {
          "name": "敏感信息泄露",
          "details": "信息加密处理：\n运用强加密算法对敏感信息加密，如对称加密的 AES、非对称加密的 RSA 等，存储与传输时均保持加密状态，让攻击者难以获取明文内容，保障信息安全。\n访问严格管控：\n按角色、业务需求划分访问权限，实施多因素认证，像密码加指纹识别等，仅授权人员可接触敏感信息，杜绝越权访问引发泄露。\n监控预警机制：\n搭建监控系统，实时监测信息访问、传输情况，一旦有异常操作，如高频访问、异地访问等，及时发出警报并阻断，快速应对泄露隐患。"
        },
        "test_case": {
          "name": "敏感信息泄露",
          "details": "测试方法：\n1、是否使用HTTPS协议。\n2、应用系统界面关键地方如个人信息页面中的个人数据、财务信息等敏感信息是否加星号脱敏了。\n3、通过Fiddler抓包查看所有请求包、响应包中是否对敏感字段加密了。敏感字读如：name、phone、key、id等。\n预期结果：使用 HTTPS 协议传输；敏感信息在传输和存储时进行了加密或脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "拒绝服务攻击",
        "details": "",
        "security_requirement": {
          "name": "拒绝服务攻击",
          "details": "确保系统能够有效防止拒绝服务攻击，保护系统的可用性和稳定性。"
        },
        "security_design": {
          "name": "拒绝服务攻击",
          "details": "输入验证强化：\n开发时对所有外部输入进行严格校验，包括数据格式、长度、类型等。例如对用户提交的表单数据、API 传入参数，通过正则表达式与数据类型检查确保其合法性，杜绝恶意构造的输入引发系统异常或资源耗尽，从而抵御攻击。\n并发控制策略：\n精心设计并发处理逻辑，利用线程池、信号量等技术限制同时处理的请求数量。依据系统硬件资源与正常业务负载，设定合理阈值，防止大量并发恶意请求使系统资源耗尽而瘫痪，保障服务稳定运行。\n资源监控与限制：\n在代码中嵌入资源监控模块，实时跟踪 CPU、内存、磁盘 I/O 等关键资源的使用情况。一旦资源使用接近危险阈值，自动限制非关键业务的资源分配，优先保障核心业务运行，避免因资源被恶意占用导致系统不可用。\n缓存机制优化：\n优化缓存策略，对频繁访问的数据进行合理缓存，设置缓存有效期与容量限制。既减少重复计算与数据库查询，提升系统响应速度，又防止缓存被恶意数据填满，影响正常业务数据缓存，保障系统高效稳定运行。\n异常处理完善：\n构建全面的异常处理体系，对于可能出现的各类异常情况，如网络中断、数据库连接失败、资源不足等，进行优雅处理。避免因未处理的异常导致系统崩溃或陷入无限循环，增强系统在面对异常与攻击时的韧性。\n代码模块化与隔离：\n将系统功能进行合理模块化，不同模块间设置清晰的边界与访问权限。当某个模块遭受攻击时，通过隔离机制限制影响范围，防止恶意攻击蔓延至整个系统，确保其他模块仍能正常提供服务，维持系统整体可用性。"
        },
        "test_case": {
          "name": "拒绝服务攻击",
          "details": "测试方法：功能测试压力测试"
        },
        "industry_standard": null
      },
      {
        "name": "角色权限提升",
        "details": "",
        "security_requirement": {
          "name": "角色权限提升",
          "details": "防止未经授权的用户获取系统中的高级权限或访问权限。\n加强对权限提升漏洞的识别和修复，及时堵塞潜在的安全漏洞。"
        },
        "security_design": {
          "name": "角色权限提升",
          "details": "权限分级与隔离：\n对系统内的权限进行细致分级，明确划分普通权限、中级权限、高级权限等不同层级，将不同层级权限对应的功能与资源严格隔离，确保低级别权限用户无法轻易触及高级权限相关内容，从架构层面防止权限的随意提升。\n身份验证强化：\n采用多因素身份验证手段，如在关键操作或涉及权限提升场景下，除常规用户名和密码外，增加指纹识别、动态口令、手机验证码等额外认证因素，全方位核实用户身份，提高非法获取高权限的门槛，避免未经授权用户提升权限。\n权限提升漏洞管理：\n定期开展全面的系统安全检测，运用专业的漏洞扫描工具以及人工渗透测试等方式，深度排查可能导致权限提升的各类漏洞，如权限绕过漏洞、越权访问漏洞等，建立详细的漏洞台账，对发现的漏洞及时安排修复，确保系统的安全性。\n行为监测与预警：\n搭建权限使用行为监测系统，实时关注用户在系统内的操作行为，尤其针对涉及权限变更、权限提升相关操作进行重点监测，一旦发现异常行为，例如低权限用户频繁尝试访问高级权限资源、短时间内出现不符合常规逻辑的权限提升请求等情况，立即触发预警机制，及时通知安全运维人员进行处置，防止未经授权的权限提升行为得逞。"
        },
        "test_case": {
          "name": "角色权限提升",
          "details": "测试方法：使用普通用户访问管理员特有的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "短信发送": {
    "threats": [
      {
        "name": "篡改",
        "details": "",
        "security_requirement": {
          "name": "篡改",
          "details": "确保系统能够防止数据在传输或存储过程中被篡改，保护数据的完整性和准确性。"
        },
        "security_design": {
          "name": "篡改",
          "details": "传输加密：\n在数据传输阶段，采用强加密算法（如 SSL/TLS 协议等）对数据进行加密处理，确保数据在网络通道中以密文形式传输，即使被拦截，攻击者也难以对密文内容进行篡改，保障传输过程的数据完整性。\n存储加密：\n对于存储的数据，使用合适的加密方式（如对称加密、非对称加密等）进行加密存储，只有拥有正确解密密钥的授权主体才能访问原始数据，防止存储过程中数据被非法篡改。\n完整性校验：\n定期或在数据使用前，采用哈希算法（如 SHA-256 等）计算数据的哈希值，并与预先保存的正确哈希值进行比对，若两者不一致，则表明数据可能被篡改，需进一步排查处理。\n访问控制：\n严格设置数据的访问权限，依据用户角色、权限级别等因素，只允许授权人员对数据进行读写等操作，限制非授权访问，从源头上减少数据被篡改的风险。\n监控与告警：\n搭建数据状态的监控系统，实时关注数据传输、存储过程中的相关指标，如数据流量变化、加密状态、完整性校验结果等，一旦发现疑似数据篡改的异常情况，及时触发告警，通知安全运维人员进行深入调查和修复。\n备份恢复：\n制定合理的数据备份策略，定期对重要数据进行备份，存储在独立、安全的介质或位置，当发现数据被篡改时，可利用备份数据进行恢复，最大程度降低篡改带来的损失。"
        },
        "test_case": {
          "name": "篡改",
          "details": "测试方法：使用 Fiddler 抓包，检查传输过程中敏感数据是否进行了加密。\n预期结果：使用非 MD5、base64等弱加密算法。"
        },
        "industry_standard": null
      },
      {
        "name": "敏感信息泄露",
        "details": "",
        "security_requirement": {
          "name": "敏感信息泄露",
          "details": "确保系统能够有效保护敏感信息，防止敏感信息泄露。"
        },
        "security_design": {
          "name": "敏感信息泄露",
          "details": "信息加密处理：\n运用强加密算法对敏感信息加密，如对称加密的 AES、非对称加密的 RSA 等，存储与传输时均保持加密状态，让攻击者难以获取明文内容，保障信息安全。\n访问严格管控：\n按角色、业务需求划分访问权限，实施多因素认证，像密码加指纹识别等，仅授权人员可接触敏感信息，杜绝越权访问引发泄露。\n监控预警机制：\n搭建监控系统，实时监测信息访问、传输情况，一旦有异常操作，如高频访问、异地访问等，及时发出警报并阻断，快速应对泄露隐患。"
        },
        "test_case": {
          "name": "敏感信息泄露",
          "details": "测试方法：\n1、是否使用HTTPS协议。\n2、应用系统界面关键地方如个人信息页面中的个人数据、财务信息等敏感信息是否加星号脱敏了。\n3、通过Fiddler抓包查看所有请求包、响应包中是否对敏感字段加密了。敏感字读如：name、phone、key、id等。\n预期结果：使用 HTTPS 协议传输；敏感信息在传输和存储时进行了加密或脱敏。"
        },
        "industry_standard": null
      },
      {
        "name": "拒绝服务攻击",
        "details": "",
        "security_requirement": {
          "name": "拒绝服务攻击",
          "details": "确保系统能够有效防止拒绝服务攻击，保护系统的可用性和稳定性。"
        },
        "security_design": {
          "name": "拒绝服务攻击",
          "details": "输入验证强化：\n开发时对所有外部输入进行严格校验，包括数据格式、长度、类型等。例如对用户提交的表单数据、API 传入参数，通过正则表达式与数据类型检查确保其合法性，杜绝恶意构造的输入引发系统异常或资源耗尽，从而抵御攻击。\n并发控制策略：\n精心设计并发处理逻辑，利用线程池、信号量等技术限制同时处理的请求数量。依据系统硬件资源与正常业务负载，设定合理阈值，防止大量并发恶意请求使系统资源耗尽而瘫痪，保障服务稳定运行。\n资源监控与限制：\n在代码中嵌入资源监控模块，实时跟踪 CPU、内存、磁盘 I/O 等关键资源的使用情况。一旦资源使用接近危险阈值，自动限制非关键业务的资源分配，优先保障核心业务运行，避免因资源被恶意占用导致系统不可用。\n缓存机制优化：\n优化缓存策略，对频繁访问的数据进行合理缓存，设置缓存有效期与容量限制。既减少重复计算与数据库查询，提升系统响应速度，又防止缓存被恶意数据填满，影响正常业务数据缓存，保障系统高效稳定运行。\n异常处理完善：\n构建全面的异常处理体系，对于可能出现的各类异常情况，如网络中断、数据库连接失败、资源不足等，进行优雅处理。避免因未处理的异常导致系统崩溃或陷入无限循环，增强系统在面对异常与攻击时的韧性。\n代码模块化与隔离：\n将系统功能进行合理模块化，不同模块间设置清晰的边界与访问权限。当某个模块遭受攻击时，通过隔离机制限制影响范围，防止恶意攻击蔓延至整个系统，确保其他模块仍能正常提供服务，维持系统整体可用性。"
        },
        "test_case": {
          "name": "拒绝服务攻击",
          "details": "测试方法：功能测试压力测试"
        },
        "industry_standard": null
      },
      {
        "name": "角色权限提升",
        "details": "",
        "security_requirement": {
          "name": "角色权限提升",
          "details": "防止未经授权的用户获取系统中的高级权限或访问权限。\n加强对权限提升漏洞的识别和修复，及时堵塞潜在的安全漏洞。"
        },
        "security_design": {
          "name": "角色权限提升",
          "details": "权限分级与隔离：\n对系统内的权限进行细致分级，明确划分普通权限、中级权限、高级权限等不同层级，将不同层级权限对应的功能与资源严格隔离，确保低级别权限用户无法轻易触及高级权限相关内容，从架构层面防止权限的随意提升。\n身份验证强化：\n采用多因素身份验证手段，如在关键操作或涉及权限提升场景下，除常规用户名和密码外，增加指纹识别、动态口令、手机验证码等额外认证因素，全方位核实用户身份，提高非法获取高权限的门槛，避免未经授权用户提升权限。\n权限提升漏洞管理：\n定期开展全面的系统安全检测，运用专业的漏洞扫描工具以及人工渗透测试等方式，深度排查可能导致权限提升的各类漏洞，如权限绕过漏洞、越权访问漏洞等，建立详细的漏洞台账，对发现的漏洞及时安排修复，确保系统的安全性。\n行为监测与预警：\n搭建权限使用行为监测系统，实时关注用户在系统内的操作行为，尤其针对涉及权限变更、权限提升相关操作进行重点监测，一旦发现异常行为，例如低权限用户频繁尝试访问高级权限资源、短时间内出现不符合常规逻辑的权限提升请求等情况，立即触发预警机制，及时通知安全运维人员进行处置，防止未经授权的权限提升行为得逞。"
        },
        "test_case": {
          "name": "角色权限提升",
          "details": "测试方法：使用普通用户访问管理员特有的功能或资源/URL，观察能否访问成功。\n预期结果：提示访问失败或身份认证失败。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "短信验证码": {
    "threats": [
      {
        "name": "短信验证码安全",
        "details": "",
        "security_requirement": {
          "name": "短信验证码安全",
          "details": "保障短信验证码从生成、传输、存储到校验全流程的保密性、完整性及有效性，防止验证码被预测、窃取、篡改、重复使用等情况"
        },
        "security_design": {
          "name": "短信验证码安全",
          "details": "验证码长度要求：\n设置验证码长度要求为不少于6位。较长的验证码长度可以增加密码的强度，提高安全性。\n随机验证码生成算法：\n使用安全的随机数生成算法（如SecureRandom）生成随机验证码，确保生成的验证码具有足够的复杂性和随机性。\n验证码校验：\n应该判断短信验证码的发送手机号是否为用户绑定的手机号码，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中。\n防止验证码重复使用：\n在校验成功后，立即从存储介质中删除该验证码，或者将其标记为已使用，防止同一个验证码被重复使用。\n验证码频率限制：\n为防止短信炸弹攻击，应该限制短信验证码的发送时间间隔和次数，建议间隔时间大于60s。\n验证码过期或错误：\n规定短信验证码的有效时间和输入错误次数，通常情况下有效时间不长于60s，失效后需重新获取验证码；输入错误次数不高于3次，超出后锁定账号5分钟。"
        },
        "test_case": {
          "name": "短信验证码安全",
          "details": "测试方法：使用抓包工具检查请求和响应包，查看是否有验证码以明文或弱加密方式出现；使用相同验证码多次校验、验证码超时后校验、频繁多次输入错误验证码，并观察应用程序的响应。\n预期结果：在响应包和源码中没有发现短信验证码以明文或弱加密方式出现；验证码校验成功或失败。"
        },
        "industry_standard": null
      }
    ]
  },
  "转发": {
    "threats": [
      {
        "name": "输入验证绕过",
        "details": "",
        "security_requirement": {
          "name": "输入验证绕过",
          "details": "对输入的内容需要校验或检测，防止恶意内容被写入或被执行。"
        },
        "security_design": {
          "name": "输入验证绕过",
          "details": "严格格式验证：\n规定输入内容的格式要求，像限定字符类型、长度等，用正则表达式等工具核查，不符合格式的输入直接拒绝，防止恶意构造的内容混入，如限定邮箱格式，不符则拦下。\n敏感字符过滤：\n梳理出如 SQL 注入、脚本攻击等常用的敏感字符及语句，在输入环节就将其过滤，避免恶意内容被写入数据库或在页面执行，保障系统安全。\n语义分析检测：\n对输入内容进行语义分析，判断其逻辑合理性，识别出看似正常实则隐藏恶意目的的内容，不让其通过验证，防止被写入或执行造成危害。"
        },
        "test_case": {
          "name": "输入验证绕过",
          "details": "测试方法：尝试在输入功能处输入一些不寻常或不正确的内容，比如很长的字符串（.......................................）、特殊符号(（' 、 \"）、`（'<' 和 '>'）、斜杠（/）、反斜杠（\\）、单引号（'）和双引号（\" )或者不是预期类型的数据（<script>、alert('XSS')、;ls、' OR '1'='1、$(ls))。然后观察应用程序是如何处理这些输入的。\n预期结果：输入特殊字符后，页面正常响应或者显示输入的信息非法。"
        },
        "industry_standard": {
          "name": "鉴别数据保护",
          "details": null
        }
      },
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": null
      }
    ]
  },
  "桌面客户端（针对新上线）": {
    "threats": [
      {
        "name": "安全审计",
        "details": "",
        "security_requirement": {
          "name": "安全审计",
          "details": "1. 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；\n2. 应确保审计记录的留存时间符合法律法规要求"
        },
        "security_design": {
          "name": "安全审计",
          "details": "审计记录保护机制：\n采用访问控制技术，对存储审计记录的系统或数据库设置严格的权限管理，仅允许授权人员进行查看、操作，防止非授权的删除、修改或覆盖行为。\n运用加密技术对审计记录进行加密存储，保障记录内容的保密性，即使数据遭遇非法获取，也难以被篡改或解读。\n定期备份策略：\n制定合理的备份计划，按照固定周期（如每日、每周等）对审计记录进行全量或增量备份，备份数据存储在独立的、安全的存储介质或异地存储中心，避免因本地故障导致数据丢失。\n在备份过程中，进行完整性校验，确保备份的数据与原始审计记录完全一致，防止出现备份数据损坏的情况。\n法规遵从核查：\n密切关注并及时掌握与审计记录留存时间相关的法律法规要求，根据业务性质和所在地区等因素，明确自身应遵守的具体时长标准。\n建立定期自查机制，定期检查审计记录的留存情况，对比法规要求，确保实际留存时间能够满足相应规定，避免出现合规风险。\n监控与告警：\n搭建针对审计记录的监控系统，实时跟踪记录的状态变化（如是否有异常访问、修改操作等）、备份执行情况以及留存时间进度等关键指标。\n当发现存在违反审计记录保护要求、备份异常或留存时间不足等问题时，及时触发告警信息，通知相关责任人员进行处理，保障安全审计工作的有效开展。"
        },
        "test_case": {
          "name": "安全审计",
          "details": "测试方法：执行一些敏感或关键操作（如登录、数据修改等）以触发审计记录，检查系统的审计记录，确认操作是否被完整、准确地记录。\n预期结果：重要的操作日志能被详细的记录。"
        },
        "industry_standard": {
          "name": "网安第四章第四十二条第一款",
          "details": null
        }
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      },
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": null
      }
    ]
  },
  "资料访问控制": {
    "threats": [
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": {
          "name": "数据存储",
          "details": null
        }
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": {
          "name": "访问控制",
          "details": null
        }
      }
    ]
  },
  "资料加密传输": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "中间人攻击",
        "details": "",
        "security_requirement": {
          "name": "中间人攻击",
          "details": "确保系统能够有效防止中间人攻击，保护通信安全。"
        },
        "security_design": {
          "name": "中间人攻击",
          "details": "加密通信：\n采用如 SSL/TLS 等强加密协议建立通信通道，让传输的数据以密文形式存在，即便被中间人拦截，也难以获取明文内容，像网站登录时启用 https 保障账号密码传输安全。\n身份验证：\n强化双向身份验证机制，通信双方互相核实身份，例如通过数字证书确认对方是否合法真实，避免中间人伪装成合法一方介入通信，从源头杜绝攻击可能。\n监测预警：\n部署网络监测工具，实时留意通信流量、连接状态等情况，一旦发现异常，像延迟过高、频繁重连等疑似中间人攻击迹象，及时发出预警并采取阻断等应对措施，保障通信安全。\n"
        },
        "test_case": {
          "name": "中间人攻击",
          "details": "测试方法：1、使用了 HTTPS 协议传输；2、使用 testssl（https://github.com/drwetter/testssl.sh.git）检查 TLS 版本。\n预期结果：1、启用了 HTTP 协议传输；2、使用了安全的 TLS 版本（TLS 1.2或 TLS 1.3）"
        },
        "industry_standard": null
      }
    ]
  },
  "领券": {
    "threats": [
      {
        "name": "领券场景威胁",
        "details": "自动化脚本滥用：攻击者使用自动化脚本或软件模拟用户行为，绕过正常用户行为限制，批量领取优惠券。\n群控设备滥用：利用群控设备（例如控制大量手机或其他终端设备）同时进行领券操作，短时间内大规模领取优惠券。\n假用户行为模拟：攻击者利用伪造的账户或虚假行为模拟真实用户行为，达到无效任务完成、虚假领取优惠券的目的。\n优惠券交易市场形成：通过非法手段积累大量优惠券后，攻击者在二级市场上进行转卖或交易，获取不正当利益。",
        "security_requirement": {
          "name": "领券场景安全需求",
          "details": "防止自动化脚本攻击：\n应设计防止脚本模拟用户行为的机制，例如引入验证码、滑动验证、行为分析等技术手段，避免程序化操作。\n应监控异常行为，如短时间内的大量领取请求等，实时检测并阻止此类活动。\n防止群控设备滥用：\n采用设备指纹识别技术或IP地址频率限制，检测和防止大规模设备同时进行相同操作。\n实现设备注册、登录限流和监控，检测相似或同一设备组的异动。\n限制虚假账户和任务作弊：\n强化账户实名认证机制，增加反作弊手段，例如使用手机验证码验证，实名制或人脸识别。\n使用机器学习模型分析用户行为模式，识别和过滤不正常的行为，避免假用户完成任务。\n禁止非法交易或转卖：\n建立优惠券的使用限制，禁止用户将优惠券转让、转卖，或者在二级市场中交易。\n定期检查优惠券的流转轨迹，发现异常行为时立刻冻结相关账户或优惠券。"
        },
        "security_design": {
          "name": "领券场景安全设计",
          "details": "验证码与行为分析：\n设计验证码系统，用户领取优惠券时要求输入验证码（如滑动解锁或图形验证码），防止自动化脚本模拟操作。\n引入用户行为分析，检测并判断用户是否是正常人类用户，如鼠标移动轨迹、点击频率等。\n设备指纹与登录频率限制：\n引入设备指纹技术，确保每个设备只能进行有限的操作，并对同一设备的频繁请求进行限制。\n对单个IP、设备和账户进行请求频率控制，确保系统公平发放优惠券。\n反作弊与任务有效性校验：\n对用户完成的任务进行有效性校验，确保任务完成真实且符合规则。\n对虚假账户的注册和行为进行监控，防止刷任务、虚假行为等。\n优惠券使用限制与监控：\n在优惠券的使用规则中增加限制，例如限定优惠券只能在特定商品或类别中使用，并设定优惠券有效期。\n设置使用和领取优惠券的监控和日志，确保可以追溯每张优惠券的使用情况，避免违规交易。"
        },
        "test_case": {
          "name": "领券场景测试用例",
          "details": "自动化脚本模拟测试：\n目标：测试系统对自动化脚本的防护能力。\n方法：使用自动化工具模拟用户的领券行为，检查验证码、防刷机制、行为分析是否能够成功识别并阻止自动化脚本。\n预期结果：系统能够识别并阻止自动化脚本，保证优惠券只分发给真实用户。\n群控设备模拟测试：\n目标：测试系统能否识别群控设备的滥用。\n方法：模拟使用多个设备（例如通过模拟器或物理设备）同时发起领券请求，测试系统是否能够识别并限制多个设备的行为。\n预期结果：系统能够有效检测群控设备的操作，并通过设备指纹、IP限流等措施限制其操作。\n虚假账户与任务作弊测试：\n目标：验证系统对虚假账户和作弊行为的检测能力。\n方法：创建虚假账户并尝试完成任务，测试系统是否能识别并阻止。\n预期结果：系统能够有效识别虚假账户，并拒绝其领取优惠券。\n优惠券滥用监控测试：\n目标：验证优惠券交易与使用限制。\n方法：尝试通过不同的渠道或账户进行优惠券转卖或非法交易，检查系统是否能够及时检测和阻止。\n预期结果：系统能够实时监控和记录优惠券的流转轨迹，发现违规行为时能够及时冻结优惠券。"
        },
        "industry_standard": null
      },
      {
        "name": "未接入互联网行为风控系统",
        "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统",
        "security_requirement": {
          "name": "接入互联网行为风控系统",
          "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统。"
        },
        "security_design": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "test_case": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》测试是否已接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "industry_standard": null
      }
    ]
  },
  "注册": {
    "threats": [
      {
        "name": "注册弱密码",
        "details": "由于应用系统的相关用户的安全意识薄弱，同时应用系统并未有效的强制性密码策略要求，从而将可能存在弱口令用户，攻击者可轻易通过字典猜解的方式获得用户的密码并进入应用系统发起进一步攻击。",
        "security_requirement": {
          "name": "密码具有一定复杂度",
          "details": "对用户密码的复杂度进行要求，如：密码应在8位以上，且必须包含数字、大写或小写字母、特殊字符等3种及3种以上组合。"
        },
        "security_design": {
          "name": "注册限制登录密码复杂度",
          "details": "通过正则表达式匹配密码字符串，判断其复杂度。\\r\\n口令设计应当满足以下要求：\\r\\n1. 在设置密码时，要对密码的强度进行约束，在客户端使用JavaScript脚本检测，服务器端也要对密码强度进行检测。密码长度至少6位字符，最多不超过16位，其中应大写字母、小写字母、数字、特殊字符这四类中至少两类；\\r\\n2. 通过正则表达式判断密码复杂程度，判断其是否是常见的弱口令；\\r\\n3. 判断登录密码是否为初始密码，是则提示用户修改密码，并跳转到密码修改页面，密码未修改，则不能进行其它操作；\\r\\n4. 为保证用户输入口令的安全性，服务器端应对用户口令的复杂度做最终的校验，包括口令复杂度、常见弱口令匹配校验。\\r\\n5. 为减轻服务器端的处理压力，客户端应配合服务器端进行用户密码复杂度检查。"
        },
        "test_case": {
          "name": "注册弱口令测试",
          "details": "访问系统注册页面，使用burpsuite对注册请求进行抓包，将密码替换为仅包含大小写字母、数字、特殊字符中1种的情况，查看响应包是否注册成功。"
        },
        "industry_standard": {
          "name": "JR/T0071.2/2020 8.1.4.1身份鉴别",
          "details": null
        }
      },
      {
        "name": "批量注册",
        "details": "由于注册过程中没有进行频率限制，导致攻击者批量注册账号。",
        "security_requirement": {
          "name": "限制注册频率",
          "details": "需检查同一 IP 注册频率，针对同一 IP 注册数量设置每日最大上限，同时增加注册验证码或一次性token机制，并检查同一邮箱/手机号或其他唯一标识是否已被注册或绑定。"
        },
        "security_design": {
          "name": "限制注册频率",
          "details": "重要的业务系统和重要的业务场景，防止来自攻击者的业务攻击行为（如恶意注册、恶意绑定数据），建议使用交互式图形验证码，提高攻击成本，缓解因安全问题导致的损失。 交互式验证码也称“行为式验证码”，主要分为拖动式和点触式。"
        },
        "test_case": {
          "name": "注册频率限制测试",
          "details": "1. 编写自动提交HTTP数据包的脚本；\\r\\n2. 或使用burpsuite的intruder功能批量提交请求。"
        },
        "industry_standard": {
          "name": "JR/T  0213/2021：5.3.3.2 d）",
          "details": null
        }
      },
      {
        "name": "通过破解登录密码导致交易密码丢失",
        "details": "由于设置交易密码时没有限制交易密码与登录密码的相关性，用户可以将交易密码与登录密码设置为同一字符串，导致攻击者可以通过暴力破解的手段获取用户登录密码，从而实现交易等敏感操作。",
        "security_requirement": {
          "name": "交易密码具有一定复杂度",
          "details": "系统强制用户区分登录密码和交易密码。"
        },
        "security_design": {
          "name": "限制交易密码复杂度",
          "details": "设置交易密码时，须验证用户身份，并判断提交交易密码密文与数据库中查询到的该账户的登录密文是否相同，相同则提示用户更换密码，不同则执行更新操作；"
        },
        "test_case": {
          "name": "交易密码复杂度测试",
          "details": "在设置或修改交易密码功能点尝试将支付密码修改为登录密码，观察是否能够成功修改。"
        },
        "industry_standard": {
          "name": "JR/T  0068/2020：6.4.2.1 f）",
          "details": null
        }
      },
      {
        "name": "密码明文存储",
        "details": "明文存储口令会降低攻击的难度，攻击者若获得访问口令存储文件的权限，便可轻易获取口令。",
        "security_requirement": {
          "name": "密码加密存储",
          "details": "数据库中用户密码信息应为密文存储。"
        },
        "security_design": {
          "name": "密码加密存储",
          "details": "对敏感或者重要数据进行加密保护，优先选择加密机对系统数据进行加密处理，在无法提供加密机的情况下，系统中不得使用已经被证明为不安全的算法或者自定义不安全算法进行用户数据加密，包括MD5等算法。\\r\\n在选择加密算法时，应根据具体应用场景选择对应安全的加密算法。\\r\\n|算法类型|填充模式|推荐算法|推荐应用场景|\\r\\n|----------------|-----------------|---------------------------------------|------------------------|\\r\\n|对称加密算法|ECB/CBC/CFB/OFB|SM4|(128位)、AES（128位/192位/256位）|交易数据传输、口令传输|\\r\\n|非对称加密算法|---|SM2（256位）、RSA（2048位）|身份认证、交易密码传输|\\r\\n|哈希算法|---|SM3、SHA256|数据库中密码存储|"
        },
        "test_case": {
          "name": "密码存储测试",
          "details": "使用数据库工具连接存储用户密码的数据库，观察存储方式。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3  a)",
          "details": null
        }
      },
      {
        "name": "本地存储导致的敏感信息泄露",
        "details": "API接口查询后如果将数据存储至本地存在较大的风险",
        "security_requirement": {
          "name": "客户侧敏感信息存储保护",
          "details": "对于金融产品持有份额用户积分等A2类只读信息查询，可使用API直接连接方式进行査询请求对接，应采取加密等措施保证査询信息的完整性与保密性，査询结果在应用方本地不得保存"
        },
        "security_design": {
          "name": "客户侧敏感信息存储保护",
          "details": "使用HTTPS协议传输，使用安全的算法对查询请求和返回的数据进行加密处理，使用数字签名等方式进行完整性保护。"
        },
        "test_case": {
          "name": "客户侧敏感信息存储测试",
          "details": "通过访谈方式，确定应用方是否保存查询结果。通过使用抓包工具等，测试验证查询信息在传输中是否是加密状态。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.2.2",
          "details": null
        }
      },
      {
        "name": "合规威胁",
        "details": "合规威胁",
        "security_requirement": {
          "name": "应用和数据安全需求",
          "details": "参考《信息系统密码应用基本要求》《信息系统密码应用高风险判定指引》第五章：通用要求和第九章： 应用和数据安全"
        },
        "security_design": {
          "name": "应用和数据安全",
          "details": "参考《信息系统密码应用基本要求》《信息系统密码应用高风险判定指引》第五章：通用要求和第九章： 应用和数据安全"
        },
        "test_case": {
          "name": "加密安全测试",
          "details": "通过访谈的方式确认加密算法是否满足要求。"
        },
        "industry_standard": null
      },
      {
        "name": "合规威胁",
        "details": "合规威胁",
        "security_requirement": {
          "name": "应用和数据安全需求",
          "details": "参考《信息系统密码应用基本要求》《信息系统密码应用高风险判定指引》第五章：通用要求和第九章： 应用和数据安全"
        },
        "security_design": {
          "name": "应用和数据安全",
          "details": "参考《信息系统密码应用基本要求》《信息系统密码应用高风险判定指引》第五章：通用要求和第九章： 应用和数据安全"
        },
        "test_case": {
          "name": "加密安全测试",
          "details": "通过访谈的方式确认加密算法是否满足要求。"
        },
        "industry_standard": null
      },
      {
        "name": "短信炸弹",
        "details": "攻击者通过网站页面中所提供的发送短信验证码的功能处，通过对其发送数据包的获取后，进行重放，如果服务器短信平台未做校验的情况时，系统会一直去发送短信，这样就造成了短信轰炸的漏洞。",
        "security_requirement": {
          "name": "限制短信发送频率",
          "details": "有效限制单位时间内的短信验证码获取次数，避免同一用户单位时间内不停收到短信。"
        },
        "security_design": {
          "name": "限制短信发送频率",
          "details": "合理配置后台短信服务器的功能，对于同一手机号码，一定时间内发送次数不超过3-5次，并且可对发送的时间间隔做限制。"
        },
        "test_case": {
          "name": "短信轰炸测试1",
          "details": "1.手工找到有关网站注册页面，认证页面，是否具有短信发送页面，如果有，则进行下一步。 2.通过利用burp或者其它抓包截断工具，抓取发送验证码的数据包，并且进行重放攻击，查看手机是否在短时间内连续收到100条以上短信，如果收到大量短信，则说明存在该漏洞。"
        },
        "industry_standard": {
          "name": "JR/T  0213/2021：5.3.2.10 j）",
          "details": null
        }
      },
      {
        "name": "短信滥用",
        "details": "攻击者通过网站页面中所提供的发送短信验证码的功能处，通过对其发送数据包的获取后，遍历手机号并进行重放，如果服务器短信平台未做校验的情况时，系统会一直去发送短信，导致单位时间内多个用户不停收到短信。",
        "security_requirement": {
          "name": "防重放",
          "details": "获取短信验证码时，采用图形验证码或token方式，防止恶意用户通过重放短信请求的方式消耗短信资源。"
        },
        "security_design": {
          "name": "防重放",
          "details": "1、在用户请求发送短信验证码时，可以在前端界面上显示一个图形验证码。用户需要正确识别并输入图形验证码才能继续发送短信验证码。2、在发送短信验证码之前，系统可以生成一个随机的Token，并将该Token与用户的请求一起发送到后端服务器。后端服务器验证Token的正确性，如果验证通过，则发送短信验证码到用户的手机。3、设置短信验证码的发送频率限制，例如每分钟最多发送一次或每个IP地址最多发送一定数量的短信验证码。"
        },
        "test_case": {
          "name": "短信轰炸测试2",
          "details": "1.手工找到有关网站注册页面，认证页面，是否具有短信发送页面，如果有，则进行下一步。 2.通过利用burp或者其它抓包截断工具，抓取发送验证码的数据包，并且进行重放攻击，查看手机是否在短时间内连续收到100条以上短信，如果收到大量短信，则说明存在该漏洞。"
        },
        "industry_standard": {
          "name": "JR/T  0213/2021：5.3.2.10 j）",
          "details": null
        }
      },
      {
        "name": "短信滥用",
        "details": "攻击者通过网站页面中所提供的发送短信验证码的功能处，通过对其发送数据包的获取后，遍历手机号并进行重放，如果服务器短信平台未做校验的情况时，系统会一直去发送短信，导致单位时间内多个用户不停收到短信。",
        "security_requirement": {
          "name": "手机号码与用户身份一致性验证",
          "details": "服务端在验证短信验证码时，应防止越权校验： 1）短信验证码应与手机号码一对一绑定； 2）验证短信验证码时，如果和手机号码一起验证，手机号码信息应从服务端获取。 3）如果手机号码通过客户端传送，服务端应对手机号码进行校验，校验失败后，记录错误日志信息，内容至少包括时间、用户、IP、校验失败的手机号码。"
        },
        "security_design": {
          "name": "验证用户身份",
          "details": "在发送短信前先检测手机号与用户身份是否一致，检测通过后发送短信验证码。"
        },
        "test_case": {
          "name": "短信轰炸测试3",
          "details": "1.手工找到具有短信发送功能的页面。 \\r\\n\n2.通过利用burp或者其它抓包截断工具，抓取发送验证码的数据包，修改手机号，并且进行重放攻击，查看手机是否在短时间内连续收到100条以上短信，如果收到大量短信，则说明存在该漏洞。"
        },
        "industry_standard": null
      },
      {
        "name": "短信验证码明文返回前端页面",
        "details": "由于短信验证码生成后直接以明文形式返回到前端，导致攻击者可以通过抓包的方式获取到生成的短信验证码从而实现短信验证码的绕过。",
        "security_requirement": {
          "name": "图形验证码应由服务器生成并校验",
          "details": "发送短信验证码后，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中"
        },
        "security_design": {
          "name": "短信验证码安全",
          "details": "验证码长度要求：\n设置验证码长度要求为不少于6位。较长的验证码长度可以增加密码的强度，提高安全性。\n随机验证码生成算法：\n使用安全的随机数生成算法（如SecureRandom）生成随机验证码，确保生成的验证码具有足够的复杂性和随机性。\n验证码校验：\n应该判断短信验证码的发送手机号是否为用户绑定的手机号码，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中。\n防止验证码重复使用：\n在校验成功后，立即从存储介质中删除该验证码，或者将其标记为已使用，防止同一个验证码被重复使用。\n验证码频率限制：\n为防止短信炸弹攻击，应该限制短信验证码的发送时间间隔和次数，建议间隔时间大于60s。\n验证码过期或错误：\n规定短信验证码的有效时间和输入错误次数，通常情况下有效时间不长于60s，失效后需重新获取验证码；输入错误次数不高于3次，超出后锁定账号5分钟。"
        },
        "test_case": {
          "name": "短信验证码安全测试",
          "details": "1.手工找到具有短信发送功能的页面。 \\r\\n 2.通过利用burp或者其它抓包截断工具，抓取发送验证码的数据包，发送后截取返回包，观察返回包中是否包含明文的短信验证码。"
        },
        "industry_standard": null
      },
      {
        "name": "短信验证码重复使用",
        "details": "当网站或应用程序使用短信验证码进行身份验证时，如果存在重复使用漏洞，攻击者可以利用该漏洞重复使用已经接收到的验证码，进行多次的登录或验证操作，而无需再次发送新的验证码。",
        "security_requirement": {
          "name": "短信验证码在使用完毕后应立刻失效",
          "details": "手机短信码验证校验成功后立即将该验证码失效。"
        },
        "security_design": {
          "name": "短信验证码安全",
          "details": "验证码长度要求：\n设置验证码长度要求为不少于6位。较长的验证码长度可以增加密码的强度，提高安全性。\n随机验证码生成算法：\n使用安全的随机数生成算法（如SecureRandom）生成随机验证码，确保生成的验证码具有足够的复杂性和随机性。\n验证码校验：\n应该判断短信验证码的发送手机号是否为用户绑定的手机号码，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中。\n防止验证码重复使用：\n在校验成功后，立即从存储介质中删除该验证码，或者将其标记为已使用，防止同一个验证码被重复使用。\n验证码频率限制：\n为防止短信炸弹攻击，应该限制短信验证码的发送时间间隔和次数，建议间隔时间大于60s。\n验证码过期或错误：\n规定短信验证码的有效时间和输入错误次数，通常情况下有效时间不长于60s，失效后需重新获取验证码；输入错误次数不高于3次，超出后锁定账号5分钟。"
        },
        "test_case": {
          "name": "短信验证码复用测试",
          "details": "1.手工找到具有短信发送功能的页面。 \\r\\n\n2.通过利用burp或者其它抓包截断工具，抓取校验验证码的数据包，并且进行重放攻击，观察同一个短信验证码是否能使用多次。"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.2.4 e）",
          "details": null
        }
      },
      {
        "name": "短信验证码明文返回前端页面",
        "details": "由于短信验证码生成后直接以明文形式返回到前端，导致攻击者可以通过抓包的方式获取到生成的短信验证码从而实现短信验证码的绕过。",
        "security_requirement": {
          "name": "图形验证码应由服务器生成并校验",
          "details": "发送短信验证码后，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中"
        },
        "security_design": {
          "name": "短信验证码安全",
          "details": "验证码长度要求：\n设置验证码长度要求为不少于6位。较长的验证码长度可以增加密码的强度，提高安全性。\n随机验证码生成算法：\n使用安全的随机数生成算法（如SecureRandom）生成随机验证码，确保生成的验证码具有足够的复杂性和随机性。\n验证码校验：\n应该判断短信验证码的发送手机号是否为用户绑定的手机号码，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中。\n防止验证码重复使用：\n在校验成功后，立即从存储介质中删除该验证码，或者将其标记为已使用，防止同一个验证码被重复使用。\n验证码频率限制：\n为防止短信炸弹攻击，应该限制短信验证码的发送时间间隔和次数，建议间隔时间大于60s。\n验证码过期或错误：\n规定短信验证码的有效时间和输入错误次数，通常情况下有效时间不长于60s，失效后需重新获取验证码；输入错误次数不高于3次，超出后锁定账号5分钟。"
        },
        "test_case": {
          "name": "短信验证码安全测试",
          "details": "1.手工找到具有短信发送功能的页面。 \\r\\n 2.通过利用burp或者其它抓包截断工具，抓取发送验证码的数据包，发送后截取返回包，观察返回包中是否包含明文的短信验证码。"
        },
        "industry_standard": null
      },
      {
        "name": "动态密码复杂度",
        "details": "在使用动态密码（如时间戳、事件触发等）进行身份验证时，由于密码的生成规则或验证方式存在缺陷，导致攻击者可以通过猜测、分析或利用漏洞来获取正确的密码，从而绕过身份验证的防护措施。",
        "security_requirement": {
          "name": "动态密码随机生成",
          "details": "手机动态密码应随机产生，长度应不少于6位"
        },
        "security_design": {
          "name": "动态密码安全1",
          "details": "1、随机密码生成算法：使用安全的随机数生成算法（如SecureRandom）生成一个随机密码。确保生成的密码具有足够的复杂性和随机性，以抵御猜测和暴力破解攻击。 2、密码长度要求：设置密码长度要求为不少于6位。较长的密码长度可以增加密码的强度，提高安全性。"
        },
        "test_case": {
          "name": "动态密码复杂度测试",
          "details": "1.手工找到存在动态密码的页面。2、多次调用发送短信验证码等功能，观察生成的动态密码长度以及是否有随机。"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.2.4 c）",
          "details": null
        }
      },
      {
        "name": "动态密码滥用",
        "details": "动态密码在有效期内长时间保持不变，导致攻击者有足够的时间来猜测、分析或利用漏洞来获取正确的密码。",
        "security_requirement": {
          "name": "设置动态密码有效期",
          "details": "手机动态密码应具有有效时间，最长不超过6分钟，超过有效时间未使用应立即作废"
        },
        "security_design": {
          "name": "动态密码安全2",
          "details": "1、生成动态密码：在生成动态密码时，同时记录生成的时间戳。这个时间戳记录了密码生成的准确时间。 2、动态密码有效期设置：为生成的动态密码设置一个合理的有效期，例如6分钟。确保密码在有效期内可用。 3、校验动态密码有效性：在校验动态密码时，检查当前时间与生成时间戳之间的时间差是否超过设定的有效期。如果密码已经过期，则认为密码无效。"
        },
        "test_case": {
          "name": "动态密码有效期测试",
          "details": "1.手工找到存在动态密码的页面。2、调用发送短信验证码功能，等待10分钟后测试收到的短信验证码是否可用于验证"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.2.4 d）",
          "details": null
        }
      },
      {
        "name": "验证码被猜测",
        "details": "图形验证码中的字符按照某种可预测的模式进行排列，攻击者可以通过分析这种模式来猜测正确的验证码。",
        "security_requirement": {
          "name": "图形验证码随机生成",
          "details": "应随机产生。"
        },
        "security_design": {
          "name": "图形验证码安全1",
          "details": "1、字符集选择：确定用于生成验证码的字符集。通常，字符集包括大写字母、小写字母和数字，并可以包含一些易于识别的特殊字符。 2、验证码长度：确定验证码的长度。一般来说，验证码长度应足够长，以增加猜测的难度和安全性，通常建议至少4个字符。 3、随机字符生成：使用安全的随机数生成算法从所选字符集中随机选择字符，生成验证码。确保生成的字符具有足够的随机性和不可预测性。"
        },
        "test_case": {
          "name": "图片验证码生成规律测试",
          "details": "请求10次观察验证码是否随机生成，如果存在一定的规律（例如5次后出现同一验证码）说明存在漏洞，完成检测"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "验证码可以通过OCR工具自动识别",
        "details": "验证码通常使用一些线条和一些不规则的字符组成，这些字符通常同时包含字母和数字。但有些Web程序设计的验证码较简单，仅由数字或字母组成，且生成的验证码字符排列规整，很容易被程序自动识别。",
        "security_requirement": {
          "name": "图形验证码具有一定干扰措施",
          "details": "应采取图片底纹干扰、颜色变换、设置非连续性及旋转图片字体、变异字体显示样式、交互式认证等有效方式，防止验证码被自动识别。"
        },
        "security_design": {
          "name": "图形验证码安全2",
          "details": "1、图片底纹干扰：在验证码图像的背景中添加随机的干扰元素，如噪点、线条、模糊效果等。2、颜色变换：使用随机的颜色组合来渲染验证码字符或背景。 3、设置非连续性：确保验证码字符在图像上不是连续排列的，而是以非常规的位置和顺序呈现。 4、旋转图片字体：对于验证码的每个字符，将其按照随机角度进行旋转。 5、变异字体显示样式：对于每个验证码字符，使用不同的字体、大小、粗细或斜体等变异样式。"
        },
        "test_case": {
          "name": "图形验证码自动识别测试",
          "details": "使用互联网上可下载的 OCR验证码识别工具、脚本等，测试确认图形验证码无法进行低成本的光学字符识别(OCR）。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "用户图形验证码可重复利用",
        "details": "如果图形验证码使用一次后未刷新，攻击者可在第一次验证失败后利用未刷新的验证码尝试再次验证，从而实现暴力破解。",
        "security_requirement": {
          "name": "图形验证码在使用一次后立刻失效",
          "details": "应具有使用时间限制并仅能使用一次。"
        },
        "security_design": {
          "name": "图形验证码安全3",
          "details": "图形验证码在使用一次后，不论验证成功或失败都立即刷新图形验证码。"
        },
        "test_case": {
          "name": "图形验证码复用测试",
          "details": "1、手工找到存在图形验证码的页面。2、尝试使用错误的图形验证码进行验证，验证失败后观察图形验证码是否刷新。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "验证码泄漏",
        "details": "应用系统的图形验证码是在前端通过JS生成的，攻击者可以很容易的控制图形验证码的生成内容。",
        "security_requirement": {
          "name": "图形验证码服务端处理",
          "details": "图形验证码应由服务器生成，客户端源文件中不应包含验证码文本。"
        },
        "security_design": {
          "name": "图形验证码安全4",
          "details": "1、服务器生成验证码：服务器接收到客户端的请求后，使用安全的随机数生成算法生成一个验证码。确保生成的验证码具有足够的复杂性和随机性。2、验证码图像生成：服务器使用生成的验证码文本，基于一些预定义的样式和参数，生成相应的验证码图像。这个过程可以利用图形库或工具来实现，生成包含验证码的图像。"
        },
        "test_case": {
          "name": "图形验证码生成方式测试",
          "details": "生成的验证码是否可以通过html源代码查看到，如果可以说明存在漏洞，完成检测。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "滑块验证相关风险1",
        "details": "滑块验证码过于简单将导致攻击者通过机器学习算法来分析验证码图片的特征，从而实现自动化破解。",
        "security_requirement": {
          "name": "滑块证码具有一定干扰措施",
          "details": "滑块验证码能够有效防止机器模拟验证。"
        },
        "security_design": {
          "name": "滑块验证码安全1",
          "details": "1、生成滑块验证码：服务器端生成一个包含滑块和背景图像的验证码。2、图像特征设置：在滑块和背景图像上分别设置一些独特的特征，如颜色、纹理、形状等。这些特征用于后续的验证过程。"
        },
        "test_case": {
          "name": "滑块验证码自动识别测试",
          "details": "使用互联网上开源的测试工具进行测试。"
        },
        "industry_standard": {
          "name": "JR/T 0213/2021：5.3.2.12 b）",
          "details": null
        }
      },
      {
        "name": "滑块验证相关风险2",
        "details": "攻击者能够通过某种手段获取到一次滑块验证码，他们可能能够在短时间内尝试多次验证。这增加了账户被攻击的风险。",
        "security_requirement": {
          "name": "滑块验证码在使用一次后立刻失效",
          "details": "滑块验证码认证1次后即刻失效。"
        },
        "security_design": {
          "name": "滑块验证码安全2",
          "details": "在验证码验使用后，立即将该验证码标记为已使用，使其失效。这样确保每个验证码只能使用一次，即使有人试图重复使用该验证码也会被拒绝。"
        },
        "test_case": {
          "name": "滑块验证码复用测试",
          "details": "1.手工找到具有短信发送功能的页面。 \\r\\n\n2.通过利用burp或者其它抓包截断工具，抓取校验验证码的数据包，并且进行重放攻击，观察同一个滑块验证码是否能使用多次。"
        },
        "industry_standard": {
          "name": "JR/T 0213/2021：5.3.2.12 c）",
          "details": null
        }
      },
      {
        "name": "通信内容窃取及篡改",
        "details": "交易数据在通信过程中可能被窃取及篡改",
        "security_requirement": {
          "name": "交易通讯协议安全",
          "details": "应采用每次交易会话采取加密方式对业务数据进行加密处理，防止业务数据被窃取或者篡改。建议使用HTTPS和报文加密方式。"
        },
        "security_design": {
          "name": "HTTPS和端到端报文加密",
          "details": "1.采用HTTPS协议:\n使用TLS/SSL协议来加密在客户端和服务器之间传输的数据。\n确保服务器证书的有效性，以防止中间人攻击。\n2. 端到端报文加密:\n在业务数据传输过程中，使用加密算法对数据进行端到端的加密。\n选择强密码学算法，如AES，以确保高度的加密安全性。\n使用安全的密钥管理和分发机制，例如公钥基础设施（PKI）。"
        },
        "test_case": {
          "name": "交易通讯安全测试",
          "details": "检查HTTPS的部署和配置\n确保应用程序的交互采用HTTPS协议。\n验证SSL证书的有效性。\n\n端到端报文加密测试\n传输包含敏感业务数据的测试报文。\n使用网络抓包工具检查传输的数据是否加密。\n验证加密算法和密钥管理的正确性。"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.3.1 b）",
          "details": null
        }
      },
      {
        "name": "数据篡改或伪造",
        "details": "如果数据在传输过程中没有进行完整性检查，可能会导致数据丢失或损坏，攻击者可能会篡改传输中的数据，可能导致敏感信息泄露、系统被破坏或业务受到损害。",
        "security_requirement": {
          "name": "数据传输完整性",
          "details": "对A1类应用采用MAC校验等手段保证数据传输完整性"
        },
        "security_design": {
          "name": "数据传输完整性",
          "details": "对于 A1 类应采用 MAC校验等手段，保证商业银行与应用方之间数据传输的完整性，必要时可使用数字签名技术。"
        },
        "test_case": {
          "name": "数据传输完整性测试",
          "details": "通过访谈方式，确定数据完整性保护的方式。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.2",
          "details": null
        }
      },
      {
        "name": "数据通讯不可信",
        "details": "如果数据在传输过程中没有进行签名校验，可能导致通讯方否认通信，或数据来源与与预期不一致，可能导致敏感信息泄露、系统被破坏或业务受到损害。",
        "security_requirement": {
          "name": "数据传输可信性",
          "details": "对A2类应用采用数字签名等手段保证数据传输完整性和不可抵赖性"
        },
        "security_design": {
          "name": "数据传输可信性",
          "details": "选择合适的数字签名算法。"
        },
        "test_case": {
          "name": "数据传输可信性测试",
          "details": "通过访谈方式，确定数据可信性保护的方式。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.2",
          "details": null
        }
      },
      {
        "name": "不安全的通信协议",
        "details": "使用不安全低版本的通信协议可能导致数据被窃取或泄露，如敏感信息、个人隐私数据或商业机密等。相关漏洞如：CVE-2016-2183，CVE-2016-6329，CVE-2011-3389，CVE-2013-2566，CVE-2015-2808等。",
        "security_requirement": {
          "name": "使用安全通信协议",
          "details": "应使用SSL/TLS等安全通信技术，应使用相对安全的高版本协议（TLS1.2及以上版本）"
        },
        "security_design": {
          "name": "使用安全通信协议",
          "details": "使用TLSv1.2以上版本安全通信协议。或者更改远程服务安全通信配置，使其不再接受存在漏洞的加密套件；修改SSL/TLS配置，移除弱加密算法，且使其不再接受弱加密套件；厂商主页下载http://www.openssl.org/升级补丁。"
        },
        "test_case": {
          "name": "TLS/SSL测试",
          "details": "使用TLS/SSL命令行测试工具testssl.sh，地址https://github.com/drwetter/testssl.sh，或者在官网https://testssl.sh/ 下载。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.2",
          "details": null
        }
      },
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "输入数据合法性验证",
          "details": "对用户输入信息做过滤，如：检查是否有输入过长、非法字符（包含但不限于< >\" ' % ( ) & + \\ \\' \\\"../等危险特殊字符）、输入不完整、输入值超过上限或者下限等错误，以防止用户输入中包含有恶意字符，引发存SQL注入、XSS等用户输入类漏洞。\n在用户输出阶段，通过语义输出编码方式，对从服务端返回到客户端的数据进行编码。比如HTML编码、URL编码等，编码形式需根据具体的应用场景选择 。"
        },
        "security_design": {
          "name": "输入数据合法性验证",
          "details": "1、必须对所有用户产生的输入进行校验，一旦数据不合法，应该告知用户输入非法并且建议用户纠正输入。2、必须对所有服务器产生的输入进行校验，一旦数据不合法，必须使会话失效，并记录告警日志。"
        },
        "test_case": {
          "name": "SQL注入测试",
          "details": "1.数字型\nhttp://host/test.php?id=100 and 1=1返回成功\nhttp://host/test.php?id=100 and 1=2返回失败\n2.字符型\nhttp://host/test.php?name=rainman’ and‘1’=‘1返回成功\nhttp://host/test.php?name=rainman’ and‘1’=‘2返回失败\n3.搜索型\n搜索型注入：简单的判断搜索型注入漏洞是否存在的办法是：\n先搜索（'），如果出错，说明90%存在这个漏洞。\n然后搜索（%），如果正常返回，说明95%有洞了。 \n然后再搜索一个关键字，比如（2006）吧，正常返回所有2006相关的信息。\n再搜索（2006%'and 1=1 and '%'='）和（2006%'and 1=2 and '%'='）\n4.绕过验证（常见的为管理登陆）也称万能密码\n(1)用户名输入： ‘ or 1=1 or ‘ 密码：任意\n(2)Admin’ - -（或‘ or 1=1 or ‘ - -）(admin or 1=1 --) (MSSQL)(直接输入用户名，不进行密码验证)\n(3)用户名输入：admin 密码输入：’ or ‘1’=’1 也可以\n(4)用户名输入：admin' or 'a'='a 密码输入：任意\n(5)用户名输入：‘ or 1=1 - -\n(6)用户名输入：admin‘ or 1=1 - - 密码输入：任意\n(7)用户名输入：1'or'1'='1'or'1'='1 密码输入：任意\n5.不同的SQL服务器连结字符串的语法不同，比如MSSQLServer使用符号+来连结字符串，而Oracle使用符号||来连结：\nhttp://host/test.jsp?ProdName=Book’ 返回错误\nhttp://host/test.jsp?ProdName=B’+’ook 返回正常\nhttp://host/test.jsp?ProdName=B’||’ook 返回正常说明有SQL注入\n2.如果应用程序已经过滤了’和+等特殊字符，我们仍然可以在输入时过把字符转换成URL编码（即字符ASCII码的16进制）来绕过检查。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "数据库参数化查询",
          "details": "使用参数化查询，或者ORM框架，例如常见的Java ORM框架包括Hibernate、MyBatis和Spring Data JPA等"
        },
        "security_design": {
          "name": "数据库参数化查询",
          "details": "1、在应用程序中执行数据库查询操作时，确保所有的查询语句都采用参数化查询的方式，避免直接拼接用户输入到查询语句中。2、根据具体选择的ORM框架（如Hibernate、MyBatis、Spring Data JPA），了解其安全配置和最佳实践，并按照指南进行设计和开发。配置ORM框架的数据映射规则，确保对象与数据库之间的映射正确且安全。注意处理敏感信息的加密、哈希等安全措施。"
        },
        "test_case": {
          "name": "SQL注入测试",
          "details": "1.数字型\nhttp://host/test.php?id=100 and 1=1返回成功\nhttp://host/test.php?id=100 and 1=2返回失败\n2.字符型\nhttp://host/test.php?name=rainman’ and‘1’=‘1返回成功\nhttp://host/test.php?name=rainman’ and‘1’=‘2返回失败\n3.搜索型\n搜索型注入：简单的判断搜索型注入漏洞是否存在的办法是：\n先搜索（'），如果出错，说明90%存在这个漏洞。\n然后搜索（%），如果正常返回，说明95%有洞了。 \n然后再搜索一个关键字，比如（2006）吧，正常返回所有2006相关的信息。\n再搜索（2006%'and 1=1 and '%'='）和（2006%'and 1=2 and '%'='）\n4.绕过验证（常见的为管理登陆）也称万能密码\n(1)用户名输入： ‘ or 1=1 or ‘ 密码：任意\n(2)Admin’ - -（或‘ or 1=1 or ‘ - -）(admin or 1=1 --) (MSSQL)(直接输入用户名，不进行密码验证)\n(3)用户名输入：admin 密码输入：’ or ‘1’=’1 也可以\n(4)用户名输入：admin' or 'a'='a 密码输入：任意\n(5)用户名输入：‘ or 1=1 - -\n(6)用户名输入：admin‘ or 1=1 - - 密码输入：任意\n(7)用户名输入：1'or'1'='1'or'1'='1 密码输入：任意\n5.不同的SQL服务器连结字符串的语法不同，比如MSSQLServer使用符号+来连结字符串，而Oracle使用符号||来连结：\nhttp://host/test.jsp?ProdName=Book’ 返回错误\nhttp://host/test.jsp?ProdName=B’+’ook 返回正常\nhttp://host/test.jsp?ProdName=B’||’ook 返回正常说明有SQL注入\n2.如果应用程序已经过滤了’和+等特殊字符，我们仍然可以在输入时过把字符转换成URL编码（即字符ASCII码的16进制）来绕过检查。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "过滤用户输入",
          "details": "采用输入复核或其他输入检查方式（检查是否有输入过长、非法字符、输入不完整、输入值超过上限或者下限等错误）"
        },
        "security_design": {
          "name": "过滤用户输入",
          "details": "1、对于每个输入字段，定义合理的最小和最大长度范围，并在后端对输入进行验证。2、定义允许的字符集，对用户输入进行检查，确保只有合法字符被接受。3、根据特定输入逻辑和业务需求，对其他字段的完整性进行验证，确保相关字段的输入满足预期规则。4、对于数值类型的输入，验证其是否在允许的范围内。例如，输入是否超过了字段定义的最大值或小于最小值。对于日期、时间等输入，确保输入值在可接受的范围内，避免无效或超出预期的输入。5、在前端和后端都使用适当的输入验证机制，包括正则表达式、数据类型验证、格式验证等，以确保输入的正确性和安全性。"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "服务端数据验证",
          "details": "使用服务器端代码执行其数据的输入验证。如果使用客户端验证方式，有可能发生攻击者绕过客户端验证或关闭客户端验证脚本进程的情况"
        },
        "security_design": {
          "name": "输入数据服务端验证",
          "details": "在服务器端进行业务逻辑验证，检查输入是否符合业务需求和预期。例如，验证某一字段的取值是否与其他字段相关联，或者是否符合特定的业务规则。"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "输出数据编码转义",
          "details": "在用户输出阶段，通过语义输出编码方式，对从服务端返回到客户端的数据进行编码。"
        },
        "security_design": {
          "name": "输出数据编码转义",
          "details": "1、对于在Web页面中显示的文本内容，使用HTML实体编码，将特殊字符转换为其对应的HTML实体。2、对于在URL参数中传递的数据，使用URL编码，将特殊字符转换为URL安全的表示形式"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "全局数据过滤",
          "details": "应用程序应设置全局过滤器，对用户提交的所有参数进行检查，验证时应使用白名单的方式进行匹配，发现非法字符跳转到错误页面。"
        },
        "security_design": {
          "name": "XSS过滤器",
          "details": "1、设置全局过滤器：在应用程序中设置一个全局过滤器，可以在请求到达服务器之前对用户提交的所有参数进行统一的检查和处理。 2、参数检查和验证：在全局过滤器中，对用户提交的所有参数进行检查，验证时应使用白名单的方式进行匹配。也就是说，只有在事先定义好的白名单中的字符才能通过验证，否则视为非法字符。 3、错误处理：如果发现用户提交的参数中包含非法字符，应当将用户重定向到错误页面，同时记录日志以便进行进一步的安全分析和处理。"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "敏感操作日志记录",
          "details": "应对个人金融信息访问与个人金融信息的增删改查等操作进行记录，并保证操作日志的完整性、可用性及可追溯性，操作日志包括但不限于业务操作日志、系统日志等"
        },
        "security_design": {
          "name": "敏感操作日志记录",
          "details": "1、明确哪些操作需要记录，如个人信息的新增、删除、更改等。2、根据操作的敏感性分级，确定日志的详细程度。3、定统一的日志格式，以便于分析和审计。4、确保所有操作都被记录，包括成功和尝试失败的操作。5、作发生时，日志应即时更新，避免延迟。"
        },
        "test_case": {
          "name": "日志记录规则测试",
          "details": "通过访谈的方式了解敏感操作日志记录规则。"
        },
        "industry_standard": {
          "name": "JR/T 0223/2021  7.4.2.1 c)",
          "details": null
        }
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "日志中的用户敏感数据脱敏",
          "details": "交易日志或系统日志中不可明文留存银行卡号（含他行卡号）、身份证号或手机号等客户敏感信息"
        },
        "security_design": {
          "name": "日志中的用户敏感数据脱敏",
          "details": "在日志记录之前，对敏感信息进行脱敏处理。这可以通过替换、掩码或哈希等方式来实现。例如，将银行卡号中间的数字掩码，只显示前六位和后四位（例如，123456******7890）。"
        },
        "test_case": {
          "name": "日志内容检测1",
          "details": "检查日志内容，搜索日志中是否记录用户敏感信息。"
        },
        "industry_standard": null
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "日志中的业务敏感数据脱敏",
          "details": "应用软件运行日志中不应打印支付敏感信息，不应打印完整的敏感数据原文"
        },
        "security_design": {
          "name": "日志中的业务敏感数据脱敏",
          "details": "在日志记录之前，通过自动化脱敏过程移除或替换所有识别出的敏感信息。可以使用正则表达式匹配敏感数据的模式，并将其替换为非敏感的占位符。"
        },
        "test_case": {
          "name": "日志内容检测2",
          "details": "检查日志内容，搜索日志中是否记录业务敏感信息。"
        },
        "industry_standard": null
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "统一客户识别编号",
          "details": "应使用统一的客户识别编号代替个人金融信息以输出到日志中，以提供故障排查处理能力"
        },
        "security_design": {
          "name": "统一客户识别编号",
          "details": "1、创建一个独特的、非敏感的客户识别编号体系。这个编号应该是唯一的，用来代替敏感的个人信息，如姓名、银行账号等。2、确保每个客户编号与相应的个人金融信息之间有一个持久化的映射关系，以便在需要时能够进行安全的查询和交叉引用。"
        },
        "test_case": {
          "name": "日志内容检测3",
          "details": "通过访谈了解日志中是否通过个人识别编号代替用户个人金融信息."
        },
        "industry_standard": null
      },
      {
        "name": "日志留存期限",
        "details": "日志留存时间过短将导致日志缺失，无法追溯安全事件。",
        "security_requirement": {
          "name": "日志留存时间应满足合规要求",
          "details": "日志记录应满足业务需要且最少留存1年"
        },
        "security_design": {
          "name": "日志留存时间设计",
          "details": "1、选择合适的存储解决方案，如本地服务器、网络存储或云服务，确保数据的可靠性和可访问性。2、制定并实施日志保留策略，明确规定所有日志至少保留一年，以符合法律法规要求。"
        },
        "test_case": {
          "name": "日志留存时间检测",
          "details": "通过访谈了解日志留存时间。"
        },
        "industry_standard": {
          "name": "JR/T0071.2/2020  7.1.4.3 c)",
          "details": null
        }
      },
      {
        "name": "接口监控日志缺失",
        "details": "接口监控日志缺失将导致无法追溯分析安全事件，影响系统的可维护性和安全性。",
        "security_requirement": {
          "name": "接口监控记录",
          "details": "对接口使用情况进行监控，具备完整记录的访问日志"
        },
        "security_design": {
          "name": "接口监控记录",
          "details": "1、确定监控范围和目标：明确需要监控的接口范围，哪些接口需要被监控，监控接口的调用频率、响应时间、错误率等。\n2、记录接口调用信息：在接口调用过程中，记录相关的调用信息，包括调用时间、调用方IP地址、接口名称、请求参数等，实现访问日志记录。"
        },
        "test_case": {
          "name": "接口监控测试",
          "details": "通过访谈了解监控范围，检查访问日志是否完整记录相关调用信息。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.3.3",
          "details": null
        }
      },
      {
        "name": "未接入互联网行为风控系统",
        "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统",
        "security_requirement": {
          "name": "接入互联网行为风控系统",
          "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统。"
        },
        "security_design": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "test_case": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》测试是否已接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "industry_standard": null
      }
    ]
  },
  "登录": {
    "threats": [
      {
        "name": "暴力破解",
        "details": "在应用系统登录过程中，由于并未限制用户的密码输入错误次数，攻击者可通过密码字典不断枚举指定用户的密码信息，最终用户密码将可能遭受到破解，攻击者可通过所破解的用户密码进入应用系统并发起进一步的攻击。",
        "security_requirement": {
          "name": "暴力破解",
          "details": "防止暴力破解攻击，保护用户账户安全"
        },
        "security_design": {
          "name": "暴力破解",
          "details": "登录失败处理：\n设置合理的登录失败次数限制，例如连续 3 次或 5 次登录失败后，暂时锁定该账户一段时间（如 15 分钟、30 分钟等），阻止攻击者继续尝试密码，降低暴力破解成功的概率。\n验证码验证：\n在登录页面、重要操作环节等添加验证码验证机制，要求用户输入验证码（如图片验证码、短信验证码、滑动验证码等），且验证码具备一定的时效性和复杂性，增加自动化暴力破解的难度。\n密码复杂度要求：\n强制规定用户密码需满足一定的复杂度标准，比如包含大小写字母、数字以及特殊字符，且长度不少于 8 位等，使密码难以通过简单的穷举方式被猜出。\n多因素认证：\n推广并启用多因素认证方式，除了常规的用户名和密码，结合使用短信验证码、动态口令牌、指纹识别、面部识别等其他认证因素，即便密码被猜到一部分，攻击者也难以突破多重验证。\n登录频率限制：\n对同一 IP 地址或同一账户在单位时间内的登录尝试次数进行限制，当超过限定次数时，进行告警提示或者采取临时阻断措施，防止恶意的批量暴力破解行为。\nIP 黑名单机制：\n对于频繁发起暴力破解尝试的可疑 IP 地址，将其加入黑名单，禁止该 IP 后续的访问请求，有效阻止来自特定恶意 IP 的持续攻击。"
        },
        "test_case": {
          "name": "暴力破解",
          "details": "测试方法：\n1、观察前端是否有二次验证多因素功能（如验证码、短信、OTP 等）\n2、若 1 不存在，则尝试故意错误登录，看是否有锁定次数提示或是否真实锁定账号\n预期结果： \n1、存在\n2、有次数限制锁定提示且账号锁定"
        },
        "industry_standard": null
      },
      {
        "name": "密码泄露",
        "details": "",
        "security_requirement": {
          "name": "密码泄露",
          "details": "确保系统能够有效保护用户的密码，防止密码泄露。"
        },
        "security_design": {
          "name": "密码泄露",
          "details": "密码加密存储：\n采用强加密算法如 bcrypt 或 Argon2 对密码进行哈希处理后存储，添加随机盐值，使相同密码存储结果不同，增强密码安全性，防止数据库泄露导致密码被轻易获取。\n传输加密保障：\n在用户登录等涉及密码传输场景，使用 HTTPS 协议，对密码进行加密传输，避免密码在网络中被窃取，保障从客户端到服务器端传输过程的保密性。\n密码更新机制：\n定期提醒用户更新密码，设置密码有效期，如每三个月或半年强制更新，减少因长期使用同一密码被破解或泄露的风险。\n安全策略提示：\n在注册、登录页面展示密码安全策略，如要求包含数字、字母、特殊字符且长度不少于 8 位，引导用户创建高强度密码，降低密码被暴力破解概率。"
        },
        "test_case": {
          "name": "密码泄露",
          "details": "测试方法：登录、注册、修改密码功能处，输入密码时，查看是否有如下的提示和回显：1、要求密码包含大写字母、小写字母、数字和特殊字符；要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：有强密码规则要求。"
        },
        "industry_standard": null
      },
      {
        "name": "短信验证码安全",
        "details": "",
        "security_requirement": {
          "name": "短信验证码安全",
          "details": "保障短信验证码从生成、传输、存储到校验全流程的保密性、完整性及有效性，防止验证码被预测、窃取、篡改、重复使用等情况"
        },
        "security_design": {
          "name": "短信验证码安全",
          "details": "验证码长度要求：\n设置验证码长度要求为不少于6位。较长的验证码长度可以增加密码的强度，提高安全性。\n随机验证码生成算法：\n使用安全的随机数生成算法（如SecureRandom）生成随机验证码，确保生成的验证码具有足够的复杂性和随机性。\n验证码校验：\n应该判断短信验证码的发送手机号是否为用户绑定的手机号码，应该在后端完成储存校验，禁止将短信验证码以明文或者编码（弱加密）的方式出现在响应包或者源码中。\n防止验证码重复使用：\n在校验成功后，立即从存储介质中删除该验证码，或者将其标记为已使用，防止同一个验证码被重复使用。\n验证码频率限制：\n为防止短信炸弹攻击，应该限制短信验证码的发送时间间隔和次数，建议间隔时间大于60s。\n验证码过期或错误：\n规定短信验证码的有效时间和输入错误次数，通常情况下有效时间不长于60s，失效后需重新获取验证码；输入错误次数不高于3次，超出后锁定账号5分钟。"
        },
        "test_case": {
          "name": "短信验证码安全",
          "details": "测试方法：使用抓包工具检查请求和响应包，查看是否有验证码以明文或弱加密方式出现；使用相同验证码多次校验、验证码超时后校验、频繁多次输入错误验证码，并观察应用程序的响应。\n预期结果：在响应包和源码中没有发现短信验证码以明文或弱加密方式出现；验证码校验成功或失败。"
        },
        "industry_standard": null
      },
      {
        "name": "图形验证码安全",
        "details": "",
        "security_requirement": {
          "name": "图形验证码安全",
          "details": "保障图形验证码的安全性"
        },
        "security_design": {
          "name": "图形验证码安全",
          "details": "1、字符集选择：确定用于生成验证码的字符集。通常，字符集包括大写字母、小写字母和数字，并可以包含一些易于识别的特殊字符。 \n2、验证码长度：确定验证码的长度。一般来说，验证码长度应足够长，以增加猜测的难度和安全性，通常建议至少4个字符。 \n3、随机字符生成：使用安全的随机数生成算法从所选字符集中随机选择字符，生成验证码。确保生成的字符具有足够的随机性和不可预测性。\n4、图片底纹干扰：在验证码图像的背景中添加随机的干扰元素，如噪点、线条、模糊效果等。\n5、颜色变换：使用随机的颜色组合来渲染验证码字符或背景。 \n6、设置非连续性：确保验证码字符在图像上不是连续排列的，而是以非常规的位置和顺序呈现。 \n7、旋转图片字体：对于验证码的每个字符，将其按照随机角度进行旋转。 \n8、变异字体显示样式：对于每个验证码字符，使用不同的字体、大小、粗细或斜体等变异样式。图形验证码在使用一次后，不论验证成功或失败都立即刷新图形验证码。\n9、服务器生成验证码：服务器接收到客户端的请求后，使用安全的随机数生成算法生成一个验证码。确保生成的验证码具有足够的复杂性和随机性。\n10、验证码图像生成：服务器使用生成的验证码文本，基于一些预定义的样式和参数，生成相应的验证码图像。这个过程可以利用图形库或工具来实现，生成包含验证码的图像。"
        },
        "test_case": {
          "name": "图形验证码安全",
          "details": "1.请求10次观察验证码是否随机生成，如果存在一定的规律（例如5次后出现同一验证码）说明存在漏洞，完成检测\n2.使用互联网上可下载的 OCR验证码识别工具、脚本等，测试确认图形验证码无法进行低成本的光学字符识别(OCR）。\n3.手工找到存在图形验证码的页面。尝试使用错误的图形验证码进行验证，验证失败后观察图形验证码是否刷新。\n4.检查生成的验证码是否可以通过html源代码查看到，如果可以说明存在漏洞，完成检测。"
        },
        "industry_standard": null
      },
      {
        "name": "篡改",
        "details": "",
        "security_requirement": {
          "name": "篡改",
          "details": "确保系统能够防止数据在传输或存储过程中被篡改，保护数据的完整性和准确性。"
        },
        "security_design": {
          "name": "篡改",
          "details": "传输加密：\n在数据传输阶段，采用强加密算法（如 SSL/TLS 协议等）对数据进行加密处理，确保数据在网络通道中以密文形式传输，即使被拦截，攻击者也难以对密文内容进行篡改，保障传输过程的数据完整性。\n存储加密：\n对于存储的数据，使用合适的加密方式（如对称加密、非对称加密等）进行加密存储，只有拥有正确解密密钥的授权主体才能访问原始数据，防止存储过程中数据被非法篡改。\n完整性校验：\n定期或在数据使用前，采用哈希算法（如 SHA-256 等）计算数据的哈希值，并与预先保存的正确哈希值进行比对，若两者不一致，则表明数据可能被篡改，需进一步排查处理。\n访问控制：\n严格设置数据的访问权限，依据用户角色、权限级别等因素，只允许授权人员对数据进行读写等操作，限制非授权访问，从源头上减少数据被篡改的风险。\n监控与告警：\n搭建数据状态的监控系统，实时关注数据传输、存储过程中的相关指标，如数据流量变化、加密状态、完整性校验结果等，一旦发现疑似数据篡改的异常情况，及时触发告警，通知安全运维人员进行深入调查和修复。\n备份恢复：\n制定合理的数据备份策略，定期对重要数据进行备份，存储在独立、安全的介质或位置，当发现数据被篡改时，可利用备份数据进行恢复，最大程度降低篡改带来的损失。"
        },
        "test_case": {
          "name": "篡改",
          "details": "测试方法：使用 Fiddler 抓包，检查传输过程中敏感数据是否进行了加密。\n预期结果：使用非 MD5、base64等弱加密算法。"
        },
        "industry_standard": null
      },
      {
        "name": "不安全的通信协议",
        "details": "使用不安全低版本的通信协议可能导致数据被窃取或泄露，如敏感信息、个人隐私数据或商业机密等。相关漏洞如：CVE-2016-2183，CVE-2016-6329，CVE-2011-3389，CVE-2013-2566，CVE-2015-2808等。",
        "security_requirement": {
          "name": "使用安全通信协议",
          "details": "应使用SSL/TLS等安全通信技术，应使用相对安全的高版本协议（TLS1.2及以上版本）"
        },
        "security_design": {
          "name": "使用安全通信协议",
          "details": "使用TLSv1.2以上版本安全通信协议。或者更改远程服务安全通信配置，使其不再接受存在漏洞的加密套件；修改SSL/TLS配置，移除弱加密算法，且使其不再接受弱加密套件；厂商主页下载http://www.openssl.org/升级补丁。"
        },
        "test_case": {
          "name": "TLS/SSL测试",
          "details": "使用TLS/SSL命令行测试工具testssl.sh，地址https://github.com/drwetter/testssl.sh，或者在官网https://testssl.sh/ 下载。"
        },
        "industry_standard": null
      },
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "SQL注入",
          "details": "对用户的输入信息过滤或者转义"
        },
        "security_design": {
          "name": "SQL注入",
          "details": "输入验证：\n严格校验用户输入数据类型、长度与格式，拒绝非法输入。\n字符过滤与转义：\n过滤或转义单引号、双引号等 SQL 特殊字符。\n预编译语句：\n采用预编译技术处理 SQL 查询，分离代码与数据。\n数据库权限：\n依最小权限原则设置数据库用户权限。"
        },
        "test_case": {
          "name": "SQL注入",
          "details": "测试方法：在输入处写入特殊字符（如：@$%&*<>';/）或构造 SQL 语句。\n预期结果：拒绝执行该功能的正确处理，或报错但无过多错误信息。"
        },
        "industry_standard": null
      },
      {
        "name": "XSS保护绕过",
        "details": "",
        "security_requirement": {
          "name": "XSS保护绕过",
          "details": "确保网站或应用程序实施了有效的 XSS 防护措施，包括输入验证、输出编码和内容安全策略等。\n加强对用户输入和输出的验证和过滤，防止 XSS 攻击的发生和影响。"
        },
        "security_design": {
          "name": "XSS保护绕过",
          "details": "输入验证强化：\n对用户输入的各类数据（如表单字段、查询参数等）进行深度验证，不仅检查数据格式、长度，还分析其语义内容，依据业务逻辑严格甄别合法与非法输入，拒绝可能用于构造 XSS 攻击的恶意输入。\n输出编码细化：\n根据输出内容的类型（如 HTML、JavaScript、CSS 等）采用针对性的编码方式，例如在 HTML 输出时对特殊字符（<、>、&、'、\" 等）进行 HTML 实体编码，确保输出内容无法被浏览器解析为恶意脚本，且覆盖所有可能的输出场景，避免遗漏导致绕过防护。\n内容安全策略优化：\n完善内容安全策略（CSP），采用严格的白名单机制，明确允许加载的脚本、样式等资源来源，禁止一切非授权来源的内容加载，同时定期审查和更新 CSP，使其能适应业务变化与新出现的绕过手段。\n上下文敏感过滤：\n考虑输入输出的上下文环境，比如在 JavaScript 字符串中、HTML 属性内等不同场景下，对输入内容进行差异化的过滤与转义处理，精准防止攻击者利用特定上下文进行 XSS 绕过攻击。\n安全框架更新与选用：\n及时更新应用程序所使用的安全框架，选用具有更强抗 XSS 绕过能力的框架，利用其内置的先进防护机制来加固整体安全防线，降低被绕过的风险。"
        },
        "test_case": {
          "name": "XSS保护绕过",
          "details": "测试方法：在输出的功能处输入恶意的JavaScript代码或HTML元素如alert()、<script></script>、\"></script>。\n预期结果：返回报错，或转义后返回前端，或原封不动文本形式返回前端。"
        },
        "industry_standard": null
      },
      {
        "name": "生物特征合规威胁",
        "details": "生物特征合规威胁",
        "security_requirement": {
          "name": "生物特征合规威胁",
          "details": "必须在开始采集人脸之前，对客户进行个人信息采集提示及隐私协议，需要引导客户查看协议并明示同意，方可进行下一步操作\n在收集阶段，应征得用户明示同意后收集最小必要的相关信息，不采集未经授权的用户信息，不因用户不同意收集生物识别数据而拒绝向其提供基本业务功能。\n采集的生物特征数据不得用于除预期业务外的其他用途。\n在存储阶段，应采取加密技术，将生物识别数据和个人身份信息数据用物理或逻辑隔离的方式分别存储，不在文件名中显示带有数据主体身份识别信息；一旦数据超出授权存储期限立即执行删除或采取匿名化等安全措施，以确保生物识别数据的安全。\n在使用阶段，完成验证或辨识后，应立即删除原始生物特征信息。生成的生物特征，可更新、不可逆变出原始的生物特征信息、不可与主体的其他生物识别信息相互链接。\n"
        },
        "security_design": {
          "name": "生物特征合规威胁",
          "details": "一、人脸采集前个人信息采集及隐私协议：1、个人信息采集提示：在开始采集人脸之前，向客户呈现一个明显的个人信息采集提示，提醒他们即将要进行个人信息的收集和使用。 2、隐私协议内容：准备一份详细的隐私协议，明确说明个人信息的类型、收集目的、使用方式、存储期限、分享情况以及相关的权利和保护措施等。确保协议符合适用的法律法规和隐私政策要求，并易于理解。3、明示同意：在个人信息采集提示中，明确要求客户查看隐私协议并表示明示同意。可以设计一个勾选框或按钮，客户必须主动选择同意该协议才能继续进行下一步操作。 4、协议查看机制：为客户提供便捷的方式来查看隐私协议。可以在界面上设置链接或按钮，点击后弹出协议内容，或者跳转至另一页展示完整的隐私协议。5、强制同意：确保在客户未明示同意隐私协议之前，无法进行下一步操作。例如，在系统中设置条件判断，只有当客户已明示同意时，才允许进行人脸采集等相关操作。\n二、知情同意和最小必要信息原则：1、信息收集明示同意：在收集阶段，向用户明确呈现所需收集的信息，并征得用户明示同意。提供一个清晰的界面或对话框，准确描述需要收集的信息和使用目的，以便用户能够理解和作出知情的决策。2、最小必要信息原则：仅收集与提供基本业务功能相关且最小必要的用户信息。确保只采集那些对于实现所需功能是必需的信息，避免过度收集和使用用户的个人数据。3、授权与拒绝处理：当用户同意提供必要信息时，进行相应的数据收集操作。如果用户拒绝提供某些信息，系统应该能够在不影响基本业务功能的情况下继续提供服务，例如通过提供替代选项或匿名访问。\n三、生物特征数据用途限制：1、明确目的：在生物特征数据采集过程中，明确说明数据的收集目的并限定仅用于预期的业务功能。确保用户清楚知道他们的生物特征数据将被用于何种用途。2、界定数据范围：明确指定需要采集的生物特征数据的类型和范围，并根据实际业务需求进行限制。只采集必要的生物特征数据，避免过度收集和使用。3、限制数据共享：不将生物特征数据用于除预期业务外的其他用途，包括不与未经授权的第三方共享这些数据。确保在共享或交换数据时，遵守相关的法律法规和隐私政策要求。\n四、生物识别与个人身份信息数据安全存储：1、加密存储：对生物识别数据（如指纹、虹膜、面部特征等）和个人身份信息数据使用高级加密技术进行存储。确保即使数据被窃取，攻击者也无法轻易解密。2、物理与逻辑隔离：物理隔离：确保生物识别数据和个人身份信息数据存储在不同的服务器或硬件设备上，降低同时被攻击的风险。逻辑隔离：在同一个服务器或硬件设备上，使用逻辑隔离技术（如虚拟机、容器等）来分隔生物识别数据和个人身份信息数据，确保它们之间不发生交叉访问。3、避免在文件名、数据库记录或其他地方明文显示带有数据主体身份识别信息的内容。这可以防止未经授权的人员通过文件名或其他途径获取敏感信息。4、设定生物识别数据和个人身份信息数据的授权存储期限。一旦数据超过这个期限，系统应自动执行删除或匿名化操作，确保数据不会长时间留存。5、建立自动清理机制，定期检查并删除过期的生物识别数据和个人身份信息数据。这样可以确保系统始终保持清洁，减少潜在的安全风险。\n五、生物特征信息删除及更新：立即在验证或辨识过程结束后删除原始生物特征信息。确保不再保留用户的原始生物特征数据，以减少潜在的风险。如果需要在将来的验证过程中再次使用生物特征信息，确保仅使用已经生成的和更新的生物特征信息，而不是依赖于原始的生物特征数据。"
        },
        "test_case": {
          "name": "生物特征认证（脸和指纹）",
          "details": "手工找到需要人脸识别的页面；观察是否有个人信息采集等提示。\n验证在信息收集阶段是否有明确的提示，告知用户即将进行个人信息采集，并引导用户查看协议并明示同意。\n以访谈的形式了解采集的生物特征用途。\n以访谈的形式了解生物识别与个人身份信息数据存储机制。\n以访谈的形式了解生物特征信息删除及更新机制。\n"
        },
        "industry_standard": null
      },
      {
        "name": "会话信息传输过程信息泄露",
        "details": "攻击者可以通过截取、监听或窃取会话数据的方式，获取包含敏感信息的数据包。这可能包括用户名、密码、个人身份信息、支付信息等。",
        "security_requirement": {
          "name": "会话标识符保护",
          "details": "会话标识符应当只出现在http头信息中，不要在URL以GET参数进行传递，且不要在错误信息或日志中暴露会话标识符"
        },
        "security_design": {
          "name": "会话标识安全传输",
          "details": "1、在应用程序中，确保会话标识符只通过HTTP头信息进行传递，而不是作为URL的GET参数。2、确保错误信息和日志中不会明文暴露会话标识符。对于错误处理和日志记录，需要对会话标识符进行脱敏处理或者只记录其哈希值。"
        },
        "test_case": {
          "name": "会话传输测试",
          "details": "1、人工找到涉及会话传输的功能点。2、刷新页面并用BURP进行抓包，观察会话标识传输方式。"
        },
        "industry_standard": {
          "name": "JR/T  0213/2021：5.3.5.4",
          "details": null
        }
      },
      {
        "name": "会话复用，会话标识未更新",
        "details": "对用户进行身份鉴别并建立一个新的会话时没有让原来的会话失效。攻击者可诱使用户在攻击者创建的会话基础上进行身份鉴别，从而窃取用户通过身份鉴别的会话并冒充用户进行恶意操作。",
        "security_requirement": {
          "name": "防会话固定",
          "details": "系统在通过身份鉴别后必须分配新的会话标识，不能使用未认证前的标识"
        },
        "security_design": {
          "name": "登录成功后刷新会话",
          "details": "在用户提供的认证信息（例如用户名和密码）、相应的权限级别发生变化时，服务器端应重新生成SessionID，并强制失效之前的会话。"
        },
        "test_case": {
          "name": "会话固定测试",
          "details": "1.打开网站登录页面。\\r\\n\n2.登陆前通过软件工具抓取到的cookie信息值与在登录后抓取到的cookie进行对比，如果其值一样，则可判断其会话的cookies或者sessions未进行更新。"
        },
        "industry_standard": {
          "name": "JR/T  0213/2021：5.3.5.3 a）",
          "details": null
        }
      },
      {
        "name": "会话并发",
        "details": "如果没有限制并发会话连接数，恶意用户可以通过创建大量会话连接占用服务器资源，例如内存、带宽等，导致系统性能下降或服务中断。",
        "security_requirement": {
          "name": "限制并发会话连接数",
          "details": "不允许同一用户在同一渠道多终端同时登录"
        },
        "security_design": {
          "name": "并发会话连接数限制",
          "details": "设置应用系统对一个时间段内可能的并发会话连接数进行限制（如：在中间件或web服务器进行限制）。"
        },
        "test_case": {
          "name": "会话并发测试",
          "details": "使用burpsuite对正常账号登录过程进行多线程的重放，查看是否全部登陆成功。若成功则分别使用响应包中的set-cookie中的会话标识访问业务页面，查看是否可以正常访问得到会话连接的并发数量。将该并发数量与后台的设定值进行比对。"
        },
        "industry_standard": null
      },
      {
        "name": "会话有效期过长",
        "details": "如果恶意用户能够获取到合法用户的会话标识符，而且会话有效期过长，他们可以利用该标识符获取对应用户的权限，并冒充该用户进行未经授权的操作。",
        "security_requirement": {
          "name": "Session安全管理",
          "details": "会话标识应随机并且唯一，且在用户长时间未操作或登出后应立即清理会话及其相关登录信息"
        },
        "security_design": {
          "name": "Session安全管理",
          "details": "Web服务器为了保存客户端的状态信息，引入了Session的概念，用于身份验证和权限校验。为了保证会话的安全性，应该遵守如下安全要求： 1. Session ID应具备随机性 1）对于Java项目，Session ID由Servlet容器进行控制。 2）对于C/C++项目，如需提供服务器端功能并且维持会话，在生成Session ID时，应保证随机数生成的随机性：建议使用多种随机因子组合生成Session ID，如使用UUID（Universally Unique Identifier）、以时间戳和客户端IP或者MAC地址为随机因子生成的随机数进行拼接，然后使用SM3对拼接字符串哈希处理，生成的字符串作为session ID，长度保证至少32位。 2. Session应具备超时机制，会话超时时间由业务系统定义。如果用户一定时间无任何操作，服务器端应注销用户会话。 3. 用户登录时，应生成新的Session ID。 4. 用户登录并建立一个会话时，若发现此用户有旧会话，建议注销旧会话。"
        },
        "test_case": {
          "name": "会话有效期测试",
          "details": "登录目标系统获得会话，一时之后再次利用该会话操作目标系统，测试会话是否失效。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3  a)",
          "details": null
        }
      },
      {
        "name": "cookie安全",
        "details": "会话cookie中缺少HttpOnly属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的cookie信息，造成用户cookie信息泄露，增加攻击者的跨站脚本攻击威胁。",
        "security_requirement": {
          "name": "cookie安全属性",
          "details": "系统使用Cookie时，应设置Cookie的Secure属性，启用HttpOnly属性"
        },
        "security_design": {
          "name": "Cookie安全属性设置",
          "details": "1、在系统中使用Cookie时，确保设置Cookie的Secure属性为true。这将要求仅在通过HTTPS协议进行传输时才能发送Cookie。2、启用Cookie的HttpOnly属性，将其设置为true。"
        },
        "test_case": {
          "name": "Cookie属性测试",
          "details": "1.通过用web扫描工具进行对网站的扫描，如果存在相关cookies的安全性问题，则一般工具都会检测出来，误报率小。\\r\\n\n2.或在浏览器调试窗口的网络请求处查看HTTP Header，判断是否设置Cookie属性。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 b)",
          "details": null
        }
      },
      {
        "name": "默认账号口令",
        "details": "默认密码容易被攻击者猜测或通过搜索引擎找到，利用这些默认口令可批量破解多个账户以及尝试登录系统或应用程序，从而获取敏感信息或进行非法操作。",
        "security_requirement": {
          "name": "用户首次登录应修改临时密码",
          "details": "应用系统应强制首次登录的用户修改默认账户或预设账户的默认口令"
        },
        "security_design": {
          "name": "默认密码管理",
          "details": "若系统提供默认固定密码时，系统应对未修改密码的用户访问权限进行限制；当用户登录系统时，系统应判断用户密码是否经过修改，若首次登录，则强制用户修改登录密码。未修改则只能对应用系统进行有限访问。"
        },
        "test_case": {
          "name": "默认密码测试",
          "details": "申请新账号，检查是否有默认密码存在；若存在默认密码，首次登录使用是否强制要求用户进行默认密码的修改。"
        },
        "industry_standard": {
          "name": "JR/T0071.2/2020 9.1.4.2 c)",
          "details": null
        }
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "敏感操作日志记录",
          "details": "应对个人金融信息访问与个人金融信息的增删改查等操作进行记录，并保证操作日志的完整性、可用性及可追溯性，操作日志包括但不限于业务操作日志、系统日志等"
        },
        "security_design": {
          "name": "敏感操作日志记录",
          "details": "1、明确哪些操作需要记录，如个人信息的新增、删除、更改等。2、根据操作的敏感性分级，确定日志的详细程度。3、定统一的日志格式，以便于分析和审计。4、确保所有操作都被记录，包括成功和尝试失败的操作。5、作发生时，日志应即时更新，避免延迟。"
        },
        "test_case": {
          "name": "日志记录规则测试",
          "details": "通过访谈的方式了解敏感操作日志记录规则。"
        },
        "industry_standard": {
          "name": "JR/T 0223/2021  7.4.2.1 c)",
          "details": null
        }
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "日志中的用户敏感数据脱敏",
          "details": "交易日志或系统日志中不可明文留存银行卡号（含他行卡号）、身份证号或手机号等客户敏感信息"
        },
        "security_design": {
          "name": "日志中的用户敏感数据脱敏",
          "details": "在日志记录之前，对敏感信息进行脱敏处理。这可以通过替换、掩码或哈希等方式来实现。例如，将银行卡号中间的数字掩码，只显示前六位和后四位（例如，123456******7890）。"
        },
        "test_case": {
          "name": "日志内容检测1",
          "details": "检查日志内容，搜索日志中是否记录用户敏感信息。"
        },
        "industry_standard": null
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "日志中的业务敏感数据脱敏",
          "details": "应用软件运行日志中不应打印支付敏感信息，不应打印完整的敏感数据原文"
        },
        "security_design": {
          "name": "日志中的业务敏感数据脱敏",
          "details": "在日志记录之前，通过自动化脱敏过程移除或替换所有识别出的敏感信息。可以使用正则表达式匹配敏感数据的模式，并将其替换为非敏感的占位符。"
        },
        "test_case": {
          "name": "日志内容检测2",
          "details": "检查日志内容，搜索日志中是否记录业务敏感信息。"
        },
        "industry_standard": null
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "统一客户识别编号",
          "details": "应使用统一的客户识别编号代替个人金融信息以输出到日志中，以提供故障排查处理能力"
        },
        "security_design": {
          "name": "统一客户识别编号",
          "details": "1、创建一个独特的、非敏感的客户识别编号体系。这个编号应该是唯一的，用来代替敏感的个人信息，如姓名、银行账号等。2、确保每个客户编号与相应的个人金融信息之间有一个持久化的映射关系，以便在需要时能够进行安全的查询和交叉引用。"
        },
        "test_case": {
          "name": "日志内容检测3",
          "details": "通过访谈了解日志中是否通过个人识别编号代替用户个人金融信息."
        },
        "industry_standard": null
      },
      {
        "name": "日志留存期限",
        "details": "日志留存时间过短将导致日志缺失，无法追溯安全事件。",
        "security_requirement": {
          "name": "日志留存时间应满足合规要求",
          "details": "日志记录应满足业务需要且最少留存1年"
        },
        "security_design": {
          "name": "日志留存时间设计",
          "details": "1、选择合适的存储解决方案，如本地服务器、网络存储或云服务，确保数据的可靠性和可访问性。2、制定并实施日志保留策略，明确规定所有日志至少保留一年，以符合法律法规要求。"
        },
        "test_case": {
          "name": "日志留存时间检测",
          "details": "通过访谈了解日志留存时间。"
        },
        "industry_standard": {
          "name": "JR/T0071.2/2020  7.1.4.3 c)",
          "details": null
        }
      },
      {
        "name": "接口监控日志缺失",
        "details": "接口监控日志缺失将导致无法追溯分析安全事件，影响系统的可维护性和安全性。",
        "security_requirement": {
          "name": "接口监控记录",
          "details": "对接口使用情况进行监控，具备完整记录的访问日志"
        },
        "security_design": {
          "name": "接口监控记录",
          "details": "1、确定监控范围和目标：明确需要监控的接口范围，哪些接口需要被监控，监控接口的调用频率、响应时间、错误率等。\n2、记录接口调用信息：在接口调用过程中，记录相关的调用信息，包括调用时间、调用方IP地址、接口名称、请求参数等，实现访问日志记录。"
        },
        "test_case": {
          "name": "接口监控测试",
          "details": "通过访谈了解监控范围，检查访问日志是否完整记录相关调用信息。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.3.3",
          "details": null
        }
      },
      {
        "name": "接口日志内容泄露",
        "details": "接口日志中记录的个人金融信息如果未受到足够的安全保护，可能会被黑客攻击或内部人员滥用，可能会导致银行卡号、密码、交易记录等敏感信息泄露。这些信息一旦泄露，可能会被用于欺诈、身份盗窃等不良行为，给个人财产和隐私带来严重威胁。",
        "security_requirement": {
          "name": "接口日志内容脱敏",
          "details": "个人金融信息不能在应用方接口日志中记录，且应以部分屏蔽的方式记录支付账号（或其等效信息）"
        },
        "security_design": {
          "name": "接口日志内容脱敏",
          "details": "因清分清算、差错对账等业务需要，应用方接口日志中应以部分屏蔽的方式记录支付账号(或其等效信息），除此之外的个人金融信息不在应用方接口日志中进行记录。"
        },
        "test_case": {
          "name": "接口日志内容检测",
          "details": "检查日志内容，搜索日志中是否记录个人金融信息。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.3.3",
          "details": null
        }
      },
      {
        "name": "应用方身份冒用",
        "details": "如果身份认证凭证被盗或滥用，攻击者可能会使用这些凭证进行身份认证，从而获得对系统的访问权限，导致敏感数据泄露、恶意操作或其他安全问题，增加验证要素可提高安全性。",
        "security_requirement": {
          "name": "身份验证要素",
          "details": "对应用方身份认证使用的验证要素至少两种且包含APP_ID"
        },
        "security_design": {
          "name": "身份验证要素",
          "details": "对于应用方身份认证应使用的验证要素包括：\n——App_ID、 App_Secret。\n一—App_ID、数字证书。\n——App_ID、公私钥对。\n——App_ID 、 App_Secret、数字证书（或公私钥对）的组合。"
        },
        "test_case": {
          "name": "应用方身份冒用测试",
          "details": "人工测试验证，应用方身份验证要素是否使用两种验证要素，并且其中一种必须是APP_ID。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.1 b）",
          "details": null
        }
      },
      {
        "name": "A2级别接口应用方身份冒用",
        "details": "其他身份认证方式没有经过权威认证，可能存在被伪造的风险。",
        "security_requirement": {
          "name": "双向身份认证",
          "details": "对A2级别接口、应用方身份认证进行双向身份认证"
        },
        "security_design": {
          "name": "双向身份认证",
          "details": "对A2级别接口、应用方身份认证进行双向身份认证：\n一—App_ID、数字证书。\n——App_ID、公私钥对。\n——App_ID 、 App_Secret、数字证书（或公私钥对）的组合。"
        },
        "test_case": {
          "name": "A2级别接口应用方身份冒用测试",
          "details": "人工测试验证，应用方身份验证要素是否使用数字证书或公私钥对进行双向身份验证。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.1 b）",
          "details": null
        }
      },
      {
        "name": "用户身份冒用",
        "details": "除了用户名和密码外，还可以使用其他因素进行身份认证，如手机验证码、生物特征信息等。这可以增加攻击者进行身份冒用的难度。",
        "security_requirement": {
          "name": "用户双因子认证",
          "details": "对于A2级别接口中的资产交易类服务应对用户登录身份认证使用双因子认证"
        },
        "security_design": {
          "name": "用户双因子认证",
          "details": "用户身份认证应在商业银行执行，对于 A2 级别接口中的资金交易类服务，用户登录身份认证应至少使用双因子认证的方式来保护账户财产安全。\n选择合适的双因子认证方法，如硬件令牌，短信验证码等。\n登录界面：在登录界面明确提示用户需要进行双因子认证，并提供相应的方法选项。 \n二次验证流程：根据选择的认证方法，设计相应的二次验证流程。例如，如果选择短信验证码，系统应发送验证码到用户的注册手机，并提示用户输入该验证码。"
        },
        "test_case": {
          "name": "用户双因子认证测试",
          "details": "观察用户登录界面是否明确提示用户需要进行双因子认证，通过修改返回值等方法验证认证是否可被绕过。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.2.1 b）",
          "details": null
        }
      },
      {
        "name": "数据交互未校验",
        "details": "未使用数据签名等校验手段对通讯进行校验，容易导致数据被第三方窃取",
        "security_requirement": {
          "name": "通讯数字签名校验",
          "details": "对A2级别接口使用数字签名，密码算法符合国家密码主管部门要求"
        },
        "security_design": {
          "name": "通讯数字签名校验",
          "details": "商业银行和应用方使用数字签名来保证数据的完整性和不可抵赖性。\n1. 生成密钥对： 在发送方和接收方之间，各自生成一对公钥和私钥。私钥需要安全地存储，而公钥可以公开分发。 \n2. 数据加密： 当发送方需要发送数据时，使用如哈希函数（如SHA-256）对原始数据进行哈希处理，生成一个固定长度的哈希值。 然后，发送方使用其私钥对这个哈希值进行加密，生成数字签名。 \n3. 数据传输： 发送方将加密后的数字签名和原始数据一起发送给接收方。 \n4. 验证签名： 接收方接收到数据后，首先使用发送方的公钥对数字签名进行解密，得到解密后的哈希值。 然后，接收方使用同样的哈希函数对原始数据进行哈希处理，得到一个新的哈希值。 接收方将解密后的哈希值与新计算的哈希值进行比较。如果两者相同，说明数据在传输过程中没有被篡改，签名有效；如果不同，说明数据可能已被篡改或者数字签名无效。\n5. 安全存储和传输私钥： 为了保证数字签名的安全性，私钥必须安全地存储，并且只能由授权的人员访问。此外，数据的传输也应该是安全的，可以使用加密的通道（如HTTPS）来传输数据和数字签名。\n6. 定期更新密钥对和安全策略： 随着时间和技术的变化，密钥对和安全策略可能会变得不再安全。因此，需要定期更新密钥对和安全策略。\n避免使用不安全的算法，如AES算法的ECB模式，SHA1，MD5等。"
        },
        "test_case": {
          "name": "通讯数字签名校验测试",
          "details": "通过访谈方式，确定数字签名及使用的算法。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.1",
          "details": null
        }
      },
      {
        "name": "敏感信息交互泄露",
        "details": "登录口令、支付密码等敏感信息被窃取，可能导致用户资金损失等风险。",
        "security_requirement": {
          "name": "敏感信息交互防泄露",
          "details": "登录口令、支付密码等支付敏感信息在数据交互过程中应使用包括但不限于替换输入框原文、自定义软键盘、防键盘窃听、防截屏等安全防护措施，保证无法获取支付敏感信息明文"
        },
        "security_design": {
          "name": "敏感信息交互防泄露",
          "details": "1. 前端输入保护： \n替换输入框原文：当用户在输入框中输入敏感信息时，系统可以自动替换输入的字符或整个输入框的内容，使得他人无法直接从输入框中观察到敏感信息。\n自定义软键盘：使用自定义的软键盘，而不是标准的键盘，以防止键盘记录器等工具窃取用户的输入。 \n防键盘窃听：利用技术手段，如混淆键盘布局、记录和跟踪用户的键盘输入等，以防止键盘窃听。\n防截屏：阻止应用程序以外的软件或工具对当前界面的截屏操作，保护用户界面中的敏感信息不被截屏软件获取。 \n2. 后端加密存储：\n数据加密：对存储的敏感信息进行加密处理，即使数据被非法获取，也无法直接读取明文。 \n密钥管理：使用安全的密钥管理机制，确保密钥的安全存储和传输。 \n3. 通信传输保护：\n使用HTTPS：确保数据在传输过程中使用加密的通道，防止数据被截获和窃取。 \n数据完整性校验：使用消息摘要算法对传输的数据进行完整性校验，确保数据在传输过程中没有被篡改。"
        },
        "test_case": {
          "name": "敏感信息交互泄露测试",
          "details": "测试登录口令、支付密码等支付敏感信息在数据交互过程中是否有替换输入框原文、自定义软键盘、防键盘窃听、防截屏等安全防护措施。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.2.2",
          "details": null
        }
      },
      {
        "name": "授权有效期不合理",
        "details": "如果未根据业务需求和安全要求合理设置接口授权有效期，可能导致数据泄露风险，法律风险等。",
        "security_requirement": {
          "name": "授权有效期设置",
          "details": "调用接口时，需要被授权，同时设置授权有效期（单次有效、阶段性有效、协议期限内有效）"
        },
        "security_design": {
          "name": "授权有效期设置",
          "details": "单次有效提供最高的安全性，但可能对用户体验和系统性能产生一定影响。阶段性有效和协议期限内有效在安全性方面相对较低，但可以提供更好的用户体验和系统性能。商业银行在选择API调用有效期的方式时，应根据业务需求、安全性要求、用户体验和系统性能等因素进行权衡和决策。"
        },
        "test_case": {
          "name": "授权有效期检测",
          "details": "1.查看接口文档：查阅接口的文档或相关说明，了解接口授权有效期的设定方式和规则，包括授权有效期的长度、起始时间、续期方式等。\n2.使用测试工具：根据接口文档配置请求参数，提供正确的授权信息，如令牌（token）或其他身份验证凭据，检查响应中是否包含授权有效期的相关信息，如授权令牌的有效期、过期时间等。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.3.2",
          "details": null
        }
      },
      {
        "name": "接口会话有效期过长",
        "details": "如果恶意用户能够获取到合法用户的会话标识符，而且会话有效期过长，他们可以利用该标识符获取对应用户的权限，并冒充该用户进行未经授权的操作。",
        "security_requirement": {
          "name": "会话有效期设置",
          "details": "设计会话有效期应依据业务的具体场景设置会话最小时间"
        },
        "security_design": {
          "name": "会话有效期设置",
          "details": "结合具体场景，依据业务必须的最小时间设计用户会话有效期，用户长期处于无业务操作时，结束会话，立即清理会话及其相关登录信息。"
        },
        "test_case": {
          "name": "接口会话有效期测试",
          "details": "登录目标系统获得会话，长时间（如15分钟）无操作之后再次利用该会话操作目标系统，测试会话是否失效。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.1 b）",
          "details": null
        }
      },
      {
        "name": "未接入互联网行为风控系统",
        "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统",
        "security_requirement": {
          "name": "接入互联网行为风控系统",
          "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统。"
        },
        "security_design": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "test_case": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》测试是否已接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "industry_standard": null
      }
    ]
  },
  "开户": {
    "threats": [
      {
        "name": "虚假信息提交",
        "details": "",
        "security_requirement": {
          "name": "虚假信息提交",
          "details": "确保系统能够有效防止虚假注册，保护系统资源和用户权益。"
        },
        "security_design": {
          "name": "虚假信息提交",
          "details": "身份验证强化：\n采用多因素认证方式，除常规的用户名密码外，增加手机验证码、人脸识别等环节，确保注册者身份真实可靠，减少虚假信息提交的可能，比如新用户注册时需通过短信验证码验证手机号归属。\n信息比对核查：\n与权威数据源（如身份证信息库、手机号实名库等）进行信息比对，对提交的关键注册信息进行校验，若发现不一致或异常情况则拒绝注册，保障进入系统的用户信息都是真实准确的。\n行为分析监测：\n分析注册过程中的行为模式，例如填写速度是否异常、IP 地址是否频繁变动等，对于存在可疑行为特征的注册尝试判定为虚假信息提交，及时拦截并提醒，以此维护系统资源以及其他合法用户的权益。"
        },
        "test_case": {
          "name": "虚假信息提交",
          "details": "测试方法：在应用程序中尝试创建新的账户，分别使用真实和虚假的注册信息进行测试。例如，输入虚假的姓名、邮箱、电话号码等信息。测试也可以包括尝试重复使用已经存在的用户名、邮箱等信息。\n预期结果：具备真实性和各数据之间匹配性验证，如果错误返回失败。"
        },
        "industry_standard": null
      },
      {
        "name": "身份盗用",
        "details": "",
        "security_requirement": {
          "name": "身份盗用",
          "details": "强身份验证：确保系统采用安全且可靠的身份验证机制，防止攻击者盗用他人的身份信息。\n监控与检测：实施监控与检测机制，及时发现异常的身份使用行为，并采取相应的应对措施。"
        },
        "security_design": {
          "name": "身份盗用",
          "details": "多因素身份验证运用\n综合运用多种身份验证要素，如将传统的账号密码与动态验证码（短信验证码、邮箱验证码等）、生物识别技术（指纹识别、面部识别、虹膜识别等）相结合。在用户登录、关键操作等环节要求通过多因素验证，这样一来，仅获取单一身份信息很难成功盗用身份，大大增强了身份验证的安全性。\n设备指纹识别技术\n引入设备指纹识别，通过收集用户登录设备的各种特征信息（如设备型号、操作系统版本、网络 IP 地址、MAC 地址等），为每台常用设备生成独一无二的 “指纹”。当用户再次登录时，比对设备指纹，若出现陌生设备尝试登录，即便账号密码正确，也需进一步验证，以此防范身份盗用行为，尤其能有效应对因账号密码泄露导致的盗用风险。\n行为分析与画像构建\n基于用户日常的操作行为习惯（如登录时间、操作频次、常用功能、操作地域等）构建行为画像，通过大数据分析和机器学习算法实时监测当前操作行为是否偏离正常画像范围。一旦发现异常，比如在非常规时间、从陌生地域频繁登录并进行关键操作，就判定为可疑行为，触发预警机制，及时干预以防止身份盗用造成损失。\n异常监控与预警体系\n搭建完善的身份使用异常监控系统，设定合理的预警阈值，实时关注身份验证、操作权限使用等方面的异常情况。例如，短时间内同一账号在多地登录、频繁尝试修改关键信息等行为超过一定次数时，系统立即发出警报通知管理员以及用户本人。同时，暂时限制可疑账号的部分操作权限，待进一步核实身份后再做处理，确保及时发现并应对身份盗用风险。"
        },
        "test_case": {
          "name": "身份盗用",
          "details": "测试方法：通过Fiddler抓包工具，获取A账户登陆成功后的数据包，将cookie复制替换到B账户的cookie值中，发送数据包查看响应包。\n预期结果：修改数据包后，响应报错或提示信息错误。"
        },
        "industry_standard": null
      },
      {
        "name": "验证码被猜测",
        "details": "图形验证码中的字符按照某种可预测的模式进行排列，攻击者可以通过分析这种模式来猜测正确的验证码。",
        "security_requirement": {
          "name": "图形验证码随机生成",
          "details": "应随机产生。"
        },
        "security_design": {
          "name": "图形验证码安全1",
          "details": "1、字符集选择：确定用于生成验证码的字符集。通常，字符集包括大写字母、小写字母和数字，并可以包含一些易于识别的特殊字符。 2、验证码长度：确定验证码的长度。一般来说，验证码长度应足够长，以增加猜测的难度和安全性，通常建议至少4个字符。 3、随机字符生成：使用安全的随机数生成算法从所选字符集中随机选择字符，生成验证码。确保生成的字符具有足够的随机性和不可预测性。"
        },
        "test_case": {
          "name": "图片验证码生成规律测试",
          "details": "请求10次观察验证码是否随机生成，如果存在一定的规律（例如5次后出现同一验证码）说明存在漏洞，完成检测"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "验证码可以通过OCR工具自动识别",
        "details": "验证码通常使用一些线条和一些不规则的字符组成，这些字符通常同时包含字母和数字。但有些Web程序设计的验证码较简单，仅由数字或字母组成，且生成的验证码字符排列规整，很容易被程序自动识别。",
        "security_requirement": {
          "name": "图形验证码具有一定干扰措施",
          "details": "应采取图片底纹干扰、颜色变换、设置非连续性及旋转图片字体、变异字体显示样式、交互式认证等有效方式，防止验证码被自动识别。"
        },
        "security_design": {
          "name": "图形验证码安全2",
          "details": "1、图片底纹干扰：在验证码图像的背景中添加随机的干扰元素，如噪点、线条、模糊效果等。2、颜色变换：使用随机的颜色组合来渲染验证码字符或背景。 3、设置非连续性：确保验证码字符在图像上不是连续排列的，而是以非常规的位置和顺序呈现。 4、旋转图片字体：对于验证码的每个字符，将其按照随机角度进行旋转。 5、变异字体显示样式：对于每个验证码字符，使用不同的字体、大小、粗细或斜体等变异样式。"
        },
        "test_case": {
          "name": "图形验证码自动识别测试",
          "details": "使用互联网上可下载的 OCR验证码识别工具、脚本等，测试确认图形验证码无法进行低成本的光学字符识别(OCR）。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "用户图形验证码可重复利用",
        "details": "如果图形验证码使用一次后未刷新，攻击者可在第一次验证失败后利用未刷新的验证码尝试再次验证，从而实现暴力破解。",
        "security_requirement": {
          "name": "图形验证码在使用一次后立刻失效",
          "details": "应具有使用时间限制并仅能使用一次。"
        },
        "security_design": {
          "name": "图形验证码安全3",
          "details": "图形验证码在使用一次后，不论验证成功或失败都立即刷新图形验证码。"
        },
        "test_case": {
          "name": "图形验证码复用测试",
          "details": "1、手工找到存在图形验证码的页面。2、尝试使用错误的图形验证码进行验证，验证失败后观察图形验证码是否刷新。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "验证码泄漏",
        "details": "应用系统的图形验证码是在前端通过JS生成的，攻击者可以很容易的控制图形验证码的生成内容。",
        "security_requirement": {
          "name": "图形验证码服务端处理",
          "details": "图形验证码应由服务器生成，客户端源文件中不应包含验证码文本。"
        },
        "security_design": {
          "name": "图形验证码安全4",
          "details": "1、服务器生成验证码：服务器接收到客户端的请求后，使用安全的随机数生成算法生成一个验证码。确保生成的验证码具有足够的复杂性和随机性。2、验证码图像生成：服务器使用生成的验证码文本，基于一些预定义的样式和参数，生成相应的验证码图像。这个过程可以利用图形库或工具来实现，生成包含验证码的图像。"
        },
        "test_case": {
          "name": "图形验证码生成方式测试",
          "details": "生成的验证码是否可以通过html源代码查看到，如果可以说明存在漏洞，完成检测。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 f)",
          "details": null
        }
      },
      {
        "name": "滑块验证相关风险1",
        "details": "滑块验证码过于简单将导致攻击者通过机器学习算法来分析验证码图片的特征，从而实现自动化破解。",
        "security_requirement": {
          "name": "滑块证码具有一定干扰措施",
          "details": "滑块验证码能够有效防止机器模拟验证。"
        },
        "security_design": {
          "name": "滑块验证码安全1",
          "details": "1、生成滑块验证码：服务器端生成一个包含滑块和背景图像的验证码。2、图像特征设置：在滑块和背景图像上分别设置一些独特的特征，如颜色、纹理、形状等。这些特征用于后续的验证过程。"
        },
        "test_case": {
          "name": "滑块验证码自动识别测试",
          "details": "使用互联网上开源的测试工具进行测试。"
        },
        "industry_standard": {
          "name": "JR/T 0213/2021：5.3.2.12 b）",
          "details": null
        }
      },
      {
        "name": "滑块验证相关风险2",
        "details": "攻击者能够通过某种手段获取到一次滑块验证码，他们可能能够在短时间内尝试多次验证。这增加了账户被攻击的风险。",
        "security_requirement": {
          "name": "滑块验证码在使用一次后立刻失效",
          "details": "滑块验证码认证1次后即刻失效。"
        },
        "security_design": {
          "name": "滑块验证码安全2",
          "details": "在验证码验使用后，立即将该验证码标记为已使用，使其失效。这样确保每个验证码只能使用一次，即使有人试图重复使用该验证码也会被拒绝。"
        },
        "test_case": {
          "name": "滑块验证码复用测试",
          "details": "1.手工找到具有短信发送功能的页面。 \\r\\n\n2.通过利用burp或者其它抓包截断工具，抓取校验验证码的数据包，并且进行重放攻击，观察同一个滑块验证码是否能使用多次。"
        },
        "industry_standard": {
          "name": "JR/T 0213/2021：5.3.2.12 c）",
          "details": null
        }
      },
      {
        "name": "本地存储导致的敏感信息泄露",
        "details": "API接口查询后如果将数据存储至本地存在较大的风险",
        "security_requirement": {
          "name": "客户侧敏感信息存储保护",
          "details": "对于金融产品持有份额用户积分等A2类只读信息查询，可使用API直接连接方式进行査询请求对接，应采取加密等措施保证査询信息的完整性与保密性，査询结果在应用方本地不得保存"
        },
        "security_design": {
          "name": "客户侧敏感信息存储保护",
          "details": "使用HTTPS协议传输，使用安全的算法对查询请求和返回的数据进行加密处理，使用数字签名等方式进行完整性保护。"
        },
        "test_case": {
          "name": "客户侧敏感信息存储测试",
          "details": "通过访谈方式，确定应用方是否保存查询结果。通过使用抓包工具等，测试验证查询信息在传输中是否是加密状态。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.2.2",
          "details": null
        }
      },
      {
        "name": "通信内容窃取及篡改",
        "details": "交易数据在通信过程中可能被窃取及篡改",
        "security_requirement": {
          "name": "交易通讯协议安全",
          "details": "应采用每次交易会话采取加密方式对业务数据进行加密处理，防止业务数据被窃取或者篡改。建议使用HTTPS和报文加密方式。"
        },
        "security_design": {
          "name": "HTTPS和端到端报文加密",
          "details": "1.采用HTTPS协议:\n使用TLS/SSL协议来加密在客户端和服务器之间传输的数据。\n确保服务器证书的有效性，以防止中间人攻击。\n2. 端到端报文加密:\n在业务数据传输过程中，使用加密算法对数据进行端到端的加密。\n选择强密码学算法，如AES，以确保高度的加密安全性。\n使用安全的密钥管理和分发机制，例如公钥基础设施（PKI）。"
        },
        "test_case": {
          "name": "交易通讯安全测试",
          "details": "检查HTTPS的部署和配置\n确保应用程序的交互采用HTTPS协议。\n验证SSL证书的有效性。\n\n端到端报文加密测试\n传输包含敏感业务数据的测试报文。\n使用网络抓包工具检查传输的数据是否加密。\n验证加密算法和密钥管理的正确性。"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.3.1 b）",
          "details": null
        }
      },
      {
        "name": "算法不安全导致信息泄漏",
        "details": "不安全的算法可能被攻击者破解获取敏感数据。如ECB加密模式或者固定IV，存在缺陷，可能导致加密数据被进行篡改或者是加密数据变得容易被解密。",
        "security_requirement": {
          "name": "使用安全的加密算法",
          "details": "默认使用国密加密算法，特殊情况无法使用时，不得使用存在安全问题或安全强度不足的密码算法对重要数据进行保护，如MD5、DES、SHA-1、RSA（不足2048比特）等密码算法"
        },
        "security_design": {
          "name": "加密安全",
          "details": "1、制定一个明确的加密策略文档，其中包含关于何时、如何以及使用哪些加密算法的详细指南。2、指定一个算法优先级列表，首选国密算法，然后是其他安全强度足够的算法，如AES（至少128位）、RSA（2048位或以上）、ECC（256位或以上）。3、考虑到加密算法可能受到国际出口控制法规的限制，确保加密算法的选择与使用遵守所有相关的法律法规。"
        },
        "test_case": {
          "name": "加密安全测试",
          "details": "通过访谈的方式确认加密算法是否满足要求。"
        },
        "industry_standard": {
          "name": "JR/T  0223/2021 7.2 a)",
          "details": null
        }
      },
      {
        "name": "数据篡改或伪造",
        "details": "如果数据在传输过程中没有进行完整性检查，可能会导致数据丢失或损坏，攻击者可能会篡改传输中的数据，可能导致敏感信息泄露、系统被破坏或业务受到损害。",
        "security_requirement": {
          "name": "数据传输完整性",
          "details": "对A1类应用采用MAC校验等手段保证数据传输完整性"
        },
        "security_design": {
          "name": "数据传输完整性",
          "details": "对于 A1 类应采用 MAC校验等手段，保证商业银行与应用方之间数据传输的完整性，必要时可使用数字签名技术。"
        },
        "test_case": {
          "name": "数据传输完整性测试",
          "details": "通过访谈方式，确定数据完整性保护的方式。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.2",
          "details": null
        }
      },
      {
        "name": "数据通讯不可信",
        "details": "如果数据在传输过程中没有进行签名校验，可能导致通讯方否认通信，或数据来源与与预期不一致，可能导致敏感信息泄露、系统被破坏或业务受到损害。",
        "security_requirement": {
          "name": "数据传输可信性",
          "details": "对A2类应用采用数字签名等手段保证数据传输完整性和不可抵赖性"
        },
        "security_design": {
          "name": "数据传输可信性",
          "details": "选择合适的数字签名算法。"
        },
        "test_case": {
          "name": "数据传输可信性测试",
          "details": "通过访谈方式，确定数据可信性保护的方式。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.2",
          "details": null
        }
      },
      {
        "name": "不安全的通信协议",
        "details": "使用不安全低版本的通信协议可能导致数据被窃取或泄露，如敏感信息、个人隐私数据或商业机密等。相关漏洞如：CVE-2016-2183，CVE-2016-6329，CVE-2011-3389，CVE-2013-2566，CVE-2015-2808等。",
        "security_requirement": {
          "name": "使用安全通信协议",
          "details": "应使用SSL/TLS等安全通信技术，应使用相对安全的高版本协议（TLS1.2及以上版本）"
        },
        "security_design": {
          "name": "使用安全通信协议",
          "details": "使用TLSv1.2以上版本安全通信协议。或者更改远程服务安全通信配置，使其不再接受存在漏洞的加密套件；修改SSL/TLS配置，移除弱加密算法，且使其不再接受弱加密套件；厂商主页下载http://www.openssl.org/升级补丁。"
        },
        "test_case": {
          "name": "TLS/SSL测试",
          "details": "使用TLS/SSL命令行测试工具testssl.sh，地址https://github.com/drwetter/testssl.sh，或者在官网https://testssl.sh/ 下载。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：9.2.2",
          "details": null
        }
      },
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "输入数据合法性验证",
          "details": "对用户输入信息做过滤，如：检查是否有输入过长、非法字符（包含但不限于< >\" ' % ( ) & + \\ \\' \\\"../等危险特殊字符）、输入不完整、输入值超过上限或者下限等错误，以防止用户输入中包含有恶意字符，引发存SQL注入、XSS等用户输入类漏洞。\n在用户输出阶段，通过语义输出编码方式，对从服务端返回到客户端的数据进行编码。比如HTML编码、URL编码等，编码形式需根据具体的应用场景选择 。"
        },
        "security_design": {
          "name": "输入数据合法性验证",
          "details": "1、必须对所有用户产生的输入进行校验，一旦数据不合法，应该告知用户输入非法并且建议用户纠正输入。2、必须对所有服务器产生的输入进行校验，一旦数据不合法，必须使会话失效，并记录告警日志。"
        },
        "test_case": {
          "name": "SQL注入测试",
          "details": "1.数字型\nhttp://host/test.php?id=100 and 1=1返回成功\nhttp://host/test.php?id=100 and 1=2返回失败\n2.字符型\nhttp://host/test.php?name=rainman’ and‘1’=‘1返回成功\nhttp://host/test.php?name=rainman’ and‘1’=‘2返回失败\n3.搜索型\n搜索型注入：简单的判断搜索型注入漏洞是否存在的办法是：\n先搜索（'），如果出错，说明90%存在这个漏洞。\n然后搜索（%），如果正常返回，说明95%有洞了。 \n然后再搜索一个关键字，比如（2006）吧，正常返回所有2006相关的信息。\n再搜索（2006%'and 1=1 and '%'='）和（2006%'and 1=2 and '%'='）\n4.绕过验证（常见的为管理登陆）也称万能密码\n(1)用户名输入： ‘ or 1=1 or ‘ 密码：任意\n(2)Admin’ - -（或‘ or 1=1 or ‘ - -）(admin or 1=1 --) (MSSQL)(直接输入用户名，不进行密码验证)\n(3)用户名输入：admin 密码输入：’ or ‘1’=’1 也可以\n(4)用户名输入：admin' or 'a'='a 密码输入：任意\n(5)用户名输入：‘ or 1=1 - -\n(6)用户名输入：admin‘ or 1=1 - - 密码输入：任意\n(7)用户名输入：1'or'1'='1'or'1'='1 密码输入：任意\n5.不同的SQL服务器连结字符串的语法不同，比如MSSQLServer使用符号+来连结字符串，而Oracle使用符号||来连结：\nhttp://host/test.jsp?ProdName=Book’ 返回错误\nhttp://host/test.jsp?ProdName=B’+’ook 返回正常\nhttp://host/test.jsp?ProdName=B’||’ook 返回正常说明有SQL注入\n2.如果应用程序已经过滤了’和+等特殊字符，我们仍然可以在输入时过把字符转换成URL编码（即字符ASCII码的16进制）来绕过检查。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "SQL注入",
        "details": "Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过控制可控参数来构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，严重时还可以对操作系统执行命令。",
        "security_requirement": {
          "name": "数据库参数化查询",
          "details": "使用参数化查询，或者ORM框架，例如常见的Java ORM框架包括Hibernate、MyBatis和Spring Data JPA等"
        },
        "security_design": {
          "name": "数据库参数化查询",
          "details": "1、在应用程序中执行数据库查询操作时，确保所有的查询语句都采用参数化查询的方式，避免直接拼接用户输入到查询语句中。2、根据具体选择的ORM框架（如Hibernate、MyBatis、Spring Data JPA），了解其安全配置和最佳实践，并按照指南进行设计和开发。配置ORM框架的数据映射规则，确保对象与数据库之间的映射正确且安全。注意处理敏感信息的加密、哈希等安全措施。"
        },
        "test_case": {
          "name": "SQL注入测试",
          "details": "1.数字型\nhttp://host/test.php?id=100 and 1=1返回成功\nhttp://host/test.php?id=100 and 1=2返回失败\n2.字符型\nhttp://host/test.php?name=rainman’ and‘1’=‘1返回成功\nhttp://host/test.php?name=rainman’ and‘1’=‘2返回失败\n3.搜索型\n搜索型注入：简单的判断搜索型注入漏洞是否存在的办法是：\n先搜索（'），如果出错，说明90%存在这个漏洞。\n然后搜索（%），如果正常返回，说明95%有洞了。 \n然后再搜索一个关键字，比如（2006）吧，正常返回所有2006相关的信息。\n再搜索（2006%'and 1=1 and '%'='）和（2006%'and 1=2 and '%'='）\n4.绕过验证（常见的为管理登陆）也称万能密码\n(1)用户名输入： ‘ or 1=1 or ‘ 密码：任意\n(2)Admin’ - -（或‘ or 1=1 or ‘ - -）(admin or 1=1 --) (MSSQL)(直接输入用户名，不进行密码验证)\n(3)用户名输入：admin 密码输入：’ or ‘1’=’1 也可以\n(4)用户名输入：admin' or 'a'='a 密码输入：任意\n(5)用户名输入：‘ or 1=1 - -\n(6)用户名输入：admin‘ or 1=1 - - 密码输入：任意\n(7)用户名输入：1'or'1'='1'or'1'='1 密码输入：任意\n5.不同的SQL服务器连结字符串的语法不同，比如MSSQLServer使用符号+来连结字符串，而Oracle使用符号||来连结：\nhttp://host/test.jsp?ProdName=Book’ 返回错误\nhttp://host/test.jsp?ProdName=B’+’ook 返回正常\nhttp://host/test.jsp?ProdName=B’||’ook 返回正常说明有SQL注入\n2.如果应用程序已经过滤了’和+等特殊字符，我们仍然可以在输入时过把字符转换成URL编码（即字符ASCII码的16进制）来绕过检查。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "过滤用户输入",
          "details": "采用输入复核或其他输入检查方式（检查是否有输入过长、非法字符、输入不完整、输入值超过上限或者下限等错误）"
        },
        "security_design": {
          "name": "过滤用户输入",
          "details": "1、对于每个输入字段，定义合理的最小和最大长度范围，并在后端对输入进行验证。2、定义允许的字符集，对用户输入进行检查，确保只有合法字符被接受。3、根据特定输入逻辑和业务需求，对其他字段的完整性进行验证，确保相关字段的输入满足预期规则。4、对于数值类型的输入，验证其是否在允许的范围内。例如，输入是否超过了字段定义的最大值或小于最小值。对于日期、时间等输入，确保输入值在可接受的范围内，避免无效或超出预期的输入。5、在前端和后端都使用适当的输入验证机制，包括正则表达式、数据类型验证、格式验证等，以确保输入的正确性和安全性。"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "服务端数据验证",
          "details": "使用服务器端代码执行其数据的输入验证。如果使用客户端验证方式，有可能发生攻击者绕过客户端验证或关闭客户端验证脚本进程的情况"
        },
        "security_design": {
          "name": "输入数据服务端验证",
          "details": "在服务器端进行业务逻辑验证，检查输入是否符合业务需求和预期。例如，验证某一字段的取值是否与其他字段相关联，或者是否符合特定的业务规则。"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "输出数据编码转义",
          "details": "在用户输出阶段，通过语义输出编码方式，对从服务端返回到客户端的数据进行编码。"
        },
        "security_design": {
          "name": "输出数据编码转义",
          "details": "1、对于在Web页面中显示的文本内容，使用HTML实体编码，将特殊字符转换为其对应的HTML实体。2、对于在URL参数中传递的数据，使用URL编码，将特殊字符转换为URL安全的表示形式"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "XSS",
        "details": "应用系统对用户提交的参数未做过滤或过滤不严，导致攻击者可向web页面中插入恶意代码，当用户浏览该页面时，恶意代码会被执行，攻击者可利用该漏洞窃取或操纵客户会话和cookie，用来模仿合法用户，从而使攻击者获得管理员权限，控制整个网站。",
        "security_requirement": {
          "name": "全局数据过滤",
          "details": "应用程序应设置全局过滤器，对用户提交的所有参数进行检查，验证时应使用白名单的方式进行匹配，发现非法字符跳转到错误页面。"
        },
        "security_design": {
          "name": "XSS过滤器",
          "details": "1、设置全局过滤器：在应用程序中设置一个全局过滤器，可以在请求到达服务器之前对用户提交的所有参数进行统一的检查和处理。 2、参数检查和验证：在全局过滤器中，对用户提交的所有参数进行检查，验证时应使用白名单的方式进行匹配。也就是说，只有在事先定义好的白名单中的字符才能通过验证，否则视为非法字符。 3、错误处理：如果发现用户提交的参数中包含非法字符，应当将用户重定向到错误页面，同时记录日志以便进行进一步的安全分析和处理。"
        },
        "test_case": {
          "name": "XSS漏洞测试",
          "details": "1、人工找到可能存在XSS漏洞的页面（涉及到将用户输入数据输出到前端的功能点）。2、插入XSS代码：<script>alert(1)</script>，保存后刷新页面，观察是否弹窗。"
        },
        "industry_standard": {
          "name": "JRT0068/2020:6.2.4.3 e)",
          "details": null
        }
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "敏感操作日志记录",
          "details": "应对个人金融信息访问与个人金融信息的增删改查等操作进行记录，并保证操作日志的完整性、可用性及可追溯性，操作日志包括但不限于业务操作日志、系统日志等"
        },
        "security_design": {
          "name": "敏感操作日志记录",
          "details": "1、明确哪些操作需要记录，如个人信息的新增、删除、更改等。2、根据操作的敏感性分级，确定日志的详细程度。3、定统一的日志格式，以便于分析和审计。4、确保所有操作都被记录，包括成功和尝试失败的操作。5、作发生时，日志应即时更新，避免延迟。"
        },
        "test_case": {
          "name": "日志记录规则测试",
          "details": "通过访谈的方式了解敏感操作日志记录规则。"
        },
        "industry_standard": {
          "name": "JR/T 0223/2021  7.4.2.1 c)",
          "details": null
        }
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "日志中的用户敏感数据脱敏",
          "details": "交易日志或系统日志中不可明文留存银行卡号（含他行卡号）、身份证号或手机号等客户敏感信息"
        },
        "security_design": {
          "name": "日志中的用户敏感数据脱敏",
          "details": "在日志记录之前，对敏感信息进行脱敏处理。这可以通过替换、掩码或哈希等方式来实现。例如，将银行卡号中间的数字掩码，只显示前六位和后四位（例如，123456******7890）。"
        },
        "test_case": {
          "name": "日志内容检测1",
          "details": "检查日志内容，搜索日志中是否记录用户敏感信息。"
        },
        "industry_standard": null
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "日志中的业务敏感数据脱敏",
          "details": "应用软件运行日志中不应打印支付敏感信息，不应打印完整的敏感数据原文"
        },
        "security_design": {
          "name": "日志中的业务敏感数据脱敏",
          "details": "在日志记录之前，通过自动化脱敏过程移除或替换所有识别出的敏感信息。可以使用正则表达式匹配敏感数据的模式，并将其替换为非敏感的占位符。"
        },
        "test_case": {
          "name": "日志内容检测2",
          "details": "检查日志内容，搜索日志中是否记录业务敏感信息。"
        },
        "industry_standard": null
      },
      {
        "name": "日志内容合规",
        "details": "合规威胁",
        "security_requirement": {
          "name": "统一客户识别编号",
          "details": "应使用统一的客户识别编号代替个人金融信息以输出到日志中，以提供故障排查处理能力"
        },
        "security_design": {
          "name": "统一客户识别编号",
          "details": "1、创建一个独特的、非敏感的客户识别编号体系。这个编号应该是唯一的，用来代替敏感的个人信息，如姓名、银行账号等。2、确保每个客户编号与相应的个人金融信息之间有一个持久化的映射关系，以便在需要时能够进行安全的查询和交叉引用。"
        },
        "test_case": {
          "name": "日志内容检测3",
          "details": "通过访谈了解日志中是否通过个人识别编号代替用户个人金融信息."
        },
        "industry_standard": null
      },
      {
        "name": "日志留存期限",
        "details": "日志留存时间过短将导致日志缺失，无法追溯安全事件。",
        "security_requirement": {
          "name": "日志留存时间应满足合规要求",
          "details": "日志记录应满足业务需要且最少留存1年"
        },
        "security_design": {
          "name": "日志留存时间设计",
          "details": "1、选择合适的存储解决方案，如本地服务器、网络存储或云服务，确保数据的可靠性和可访问性。2、制定并实施日志保留策略，明确规定所有日志至少保留一年，以符合法律法规要求。"
        },
        "test_case": {
          "name": "日志留存时间检测",
          "details": "通过访谈了解日志留存时间。"
        },
        "industry_standard": {
          "name": "JR/T0071.2/2020  7.1.4.3 c)",
          "details": null
        }
      },
      {
        "name": "接口监控日志缺失",
        "details": "接口监控日志缺失将导致无法追溯分析安全事件，影响系统的可维护性和安全性。",
        "security_requirement": {
          "name": "接口监控记录",
          "details": "对接口使用情况进行监控，具备完整记录的访问日志"
        },
        "security_design": {
          "name": "接口监控记录",
          "details": "1、确定监控范围和目标：明确需要监控的接口范围，哪些接口需要被监控，监控接口的调用频率、响应时间、错误率等。\n2、记录接口调用信息：在接口调用过程中，记录相关的调用信息，包括调用时间、调用方IP地址、接口名称、请求参数等，实现访问日志记录。"
        },
        "test_case": {
          "name": "接口监控测试",
          "details": "通过访谈了解监控范围，检查访问日志是否完整记录相关调用信息。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.3.3",
          "details": null
        }
      },
      {
        "name": "接口日志内容泄露",
        "details": "接口日志中记录的个人金融信息如果未受到足够的安全保护，可能会被黑客攻击或内部人员滥用，可能会导致银行卡号、密码、交易记录等敏感信息泄露。这些信息一旦泄露，可能会被用于欺诈、身份盗窃等不良行为，给个人财产和隐私带来严重威胁。",
        "security_requirement": {
          "name": "接口日志内容脱敏",
          "details": "个人金融信息不能在应用方接口日志中记录，且应以部分屏蔽的方式记录支付账号（或其等效信息）"
        },
        "security_design": {
          "name": "接口日志内容脱敏",
          "details": "因清分清算、差错对账等业务需要，应用方接口日志中应以部分屏蔽的方式记录支付账号(或其等效信息），除此之外的个人金融信息不在应用方接口日志中进行记录。"
        },
        "test_case": {
          "name": "接口日志内容检测",
          "details": "检查日志内容，搜索日志中是否记录个人金融信息。"
        },
        "industry_standard": {
          "name": "JR/T 0185/2020：7.3.3",
          "details": null
        }
      },
      {
        "name": "未接入互联网行为风控系统",
        "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统",
        "security_requirement": {
          "name": "接入互联网行为风控系统",
          "details": "客户行为相关的业务功能场景，需要接入互联网行为风控系统。"
        },
        "security_design": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "test_case": {
          "name": "接入互联网行为风控系统",
          "details": "参考说明文档《互联网行为风控系统介绍》测试是否已接入互联网行为风控系统，说明文档地址：\nhttps://alidocs.dingtalk.com/i/nodes/93NwLYZXWyQAxmb5hjAB7o1eWkyEqBQm?corpId=dingecde1c76b5919843a39a90f97fcb1e09&utm_medium=im_card&rnd=0.6717988236051256&iframeQuery=utm_medium%3Dportal_recent%26utm_source%3Dportal&utm_scene=person_space&utm_source=im"
        },
        "industry_standard": null
      }
    ]
  },
  "登出": {
    "threats": [
      {
        "name": "退出登录后会话凭证未失效1",
        "details": "用户退出系统后，服务器端Session未失效，攻击者可利用此Session向服务器继续发送服务请求。",
        "security_requirement": {
          "name": "退出登录或客户端后立即终止会话",
          "details": "退出登录或客户端程序、浏览器页面关闭后，应立即终止会话，保证无法通过后退、直接输入访问地址等方式重新进入登录后的页面。"
        },
        "security_design": {
          "name": "安全注销功能",
          "details": "应具备用户注销功能，用户注销时应清理了当前用户会话，用户注销时，清除与用户相关的session和cookie。"
        },
        "test_case": {
          "name": "会话重用测试",
          "details": "人工测试。检查客户端在退出时，是否向服务端发送终止会话请求。客户端退出后，还能否使用退出前的会话id访问登录后才能访问的页面。"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.4.3 a）",
          "details": null
        }
      },
      {
        "name": "退出登录后会话凭证未失效2",
        "details": "客户在退出登录后未取下（或断开）专用安全设备将会导致设备盗用等安全问题。",
        "security_requirement": {
          "name": "安全设备管理",
          "details": "退出登录时应提示客户取下（或断开）专用安全设备，例如，智能密码钥匙。"
        },
        "security_design": {
          "name": "安全设备管理",
          "details": "在用户执行退出登录操作时，系统检测用户是否连接了专用安全设备，例如智能密码钥匙。如果检测到设备仍处于连接状态，应显示一条明确的提示消息，提醒用户取下或断开专用安全设备。提示消息应采用清晰明确的语言，并使用适当的弹窗、提醒框或其他可见性高的方式呈现给用户。确保用户能够明白并按照提示采取相应操作。"
        },
        "test_case": {
          "name": "账号退出测试",
          "details": "1、人工找到需要插入安全设备介入的功能点。2、登录成功后退出账号，观察系统是否提示断开相应安全设备。"
        },
        "industry_standard": {
          "name": "JR/T 0068/2020：6.2.4.3 a）",
          "details": null
        }
      }
    ]
  },
  "账号注销": {
    "threats": [
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      }
    ]
  },
  "修改密码": {
    "threats": [
      {
        "name": "用户名密码重置",
        "details": "",
        "security_requirement": {
          "name": "用户名密码重置",
          "details": "1. 针对敏感操作需要进行二次验证\n2. 保证敏感操作的二次验证的不可绕过"
        },
        "security_design": {
          "name": "用户名密码重置",
          "details": "双重验证机制：\n实施短信验证码与动态口令相结合的二次验证。用户发起密码重置时，先接收短信验证码，再输入动态口令。动态口令由专门的安全令牌生成，基于时间或事件同步算法，具有唯一性与时效性，增加验证难度。\n流程严格把控：\n验证流程中，各环节紧密相连且不可回退。每步都与用户注册时预留信息及当前设备特征绑定，如设备指纹识别。若检测到异常设备或信息不匹配，立即终止并告警，确保无法绕过验证。\n实时监测防护：\n建立实时监测系统，分析验证行为特征。对短时间内多次尝试、异地请求等异常行为进行识别拦截，锁定异常账号并通知用户，有效防止非法绕过二次验证进行密码重置。\n"
        },
        "test_case": {
          "name": "用户名密码重置",
          "details": "测试方法：在密码修改、忘记密码、密码充值功能处是否有二次认证。\n预期结果：存在有效的二次认证或短信验证码等。"
        },
        "industry_standard": null
      }
    ]
  },
  "客户服务与支持": {
    "threats": [
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "身份认证安全",
        "details": "",
        "security_requirement": {
          "name": "身份认证安全",
          "details": "强密码策略：要求用户使用复杂度高的密码，包括足够长度、大小写字母、数字和特殊字符的组合。\n双因素认证：采用多因素认证机制，提高身份认证的安全性，例如结合密码和手机短信验证码。\n会话管理：有效管理用户的会话，防止会话劫持或会话固定攻击。\n锁定机制：在多次失败的身份认证尝试后，暂时锁定用户账户，防止暴力破解攻击。"
        },
        "security_design": {
          "name": "身份认证安全",
          "details": "强密码策略：\n设置密码创建规则，要求长度至少 8 位，且包含大小写字母、数字与特殊字符。定期提示用户更换密码，避免因长期使用单一密码引发安全风险，增强密码抗破解能力。\n双因素认证：\n除密码外，增加如手机短信验证码、指纹识别或硬件令牌等第二因素。用户登录时需双重验证，即使密码泄露，无第二因素配合，攻击者也难以突破认证，大幅提升安全性。\n会话管理：\n为会话分配唯一标识并加密传输，设置会话超时时间，用户长时间无操作自动注销会话。同时，验证会话来源合法性，防止攻击者窃取或篡改会话信息，有效抵御会话劫持与固定攻击。\n锁定机制：\n连续 3 - 5 次认证失败后，自动锁定账户 15 - 30 分钟。记录失败 IP 与时间，若短时间内同一 IP 多次触发锁定，可进一步限制访问或采取告警措施，阻止暴力破解攻击。\n"
        },
        "test_case": {
          "name": "身份认证安全",
          "details": "测试方法：\n1、登录应用系统，在登录界面查看是否使用了多因素认证，如短信验证码、图形验证码等。\n2、在注册功能处输入密码后，查看是否存在密码强度要求，如：\na)要求密码包含大写字母、小写字母、数字和特殊字符。\nb)要求密码长度达到规定的最小长度（如8位或以上）。\n预期结果：存在多因素认证，有对密码强度要求。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "个人信息维护": {
    "threats": [
      {
        "name": "目录遍历",
        "details": "",
        "security_requirement": {
          "name": "目录遍历",
          "details": "确保应用程序对文件系统的访问受到适当的限制，仅允许合法的文件访问。\n加强对用户输入的验证和过滤，防止恶意用户利用目录遍历漏洞进行攻击。"
        },
        "security_design": {
          "name": "目录遍历",
          "details": "访问权限限制：\n明确设定应用程序在文件系统中的访问范围，依据业务需求划分出可访问区域与禁止访问区域，仅授予访问合法文件的权限，如限定只能读取特定文件夹内文件，避免触及其他敏感目录。\n输入验证规则：\n制定严格的用户输入验证机制，用正则表达式等检查输入是否符合预期格式，像只允许输入合法文件名格式的内容，拒绝包含 “../”“..\\” 这类可用于目录遍历的特殊字符组合的输入。\n输入过滤处理：\n对用户输入仔细筛查，将诸如 “../” 等能引发目录遍历的字符及相关构造进行过滤，确保输入无法被利用来突破限定目录，访问不该访问的文件。\n异常监测反馈：\n搭建异常监测体系，实时留意文件访问中的异常情况，若出现频繁尝试突破访问限制等行为，及时记录并反馈，以便快速采取措施应对目录遍历攻击风险。"
        },
        "test_case": {
          "name": "目录遍历",
          "details": "测试方法：在传参 filepath 的地方或URL带有路径的文件下载 的地方，尝试输入\"../../../../../etc/passwd\"\n预期结果：已经过滤\"../\"，访问失败或报错。"
        },
        "industry_standard": null
      },
      {
        "name": "未授权访问、越权",
        "details": "",
        "security_requirement": {
          "name": "未授权访问、越权",
          "details": "确保用户的权限正确和最小化"
        },
        "security_design": {
          "name": "未授权访问、越权",
          "details": "权限管理：\n建立精细的权限分配体系，依据不同用户角色、岗位职能等明确各用户可操作的功能模块与数据范围，确保权限最小化。例如，普通员工仅能查看和操作与其自身工作相关的数据，禁止访问敏感或无关模块。\n采用多因素认证机制，如密码搭配动态验证码、指纹识别等，增强用户登录环节的安全性，防止未授权用户冒用他人账号访问系统。\n访问控制：\n在系统各层级（如页面、接口、数据资源等）设置严格的访问控制列表（ACL），明确规定哪些角色、用户可进行访问，其他无权限主体一律禁止访问。\n对关键操作、重要资源进行权限验证，每次访问请求时都严格核实用户权限是否匹配，杜绝越权操作行为。\n审计与监控：\n定期审计用户的权限变更情况，记录权限调整的时间、操作人、变动缘由等信息，便于追溯异常权限变动情况。\n实时监控用户的访问行为，通过日志记录等方式，分析是否存在异常的访问模式、频繁越权尝试等情况，一旦发现及时预警并处理。"
        },
        "test_case": {
          "name": "未授权访问、越权",
          "details": "测试方法：登录后访问其他用户/管理员特有的功能、URL 、API 等资源，观察时候访问成功。\n预期结果：访问失败或无权访问。"
        },
        "industry_standard": null
      },
      {
        "name": "个人信息泄露",
        "details": "",
        "security_requirement": {
          "name": "个人信息泄露",
          "details": "保护用户个人信息的隐私和安全，防止个人信息被未经授权的第三方获取和利用。\n加强对个人信息的访问控制和监控，确保个人信息的合法使用和安全存储。"
        },
        "security_design": {
          "name": "个人信息泄露",
          "details": "数据加密体系构建：\n采用多层次加密架构，对个人信息在存储、传输及使用过程进行全方位加密。在存储时，运用数据库加密技术对数据文件加密；传输过程中，借助 SSL/TLS 等加密协议保障数据通道安全；使用时，对内存中的敏感数据进行加密处理，防止因数据被窃取而导致信息泄露。\n网络隔离与防护：\n将存储个人信息的系统与外部网络进行有效隔离，部署防火墙、入侵检测与防御系统（IDS/IPS）等安全设备。防火墙可阻挡非法网络访问，IDS/IPS 实时监测并拦截可疑的网络攻击行为，降低外部恶意攻击导致个人信息泄露的风险。\n安全漏洞管理：\n建立定期的安全漏洞扫描与修复机制，对涉及个人信息处理的系统、应用程序等进行全面漏洞检测。及时发现并修复操作系统漏洞、软件漏洞、网络配置漏洞等，防止攻击者利用漏洞获取个人信息。同时，关注安全补丁更新，及时进行更新安装以保持系统安全性。"
        },
        "test_case": {
          "name": "个人信息泄露",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      },
      {
        "name": "数据存储及展示安全",
        "details": "",
        "security_requirement": {
          "name": "数据存储及展示安全",
          "details": "保证敏感数据的安全存储和展示。"
        },
        "security_design": {
          "name": "数据存储及展示安全",
          "details": "存储加密保障\n采用先进的加密算法，像 AES、RSA 等对敏感数据加密存储，设置严格的密钥管理机制，仅授权人员可获取。如此一来，即便存储介质被非法获取，数据也难以被破解查看，保障存储安全。\n访问权限严控\n依据角色和业务需求精细划分访问权限，仅允许有必要知晓的人员查看相关敏感数据，同时记录访问情况，防止内部人员违规操作，杜绝未授权的访问与展示。\n脱敏展示处理\n对于需对外展示的敏感数据，进行脱敏操作，如隐藏关键部分、用星号替代部分字符等，确保既能满足展示需求，又不会泄露关键敏感信息，维护展示环节安全。"
        },
        "test_case": {
          "name": "数据存储及展示安全",
          "details": "测试方法：\n1、查看回显到前端页面的敏感信息是否脱敏处理；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、敏感信息中使用*（或其他符号）替换；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  },
  "支付": {
    "threats": [
      {
        "name": "支付漏洞",
        "details": "",
        "security_requirement": {
          "name": "支付漏洞",
          "details": "1. 服务器端在生成交易订单时，商品的价格从数据库中取出，禁止使用客户端发送的商品价格。\n2. 服务器端对客户端提交的交易数据（如商品ID、商品数量、商品价格等）的取值范围进行校验，将商品ID和商品价格与数据库中的数据对比校验，商品数量为大于零的整型数。\n3. 服务器端在生成支付订单时，对支付订单中影响支付金额的所有因素（比如商品ID、商品数量、商品价格、订单编号等）进行签名，对客户端提交的支付订单进行校验"
        },
        "security_design": {
          "name": "支付漏洞",
          "details": "价格获取规范：\n服务器生成交易订单时，务必从数据库取商品价格，杜绝用客户端发送价格，防止客户端篡改价格造成支付漏洞，保障交易金额准确。\n数据取值校验：\n服务器要校验客户端提交的交易数据取值范围，比对商品 ID、价格与数据库记录，限定商品数量为正整数，避免异常数据影响支付金额准确性。\n支付订单签名：\n生成支付订单时，对影响支付金额的各因素签名，校验客户端提交的支付订单，以此验证订单完整性与真实性，有效堵住支付漏洞，确保支付安全。"
        },
        "test_case": {
          "name": "支付漏洞",
          "details": "测试方法：创建订单时，尝试输入不同的数据，包括合法已存在或非法的数据，例如订单数量、价格、产品信息等。观察系统对输入数据的反应。\n预期结果：创建失败。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌劫持",
        "details": "",
        "security_requirement": {
          "name": "令牌劫持",
          "details": "防止攻击者获取用户的身份验证令牌。\n加强对令牌的安全性管理，确保令牌只能被授权用户使用。"
        },
        "security_design": {
          "name": "令牌劫持",
          "details": "令牌生成安全强化：\n开发中采用高强度加密算法生成令牌，结合随机数、时间戳等多因素，确保令牌的唯一性与不可预测性。例如使用基于哈希的消息认证码（HMAC）算法，引入秘钥与用户特定信息生成令牌，使攻击者难以通过常规手段伪造，从源头上降低劫持风险。\n令牌传输加密：\n在令牌传输过程中，无论是在网络请求中还是在不同系统组件间传递，都强制使用安全的传输协议，如 HTTPS。对令牌进行加密传输，防止在网络传输线路上被窃取，确保令牌在传输阶段的保密性与完整性，避免被中间人攻击获取。\n令牌存储保护：\n在服务器端与客户端存储令牌时，采用加密存储方式。服务器端可利用数据库加密功能或自行加密后存储，客户端则借助安全的本地存储机制，如浏览器的 IndexedDB 或本地加密库，防止令牌因存储介质被攻破而泄露，保障令牌存储安全。\n令牌有效期管理：\n设置合理的令牌有效期，根据业务需求与安全考量，短则几分钟，长不过数小时。令牌过期后自动失效，要求用户重新登录获取新令牌，减少令牌长时间暴露被劫持利用的机会，降低攻击窗口时间。\n令牌使用验证：\n每次使用令牌进行身份验证时，不仅验证令牌本身的有效性，还结合用户的其他特征信息，如 IP 地址、设备指纹等进行多因素验证。若发现使用令牌的请求来源异常，如来自陌生 IP 或新设备，及时触发二次验证或直接拒绝，确保令牌被授权用户在合法环境下使用。\n异常行为监测：\n建立令牌使用异常行为监测系统，实时监测令牌的使用频率、使用时间、使用地点等。一旦发现异常，如短时间内令牌在多个不同地理位置使用或使用频率远超正常范围，立即暂停该令牌的使用，并通知用户进行安全确认，防止令牌被劫持后恶意利用。"
        },
        "test_case": {
          "name": "令牌劫持",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "令牌泄露",
        "details": "",
        "security_requirement": {
          "name": "令牌泄露",
          "details": "确保用户的身份验证令牌的安全性，防止令牌泄露给未经授权的第三方。\n加强对令牌的保护和管理，及时发现并应对泄露事件。"
        },
        "security_design": {
          "name": "令牌泄露",
          "details": "令牌生成安全：\n开发时采用强加密算法与随机因子生成令牌，如使用加密强度高的哈希函数结合随机字符串、时间戳等元素，确保令牌具备高度唯一性与不可预测性，让攻击者难以通过分析或猜测获取令牌，为令牌安全奠定坚实基础。\n传输加密措施：\n在令牌于客户端与服务器端传输过程中，强制启用安全传输协议，如 HTTPS。对令牌进行加密打包传输，防止在网络传输环节被中间人窃取或嗅探，保障令牌在传输路径中的保密性，避免信息泄露风险。\n存储加密与隔离：\n服务器端存储令牌时，利用数据库加密技术或自行加密后存储于安全区域，与其他数据隔离。客户端采用安全的本地存储机制，如加密的本地缓存或受保护的浏览器存储，防止因存储介质被攻破而导致令牌泄露，全方位守护令牌存储安全。\n定期令牌更新：\n设定合理的令牌更新周期，依据业务敏感程度与安全需求，定期强制用户重新登录获取新令牌，旧令牌自动失效。减少令牌长期存在被泄露利用的可能性，降低因单个令牌泄露而造成的长期安全隐患。\n异常监测与响应：\n搭建令牌使用异常监测系统，实时跟踪令牌的使用行为，包括使用频率、使用地点、使用时间间隔等参数。"
        },
        "test_case": {
          "name": "令牌泄露",
          "details": "测试方法：使用 Fiddler 抓包，等到一段较长时间之后或前端注销账号之后，重放此带有会话令牌的数据包，确认能否正确响应。\n预期结果：响应失败或错误。"
        },
        "industry_standard": null
      },
      {
        "name": "数据传输安全",
        "details": "",
        "security_requirement": {
          "name": "数据传输安全",
          "details": "保证传输数据的安全和敏感信息加密后传输。"
        },
        "security_design": {
          "name": "数据传输安全",
          "details": "加密算法运用：\n采用如 AES、RSA 等可靠加密算法，在数据传输前将敏感信息加密成密文，接收端再用对应密钥解密还原，即便传输途中数据被截获，攻击者也难以解读内容，保障数据机密性。\n安全传输协议：\n使用 HTTPS、SSL/TLS 等协议，为传输搭建安全通道，通过认证、加密、完整性校验等机制，验证通信双方身份，加密传输数据，确保数据完整性，防止被篡改或窃取，让数据传输安全可靠。\n传输监控审计：\n搭建监控系统，实时关注传输过程，记录传输详情，如时间、来源、去向等。定期审计分析，及时发现异常传输行为，比如频繁中断、超大流量等，及时排查并处理安全隐患。\n"
        },
        "test_case": {
          "name": "数据传输安全",
          "details": "测试方法：\n1、URL是否以https://开头；\n2、用 Fiddler 抓包查看POST Data 中的敏感字段是否加密。\n预期结果：\n1、使用 https 传输；\n2、POST Data 中的敏感字段已经加密（非 base64、MD5、URLcode等容易破解的方式）。"
        },
        "industry_standard": null
      }
    ]
  }
}